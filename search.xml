<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>9-25每周总结</title>
      <link href="/2020/09/25/9-25%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2020/09/25/9-25%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>这周选课费了不少精力，最终课表还算满意，时间没有想象中紧张。</p><p>又陷入了一种瓶颈，想学的太多，却没法专注下来利用好每个碎片时间。工作中也总是分神，也有环境嘈杂的原因。花了很多时间在梳理业务逻辑上，技术感觉没有长进。因此又伴随着一点焦虑。</p><p>下周目标：</p><ul><li>回归专注。不管在学什么做什么，让自己快速进入旁若无人的专注状态。</li></ul></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>9-19每周总结</title>
      <link href="/2020/09/19/9-19%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2020/09/19/9-19%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>最近感觉身体和精神状态不太好，睡眠时间不够，晚上老是管不住自己。</p><p>这周去了中日友好医院做核酸检测，去学校报道，回创空间收拾东西，参加了开学典礼。下周就要正式上课了。</p><p>技术上，看了100集JVM视频，能看懂，收获很大，对JVM内部结构总算基本清楚了。鹏哥的爬虫也在这周日暂时了结了，实在没精力搞，先放弃吧。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 每周总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9-12每周总结</title>
      <link href="/2020/09/12/9-12%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2020/09/12/9-12%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>这周在技术上的收获有：</p><ul><li>做排行榜优化，借此机会学了Redis，看完了狂神的Redis视频，算是入门。而且还写了lua脚本。</li><li>JavaGuide看到了Spring部分</li></ul><p>​    另外这周还在朋友圈看到鹏哥发的招兼职Java的信息，考虑了下就直接自荐了。主要是我觉得鹏哥很厉害很靠谱。聊了之后知道，鹏哥现在创业做留学择校算法推荐，而且算法已经被鹏哥写好了。我很想参与体验这个过程，但我目前能做的就是写爬虫，一个能入库，并且定时监控更新数据的爬虫。</p><p>​    虽然我很快就把流程捋清楚了，但却因为这件事，产生了很多心理时间。我又开始觉得，做这件事是不是偏离了自己的方向？自己Java基础还没打牢，就开始做别的，把时间花在学基础上不好吗？因为做这个，我这周几乎没有学算法。可是又不想辜负鹏哥的期望，借此机会学一学Python。</p><p>​    我总是什么都想要，却往往什么都得不到。一切的主动权在自己手里，等完成初版爬虫之后，预计要一两个月时间，就和鹏哥说退出。</p><p>下周要做出改变：</p><ul><li>不再创造心理时间和心理负担。有空的时间就做项目，解决问题，没空的时候就不想它。如果这样最后还是没达到预期目标，也认了，自己已经尽力</li><li>每天再忙也要看一点算法。永远不要丢弃算法。鹏哥现在也在刷LeetCode，足以说明算法的重要性</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 每周总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>9-06每周总结</title>
      <link href="/2020/09/06/9-06%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2020/09/06/9-06%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>这周主要是把BI的枚举配置抽离出来了。前期设计的时候没有完全弄清楚Spring Data ES的用法，只知道可以用Entity映射索引。在和存伟的讨论后，最终确定每个枚举放一个索引，再和游戏Id绑定。实际做的过程中，我想把枚举相关的DAO抽象出来，不然就要写很多几乎一样的Service、Dao、Entity。但是呢，我又发现Entity封装后索引就不能正常映射了。然后又把6个枚举的Dao放在了同一个Service里，用switch处理。虽然功能能实现，但我实在忍不了这样多余的代码，最终想办法利用反射，更少的代码实现了相同功能。这个过程还是很开心的。</p><p>其他印象深刻的事：</p><ul><li>周六公司游戏内测，所有人玩了一天的游戏</li><li>见了九龙，交流了面试的经验，共享了一些资料</li><li>看了诺兰的新片《信条》</li></ul><p>下周的重心：继续摸索自己工作之外的学习路线。暂时还没有必要为公司卖命，提升技术和能力是当下的主干道。</p><ul><li>JavaGuide</li><li>算法4</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 每周总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8-29每周总结</title>
      <link href="/2020/08/29/8-29%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2020/08/29/8-29%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>这周做了什么呢？</p><ul><li>BI初版完成，后面还有一些事情需要做：抽离统一配置，导出数据，集群分片设计等</li><li>学会了查服务器日志定位Bug</li><li>跟爸爸要了一年的学费，1.5w</li><li>和李业韬见面</li><li>开始养成存钱的习惯。工资全部存入余额宝，每月只给中行卡留1000元</li></ul><p>这周主要把BI上剩的一些零碎的问题都写完了，每次写代码的时候都很爽很专注，但平时大部分时间都在思考和学习，希望以后能有机会做更有挑战性的项目。JavaGuide也慢慢开始看了。工作中遇到的Java基础，也开始有意识的去学习解决。健哥说不能工作几年也没有成长，要学会在工作中学习。尽管对健哥没什么好感，但是他的一些理念还是很正确的。</p><p>我开始担心，现在工作中写代码的机会是不是太少了？游戏需求一般都是在现有框架上添些逻辑，BI其实也形成了套路，写好搜索模板，拼接一下结果就完事了。既然这样，就按照计划学自己的吧。</p><ol><li>《JavaGuide》 扫盲！</li><li>《设计模式之美》</li><li>《算法4》+LeetCode</li></ol></body></html>]]></content>
      
      
      <categories>
          
          <category> 每周总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8-22本周总结</title>
      <link href="/2020/08/22/8-22%E6%9C%AC%E5%91%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2020/08/22/8-22%E6%9C%AC%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>本周感觉花了很多时间在梳理业务需求上，常常感到手足无措。根本原因是我对项目没有一种全局观，无法确定问题的全部条件。比如BI的多游戏统一性，之前都没考虑过。</p><p>另外还明确了一件事，我到底要应付工作上班摸鱼学习，还是全力以赴对待工作，然后挤时间正大光明的学习？我选择后者。之前一直是第一种方式，偷偷摸摸地学自己的东西，经常担心别人看到，有些心理负担。工作任务虽然有很多重复性，技术含量不高的内容，但至少也能提高熟练度。工作任务进度不影响，自己学的时候也没有什么其他压力，不然两边都想着，什么都学不好。</p><p>这周最重要的一个决定，是我确定了要离职。我本身就是想学大数据的，如果在正确的路上，有匹配的工作项目去实践，哪怕工资低，成长也会很快。而现在我所做的事情很杂，后面主要精力也会被安排到游戏业务，靠工作之余学习大数据进步太慢。所以我一定会离职，可能两个月，也可能三个月后，先骑驴找马，因为我知道我现在的技术还很菜，突然离职也不一定能找到工作。下载了几本面经，补知识盲点。离职理由：20年毕业，想做大数据，试用期BI项目结束，后面没有想做的业务了。</p><p>下周主要目标是完成BI分配的任务，到月底要验收了。如果时间不够，加班也要做完。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 每周总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8-14本周总结</title>
      <link href="/2020/08/14/8-14%E6%9C%AC%E5%91%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2020/08/14/8-14%E6%9C%AC%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>​    这周主要在做英雄图鉴功能，第一次比较完整地做一个需求：定协议，改数据库格式，读配置，以及英雄属性相关的。感觉对整个流程更清晰了些。但是呢，我在理解业务需求，和客户端定协议，做属性投放这三块，都卡了很长时间。</p><p>​    我记得有两三天都处于一个很懵逼的状态，最后在黑哥吉帅的帮助下，总算也写完了需求，等周六和下周测试一下。ES方面我在周五梳理了一下时间格式，可选参数对之前写好的代码的影响，然后写了个工具类能够创建动态搜索模板了。商店模块开启了1/4左右。</p><p>​    空余时间快把《大话设计模式》看完了，有了大体印象，后面需要结合项目实际场景中加深理解。算法题也刷了几道，还在多抓鱼买了本《算法4》。安排上，必须看。</p><p>​    这周最悲伤的事是，黑哥要离职了┭┮﹏┭┮</p><p>下周如何改进：</p><ul><li>改变每天刷算法的方式，之前的方法性价比太低了。关注点放在解题思想和新的数据结构上，目标是能理解方法，弄清楚为什么这么做，而不是非要把代码实现调试出来</li><li>每遇到一个小问题，小知识点，都要把它搞明白，尤其是项目代码中一些没见过的基础用法，设计方式，硬啃一会总是能找到答案的。在项目场景下学Java基础，印象会更深刻，不要浪费学习框架底层优雅代码的机会。</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 每周总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8-7本周总结</title>
      <link href="/2020/08/07/8-7%E6%9C%AC%E5%91%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2020/08/07/8-7%E6%9C%AC%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>上周说要花更多时间在基础知识上，但是这周这方面并没有大的改进。</p><p>时间去哪了？</p><ul><li>看机器人代码和aladdin底层（如果业务理解程度足够，应该也能看懂，里面用到了很多Java基础和没见过的包，以及设计模式）</li><li>看英雄属性代码，查一个Bug（不了解业务，只能猜测，效率很低）</li><li>和策划确定日志格式，增加日志字段</li><li>写BI业务逻辑</li></ul><p>这周做的比较好的：</p><ul><li>每天10点开会前，都在自己看书。把《大型网站技术架构》看完了</li><li>坚持每天看LeetCode，哪怕没时间做也会看一下题解学习思路</li></ul><p>做的不好的：</p><ul><li>思路乱，不清晰。经常点点这点点那，也不知道在干什么，过一会才能回到主线</li><li>写代码之前，没有完全想明白，导致写了很多之后才发现逻辑有问题</li><li>效率低。大部分时间，脑子都是低速运转状态（不够专注）</li></ul><p>下周注意改进的地方：</p><ul><li>没捋清思路前，不要随处乱看乱动，让身体静下来，捋清楚逻辑顺序再往下进行，不要在不清楚自己要干什么的时候直接闷头做。勇于承认自己知识的不足，虚心请教别人</li><li>提高效率。经常提醒自己，脑子是否在高速运转。高速运转的同时，往往会让自己进入专注状态</li><li>对于通用技术问题比如Redis，Netty，Docker，设计模式等，在自己学习之后，如果有实在搞不明白的地方，一定要提前组织好语言，向黑哥，吉帅，存伟提出有价值有深度的问题</li></ul></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>8-1本周总结</title>
      <link href="/2020/08/01/8-1%E6%9C%AC%E5%91%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2020/08/01/8-1%E6%9C%AC%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>这周比上周有一些进步：</p><ol><li>代码写的更多了，很有成就感。Springboot ES原始日志数据查询，日期处理，字符串转换，代码生成器，React前端，每天一道的算法题等。在写代码的过程中体会到了基础的重要性，比如static和构造函数的执行顺序，单例模式的使用等。平时不写代码只看知识点的话，很难形成深刻的记忆。</li><li>终于想出了不用复杂聚合就能求出玩家等级分布的算法。我一直坚信这个问题有更好的解法，思考了好几天，找到答案的那一刻真的很开心，久违的快乐。存伟根据我的思路和demo更改了业务逻辑。</li></ol><p>学习和成长是急不得的，也不可能速成。不能太着急，只要每天有一点点进步就可以。这周也发现了一些其他问题。</p><ol><li>没有在工作中花更多时间学习基础知识。这周写代码的时候遇到了一些Java8的新特性，从来没有系统学过，不太会用，但是工作的时候为了尽快解决问题，就直接上网搜一些解决方案，最后虽然完成了任务，但在技术和基础知识上，没得到提升。有时候也是因为，担心别人看到自己在学其他的，感觉不太好，所以心里有点虚，也不敢上班时间直接拿起本书看。其实这根本没什么，就是自己没有完全放开，有点拘束。黑哥经常半天都不在工位上。</li><li>有时候闲下来午休的时候，把所有能刷遍的信息流都刷了一遍（知识星球，知乎，微信，微博），然后会陷入一种迷茫。我在想是不是只关心技术和业务就够了？会不会有局限？金融，历史，政治，我都很关心，但是呢，我要把大部分时间花在技术和业务上。如果一生除了家人爱人，只关注技术（主），业务（主），金融，历史，政治，也就足够了。其他的什么明星八卦，乱七八糟的新闻，何必care呢?</li></ol><p>学习策略改进：</p><ol><li>在工作中遇到没有完全掌握的基础知识，比如Java8新特性，设计模式，Springboot的使用等，一定不要急于赶进度，要花时间认真查资料学习，不要在意别人会不会看你在学什么。把学到的基础知识或新技术，在项目中找到应用场景，动手实践加深理解。</li></ol></body></html>]]></content>
      
      
      <categories>
          
          <category> 每周总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.25本周总结</title>
      <link href="/2020/07/25/7-25%E6%9C%AC%E5%91%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2020/07/25/7-25%E6%9C%AC%E5%91%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>工作上，发现和同事的技术差距很大。自己的基础不够好，导致学新东西比较慢不能很快上手，而且很容易陷入纠结原理之中，产出很低。一直在想如何在工作中提升自己的技术。我不缺时间，服务器部门现在压力不大，也有SpringBoot、ElasticSearch的应用场景。可我经常有那种感觉，就是一上午一下午过去了，自己好像什么也没做。</p><p>我知道知识很多，有学不完的知识，我也不怕花时间去学，但如果学习路线和方法不正确，这个过程就会很痛苦。痛苦我能坚持，但更希望能形成正反馈，在学习中找到快乐。</p><p>学习策略改进：</p><ol><li>工作上的开发任务，不用等原理都想清楚，所有潜在问题都弄清楚之后，再动手开始做。以做出东西为目标，查API，模仿着先做出来，更深的原理以后会有时间深入研究，不要卡在原理上停滞不前，至少先会用别人的工具。</li><li>任何非工作的时间，都只学习自己当前努努力能看懂的基础知识。比如Java核心，计网，算法等。每一份自己觉得能看懂的资料，在保证学习质量的前提下，都要花最短的时间，快速学完。我能超越别人的地方，就在于学习速度。现在可能还不够快，以后会成为我的核心竞争力。所以先把《Java核心技术36讲》和《图解HTTP》快速学完再学其他的吧。</li></ol></body></html>]]></content>
      
      
      <categories>
          
          <category> 每周总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>48-对称的二叉树</title>
      <link href="/2020/06/07/48-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/06/07/48-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></tbody></table></figure></div><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line"> / \</span><br><span class="line">2   2</span><br><span class="line"> \   \</span><br><span class="line"> 3    3</span><br></pre></td></tr></tbody></table></figure></div><p>示例 1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></tbody></table></figure></div><p>思路：如果是对称二叉树，那么它的前序遍历结果和自定义前序遍历（根右左）结果是相同的</p><p>1.递归实现</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot.left, pRoot.right);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//判断两个二叉树是不是镜像的</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode p1, TreeNode p2)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="keyword">null</span> && p2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="keyword">null</span> || p2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1.val != p2.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(p1.left, p2.right)&&isSymmetrical(p1.right, p2.left);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>上面思路的迭代实现：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">bool <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==NULL) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//两个队列，两种方式遍历</span></span><br><span class="line">        queue<treenode*> q1,q2;</treenode*></span><br><span class="line">        TreeNode *left,*right;</span><br><span class="line">        q1.push(root->left);</span><br><span class="line">        q2.push(root->right);</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty() and !q2.empty())</span><br><span class="line">        {</span><br><span class="line">            left = q1.front();</span><br><span class="line">            q1.pop();</span><br><span class="line">            right = q2.front();</span><br><span class="line">            q2.pop();</span><br><span class="line">            <span class="comment">//两边都是空</span></span><br><span class="line">            <span class="keyword">if</span>(NULL==left && NULL==right)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//只有一边是空</span></span><br><span class="line">            <span class="keyword">if</span>(NULL==left||NULL==right)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             <span class="keyword">if</span> (left->val != right->val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            q1.push(left->left);</span><br><span class="line">            q1.push(left->right);</span><br><span class="line">            q2.push(right->right);</span><br><span class="line">            q2.push(right->left);</span><br><span class="line">        }    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure></div><p>下面这两个乍一看好像都是BFS，画图走一遍会发现用栈和队列是有区别的，确实是DFS和BFS</p><p><strong>DFS使用stack</strong>来保存成对的节点</p><p>1.<strong>出栈</strong>的时候也是<strong>成对</strong>成对的 ，</p><p>若都为空，继续；</p><p>一个为空，返回false;</p><p>不为空，比较当前值，值不等，返回false；</p><p>2.确定入栈顺序，每次<strong>入栈</strong>都是成对<strong>成对</strong>的，如left.left， right.right ;left.rigth,right.left</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">boolean isSymmetricalDFS(TreeNode pRoot)</span><br><span class="line">    {</span><br><span class="line">        if(pRoot == null) return true;</span><br><span class="line">        Stack<treenode> s = new Stack<>();</treenode></span><br><span class="line">        s.push(pRoot.left);</span><br><span class="line">        s.push(pRoot.right);</span><br><span class="line">        while(!s.empty()) {</span><br><span class="line">            TreeNode right = s.pop();//成对取出</span><br><span class="line">            TreeNode left = s.pop();</span><br><span class="line">            if(left == null && right == null) continue;</span><br><span class="line">            if(left == null || right == null) return false;</span><br><span class="line">            if(left.val != right.val) return false;</span><br><span class="line">            //成对插入</span><br><span class="line">            s.push(left.left);</span><br><span class="line">            s.push(right.right);</span><br><span class="line">            s.push(left.right);</span><br><span class="line">            s.push(right.left);</span><br><span class="line">        }</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p><strong>BFS使用Queue</strong>来保存成对的节点，代码和上面极其相似</p><p>1.<strong>出队的时候也是成对成对</strong>的</p><p>若都为空，继续；</p><p>一个为空，返回false;</p><p>不为空，比较当前值，值不等，返回false；</p><p>2.确定入队顺序，<strong>每次入队都是成对成对的</strong>，如left.left， right.right ;left.rigth,right.left</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetricalBFS</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Queue<treenode> s = <span class="keyword">new</span> LinkedList<>();</treenode></span><br><span class="line">        s.offer(pRoot.left);</span><br><span class="line">        s.offer(pRoot.right);</span><br><span class="line">        <span class="keyword">while</span>(!s.isEmpty()) {</span><br><span class="line">            TreeNode left= s.poll();<span class="comment">//成对取出</span></span><br><span class="line">            TreeNode right= s.poll();</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="keyword">null</span> && right == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//成对插入</span></span><br><span class="line">            s.offer(left.left);</span><br><span class="line">            s.offer(right.right);</span><br><span class="line">            s.offer(left.right);</span><br><span class="line">            s.offer(right.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>55-剪绳子</title>
      <link href="/2020/05/30/55-%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
      <url>/2020/05/30/55-%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>思路：</p><p>动态规划或者贪婪算法。这道题目的临界点其实是4，也就是说4以下的其实不论怎么分，乘积都不可能比自身的数大。</p><p>如果没看出临界点4，可以这样写</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">      <span class="comment">//dp[n]表示，长度为n的绳子，对应的结果</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//依次往后求dp[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i <= n; i++){</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">          <span class="comment">//dp[i]等于从长度为2，3...的位置分别切一刀，然后乘以更小的dp,找到这个过程的最大值，就是dp[i]</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j < i; j++){</span><br><span class="line">                <span class="keyword">int</span> k = j*dp[i-j];</span><br><span class="line">              <span class="comment">//因为没发现临界点4，还需要考虑后面部分一刀也不切的情况</span></span><br><span class="line">                <span class="keyword">int</span> t = j*(i-j);</span><br><span class="line">                k = k > t ? k : t;</span><br><span class="line">                tmp = k > tmp ? k : tmp;</span><br><span class="line">            }</span><br><span class="line">            dp[i] = tmp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>如果考虑到了临界点4（其实也需要数学证明）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">         <span class="comment">// n<=3的情况，m>1必须要分段，例如：3必须分成1、2；1、1、1 ，n=3最大分段乘积是2,</span></span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        下面3行是n>=4的情况，跟n<=3不同，4可以分很多段，比如分成1、3，</span></span><br><span class="line"><span class="comment">        这里的3可以不需要再分了，因为3分段最大才2，不分就是3。记录最大的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="comment">//这里很重要，不能直接递归</span></span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;<span class="comment">//记录最大的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i <= target; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j <=i/<span class="number">2</span> ; j++) {</span><br><span class="line">                res=Math.max(res,dp[j]*dp[i-j]);</span><br><span class="line">            }</span><br><span class="line">            dp[i]=res;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>另外一种方法，是纯数学证明，最后得出的结论是：</p><p>切分规则</p><ol><li>最优： 3 。把绳子尽可能切为多个长度为 3 的片段，留下的最后一段绳子的长度可能为 0,1,2 三种情况。</li><li>次优： 2 。若最后一段绳子长度为 2 ；则保留，不再拆为 1+1 。</li><li>最差： 1 。若最后一段绳子长度为 1 ；则应把一份 3+1 替换为 2+2，因为 2×2>3×1。</li></ol><p>详细数学证明<a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/mian-shi-ti-14-i-jian-sheng-zi-tan-xin-si-xiang-by/" target="_blank" rel="noopener">看这里</a></p><p>也可以理解为贪婪算法：n>=5时，尽量多剪长度为3的绳子，当剩下的绳子长度为4时，把绳子切成2*2。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> timesOf3 = target / <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/*  当最后绳子长度为 4 时，这时候分割成 2，2 而不是 3，1 因为2*2=4 > 3=3*1  */</span></span><br><span class="line">        <span class="keyword">if</span> (target - timesOf3 * <span class="number">3</span> == <span class="number">1</span>)</span><br><span class="line">            timesOf3--;</span><br><span class="line">        <span class="keyword">int</span> timesOf2 = (target - timesOf3 * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(Math.pow(<span class="number">3</span>, timesOf3))*(<span class="keyword">int</span>)(Math.pow(<span class="number">2</span>, timesOf2));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>60-机器人的运动范围</title>
      <link href="/2020/05/30/60-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
      <url>/2020/05/30/60-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><p>思路：</p><p>1.从(0,0)开始走，每成功走一步标记当前位置为true,然后从当前位置往四个方向探索，</p><p>返回1 + 四个方向的探索值之和。</p><p>2.探索时，判断当前节点是否可达的标准为：</p><p>1）当前节点在矩阵内；</p><p>2）当前节点未被访问过；</p><p>3）当前节点满足limit限制。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">//记录是否访问过。boolean实例化后默认是false</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows][cols];</span><br><span class="line">        <span class="keyword">return</span> countSteps(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//递归访问</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSteps</span><span class="params">(<span class="keyword">int</span> limit,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> r,<span class="keyword">int</span> c,<span class="keyword">boolean</span>[][] visited)</span></span>{</span><br><span class="line">        <span class="comment">//如果坐标超出边界或者已经访问过，返回0</span></span><br><span class="line">        <span class="keyword">if</span>(r < <span class="number">0</span> || c < <span class="number">0</span> || r >= rows || c >= cols || visited[r][c])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = bitSum(r)+bitSum(c);</span><br><span class="line">        <span class="comment">//如果满足限制条件</span></span><br><span class="line">        <span class="keyword">if</span>(tmp <= limit){</span><br><span class="line">            <span class="comment">//标记已访问</span></span><br><span class="line">            visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//递归访问相邻的上下左右格子</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>+</span><br><span class="line">            countSteps(limit, rows, cols, r-<span class="number">1</span>, c, visited)+</span><br><span class="line">            countSteps(limit, rows, cols, r+<span class="number">1</span>, c, visited)+</span><br><span class="line">            countSteps(limit, rows, cols, r, c-<span class="number">1</span>, visited)+</span><br><span class="line">            countSteps(limit, rows, cols, r, c+<span class="number">1</span>, visited);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算数位和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bitSum</span><span class="params">(<span class="keyword">int</span> num)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>){</span><br><span class="line">            res += num%<span class="number">10</span>;</span><br><span class="line">            num = num/<span class="number">10</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>61-矩阵中的路径</title>
      <link href="/2020/05/29/61-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2020/05/29/61-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p><p>[[“a”,”b”,”c”,”e”],<br>[“s”,”f”,”c”,”s”],<br>[“a”,”d”,”e”,”e”]]</p><p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p><p>示例 1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"</span><br><span class="line">输出：true</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [["a","b"],["c","d"]], word = "abcd"</span><br><span class="line">输出：false</span><br></pre></td></tr></tbody></table></figure></div><p>思路：<strong>深度优先搜索（DFS）+ 剪枝</strong></p><ul><li>深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li><li>剪枝： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 <strong>可行性剪枝</strong> 。</li></ul><p>也可以理解为回溯法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>{</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < board.length; i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j < board[<span class="number">0</span>].length; j++){</span><br><span class="line">              <span class="comment">//从矩阵中每个字符开始，都dfs一下</span></span><br><span class="line">                <span class="keyword">if</span>(dfs(board, i, j, words, <span class="number">0</span>))  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//参数K表示board[i][j]在words中的索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[] words, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">      <span class="comment">//如果board[i][j]越界，或者不是索引k对应的字符</span></span><br><span class="line">        <span class="keyword">if</span>(i < <span class="number">0</span> || i >= board.length || j < <span class="number">0</span> || j >= board[<span class="number">0</span>].length || board[i][j] != words[k]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">//如果到了最后一位，说明找到了路径</span></span><br><span class="line">        <span class="keyword">if</span>(k == words.length - <span class="number">1</span>)   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">char</span> tmp = board[i][j];</span><br><span class="line">      <span class="comment">//标记已访问的位置</span></span><br><span class="line">        board[i][j] = <span class="string">'/'</span>;</span><br><span class="line">      <span class="comment">//向四个方向DFS</span></span><br><span class="line">        <span class="keyword">boolean</span> res = dfs(board, i-<span class="number">1</span>, j, words, k+<span class="number">1</span>)||dfs(board, i+<span class="number">1</span>, j, words, k+<span class="number">1</span>)||dfs(board, i, j-<span class="number">1</span>, words, k+<span class="number">1</span>)||dfs(board, i, j+<span class="number">1</span>, words, k+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(res) <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">      <span class="comment">//如果没找到路径，就回溯</span></span><br><span class="line">        board[i][j] = tmp;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>同样的思路，不同的写法（函数参数不同）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">//标记是否被访问</span></span><br><span class="line">        <span class="keyword">boolean</span>[] flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[matrix.length];</span><br><span class="line">        <span class="comment">//注意题中给的是一维数组matrix</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < rows; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j < cols; j++)</span><br><span class="line">                <span class="keyword">if</span>(judge(matrix, rows, cols, str, i, j, flag, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断以i,j坐标为起始点是否能找到符合条件的路径</span></span><br><span class="line">    <span class="comment">//start表示在一条路径中走过的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[] flag, <span class="keyword">int</span> start)</span></span>{</span><br><span class="line">        <span class="comment">//int index = rows*i + j;</span></span><br><span class="line">        <span class="comment">//这里注意，二维转一维坐标，不是上面的写法</span></span><br><span class="line">        <span class="keyword">int</span> index = cols*i + j;</span><br><span class="line">        <span class="comment">//如果坐标超出矩阵范围，或者已经在这个路径被访问过，或者坐标对应的值不对</span></span><br><span class="line">        <span class="keyword">if</span>(i < <span class="number">0</span> || j < <span class="number">0</span> || i >=rows || j >= cols || flag[index] || matrix[index] != str[start])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//如果start到了目标字符串str的长度，说明找到了一条符合条件的路径</span></span><br><span class="line">        <span class="keyword">if</span>(start == str.length-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//标记当前坐标已被访问</span></span><br><span class="line">        flag[index] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//向上下左右探索</span></span><br><span class="line">        <span class="keyword">if</span>(judge(matrix, rows, cols, str, i-<span class="number">1</span>, j, flag, start+<span class="number">1</span>)||</span><br><span class="line">           judge(matrix, rows, cols, str, i+<span class="number">1</span>, j, flag, start+<span class="number">1</span>)||</span><br><span class="line">           judge(matrix, rows, cols, str, i, j-<span class="number">1</span>, flag, start+<span class="number">1</span>)||</span><br><span class="line">           judge(matrix, rows, cols, str, i, j+<span class="number">1</span>, flag, start+<span class="number">1</span>)){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//注意这里要还原flag，此条路径不通，换下一条路径     </span></span><br><span class="line">        flag[index] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>32-数组中重复的数字</title>
      <link href="/2020/05/28/32-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2020/05/28/32-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><p>思路一：如果没有重复数字，那么正常排序后，数字i应该在下标为i的位置，所以思路是重头扫描数组，遇到下标为i的数字如果不是i的话，（假设为m),那么我们就拿与下标m的数字交换。在交换过程中，如果有重复的数字发生，那么终止返回ture</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++){< span><br><span class="line">            <span class="keyword">while</span>(nums[i]!=i){</span><br><span class="line">              <span class="comment">//nums[nums[i]] 是占据nums[i]本应所在位置的数字</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i]==nums[nums[i]]){</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                }</span><br><span class="line">                temp=nums[i];</span><br><span class="line">                nums[i]=nums[temp];</span><br><span class="line">                nums[temp]=temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></nums.length;i++){<></span></pre></td></tr></tbody></table></figure></div><ul><li>为什么不会出现一直卡在 while 循环中情况？ 假设 1：无重复元素，则每次交换后就有一个元素归位，最后所有元素都到了正确的位置，i处必有对应的数字，跳出循环；假设 2：有重复元素，如果没有nums[i] == i, while就会一个个把所有元素归位，直到最后发现重复的数字</li></ul><p>思路二：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        Map<integer, integer> map = <span class="keyword">new</span> HashMap<>();</integer,></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : nums){</span><br><span class="line">            <span class="keyword">if</span>(map.get(i) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.put(i,<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>974-和可被K整除的子数组</title>
      <link href="/2020/05/27/974-%E5%92%8C%E5%8F%AF%E8%A2%ABK%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2020/05/27/974-%E5%92%8C%E5%8F%AF%E8%A2%ABK%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。</p><p> 示例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [4,5,0,-2,-3,1], K = 5</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">有 7 个子数组满足其元素之和可被 K = 5 整除：</span><br><span class="line">[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]</span><br></pre></td></tr></tbody></table></figure></div><p>思路：<strong>一看到子数组和，要马上想到前缀和</strong></p><p>我们令 <strong>P[i] = A[0] + A[1] + … + A[i]</strong>。那么每个连续子数组的和 sum(i,j) 就可以写成 P[j] - P[i-1]（其中 0 < i < j）的形式。此时，判断子数组的和能否被 K 整除就等价于判断 (P[j]−P[i−1])modK==0，根据 同余定理，只要 P[j]modK==P[i−1]modK，就可以保证上面的等式成立。</p><p>因此我们可以考虑对数组进行遍历，<strong>在遍历同时统计答案</strong>。当我们<strong>遍历到第 i 个元素时，我们统计以 i 结尾的符合条件的子数组个数</strong>。我们可以维护一个<strong>以前缀和模 K 的值为键，出现次数为值的哈希表</strong>record，在遍历的同时进行更新。这样在计算以 i 结尾的符合条件的子数组个数时，根据上面的分析，答案即为 0..i-1 中前缀和模 K 也为 P[i]modK 的位置个数，即 <strong>record[P[i]modK]。</strong></p><p>最后的答案即为以每一个位置为数尾的符合条件的子数组个数之和。需要注意的一个边界条件是，我们需要<strong>对哈希表初始化，记录 record[0]=1，这样就考虑了前缀和本身被 K 整除的情况。</strong></p><p>注意：不同的语言负数取模的值不一定相同，有的语言为负数，对于这种情况需要特殊处理。</p><p>代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraysDivByK</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>{</span><br><span class="line">        Map<integer, integer> record = <span class="keyword">new</span> HashMap<>();</integer,></span><br><span class="line">      <span class="comment">//这里的初始化不能忘。不太好理解，跟着例子走一遍能体会到</span></span><br><span class="line">      <span class="comment">//当第一次出现 前缀和模k等于0 的时候，ans也要加一。后面就正常了</span></span><br><span class="line">        record.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> elem : A){</span><br><span class="line">            sum += elem;</span><br><span class="line">          <span class="comment">//对负数的处理</span></span><br><span class="line">            <span class="keyword">int</span> m = (sum%K + K)%K;</span><br><span class="line">            <span class="keyword">int</span> same = record.getOrDefault(m, <span class="number">0</span>);</span><br><span class="line">            ans += same;</span><br><span class="line">            record.put(m, same + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>287-寻找重复数</title>
      <link href="/2020/05/26/287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/"/>
      <url>/2020/05/26/287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p><p>示例 1:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br></pre></td></tr></tbody></table></figure></div><p>说明：</p><ol><li>不能更改原数组（假设数组是只读的）</li><li>只能使用额外的 O(1) 的空间</li><li>时间复杂度小于 O(n2) </li><li>数组中只有一个重复的数字，但它可能不止重复出现一次。</li></ol><p>思路：</p><p>​    这个题要注意细节。因为下面的限制条件，所以不能用哈希，也不能先排序。这道题要求我们查找的数是一个整数，并且给出了这个整数的范围（在 1 和 n 之间，包括 1 和 n），并且给出了一些限制，于是可以使用二分查找法定位在一个区间里的整数；</p><p>​    二分法的思路是先猜一个数（有效范围 [left, right]里的中间数 mid），然后统计原始数组中小于等于这个中间数的元素的个数 cnt。如果 cnt 严格大于 mid，根据抽屉原理，重复元素就在区间 [left, mid] 里；</p><p>与绝大多数二分法问题的不同点是：正着思考是容易的，即：思考哪边区间存在重复数是容易的，因为有抽屉原理做保证。我们通过一个具体的例子来分析应该如何编写代码；</p><p>以 [2, 4, 5, 2, 3, 1, 6, 7] 为例，一共 8 个数，n + 1 = 8，n = 7，根据题目意思，每个数都在 1 和 7 之间。</p><p>例如：区间 1, 7 的中位数是 4，遍历整个数组，统计小于等于 4 的整数的个数（记为cnt）。<strong>如果cnt小于4，那么重复数字一定在左边。如果cnt等于 4 ，那么重复数字一定在右边。但是，如果整个数组里小于等于 4 的整数的个数严格大于 4 的时候，就可以说明重复的数一定存在于区间 [1, 4]（也就是右边）</strong></p><p>这里最难理解的地方，就是cnt等于4的情况，可以用反证法证明，此时重复数字一定在右边。因为如果重复数字在左边，说明右边没有重复数字，那么右边数字的个数比抽屉的个数多1，即右边也有重复数字，矛盾。</p><p>代码：（边界处理还不熟练）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">      <span class="comment">//left right分别代表最小值1和最大值n(数组长度视为n+1)</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left < right) {</span><br><span class="line">            <span class="comment">// 左边界</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) {</span><br><span class="line">                <span class="keyword">if</span> (num <= mid) {</span><br><span class="line">                    cnt += <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 根据抽屉原理，小于等于 4 的个数如果严格大于 4 个</span></span><br><span class="line">            <span class="comment">// 此时重复元素一定出现在 [1, 4] 区间里</span></span><br><span class="line">            <span class="keyword">if</span> (cnt > mid) {</span><br><span class="line">                <span class="comment">// 重复元素位于区间 [left, mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 注意等于的情况，要想明白</span></span><br><span class="line">                <span class="comment">// [mid + 1, right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM总结</title>
      <link href="/2020/05/25/JVM%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/25/JVM%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>JVM调优说的是方法区和堆，这两个地方才有垃圾回收</p><p>类是模板，对象才是具体的</p><p>双亲委派机制</p><p>沙箱安全机制</p><p>native Java作用范围达不到了，调用C底层语言的库。进入本地方法栈，调用本地房方法栈接口 JNI</p><p>JNI作用是扩展Java的使用，融合不同编程语言。本地方法栈会登记native方法。</p><p>用途：Java程序驱动打印机，操作机器人</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26-连续子数组的最大和</title>
      <link href="/2020/05/23/26-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2020/05/23/26-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。</p><p>示例1:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></tbody></table></figure></div><p>思路：最简单暴力的方式，枚举每个子数组，但是复杂度为n*(n+1)/2，也就是O(n方)，不满足题目条件。</p><p>方法二：模拟人工流程走一遍。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>{</span><br><span class="line">        <span class="comment">//保存最大和</span></span><br><span class="line">        <span class="keyword">int</span> max_sum = array[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//保存累加和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < array.length; i++){</span><br><span class="line">            <span class="comment">//如果累加和小于0，就抛弃掉</span></span><br><span class="line">            <span class="keyword">if</span>(sum < <span class="number">0</span>)</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            sum = sum + array[i];</span><br><span class="line">            <span class="comment">//如果累加和大于当前记录的最大和，更新</span></span><br><span class="line">            <span class="keyword">if</span>(sum > max_sum)</span><br><span class="line">                max_sum = sum;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max_sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>方法三：动态规划</p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200523105723770.png" data-fancybox="group" data-caption="image-20200523105723770" class="fancybox"><img alt="image-20200523105723770" style="zoom:50%;" title="image-20200523105723770" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200523105723770.png" class="lazyload"></a><p>优化空间复杂度：由于 dp[i] 只与 dp[i-1] 和 nums[i] 有关系，因此可以将原数组 nums 用作 dp 列表，即直接在 nums 上修改即可。由于省去 dp 列表使用的额外空间，因此空间复杂度从 O(N) 降至 O(1) 。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < nums.length; i++) {</span><br><span class="line">            nums[i] += Math.max(nums[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">            res = Math.max(res, nums[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>169-数组中出现次数超过一半的数字</title>
      <link href="/2020/05/21/169-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2020/05/21/169-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1:</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></tbody></table></figure></div><p>思路：</p><p>方法一：最简单的方法是，先排序，然后找到中间位置的数。</p><p>方法二：采用阵地攻守的思想：第一个数字作为第一个士兵，守阵地；count = 1；遇到相同元素，count++;遇到不相同元素，即为敌人，同归于尽,count–；当遇到count为0的情况，又以新的i值作为守阵地的士兵，继续下去，到最后还留在阵地上的士兵，就是主元素。</p><p>方法二的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//当前阵地的士兵</span></span><br><span class="line">        <span class="keyword">int</span> cur = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < nums.length; i++){</span><br><span class="line">          <span class="comment">//如果阵地上没有士兵</span></span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>){</span><br><span class="line">                count++;</span><br><span class="line">                cur = nums[i];</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">              <span class="comment">//新加入的士兵，如果和当前阵地上的士兵一样，就一起站上去</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] == cur){</span><br><span class="line">                    count++;</span><br><span class="line">                }<span class="keyword">else</span>{</span><br><span class="line">                  <span class="comment">//如果不一样，就同归于尽</span></span><br><span class="line">                    count--;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">      <span class="comment">//返回最后阵地上留下的士兵</span></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>还有另一种写法：</p><p>（假设不知道是否存在满足条件的士兵，还需要在最后判断一下个数是否过半）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录士兵位置        </span></span><br><span class="line">        <span class="keyword">int</span> soldier = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < array.length; i++){</span><br><span class="line">            <span class="keyword">if</span>(array[i] == array[soldier])</span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                count--;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>){</span><br><span class="line">                <span class="comment">//这里要注意，新士兵的count为1</span></span><br><span class="line">                soldier = i;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">                </span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//最终检查</span></span><br><span class="line">        <span class="keyword">int</span> check_num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j < array.length; j++)</span><br><span class="line">            <span class="keyword">if</span>(array[j] == array[soldier])</span><br><span class="line">                check_num++;</span><br><span class="line">        <span class="keyword">if</span>(check_num > array.length/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> array[soldier];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>25-K个一组翻转链表</title>
      <link href="/2020/05/17/25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/05/17/25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p> 示例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你这个链表：1->2->3->4->5</span><br><span class="line"></span><br><span class="line">当 k = 2 时，应当返回: 2->1->4->3->5</span><br><span class="line"></span><br><span class="line">当 k = 3 时，应当返回: 3->2->1->4->5</span><br></pre></td></tr></tbody></table></figure></div><p>说明：</p><ul><li>你的算法只能使用<strong>常数的额外空间</strong>。</li><li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li></ul><p>思路：我首先想到的是头插法反转链表，但是不知道怎么处理这种K个一组的形式。然后想到了用栈，每次把k个节点入栈再出栈，就能得到反转的。但是实现起来有点问题，不知道怎么处理最后剩余不够K个的部分。链表使用经验还不够。</p><p>这是我的代码（未通过）：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        Stack<listnode> stack = <span class="keyword">new</span> Stack<>();</listnode></span><br><span class="line">        <span class="keyword">int</span> num = k;</span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        ListNode last_head = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">while</span>(num > <span class="number">0</span>){</span><br><span class="line">                stack.push(head);</span><br><span class="line">                head = head.next;</span><br><span class="line">                num--;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">          <span class="comment">//保存每一段链表的头和尾</span></span><br><span class="line">            ListNode tmp_head = stack.pop();</span><br><span class="line">            ListNode tmp_end = tmp_head;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(!stack.empty()){</span><br><span class="line">                tmp_end.next = stack.pop();</span><br><span class="line">                tmp_end = tmp_end.next;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(last_head != <span class="keyword">null</span>)</span><br><span class="line">                last_head.next = tmp_head;</span><br><span class="line">            <span class="keyword">if</span>(last_head == <span class="keyword">null</span>)</span><br><span class="line">                res = tmp_head;</span><br><span class="line"></span><br><span class="line">            last_head = tmp_end;</span><br><span class="line">            num = k;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>同样的思路，正确且简洁的写法是：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        Deque<listnode> stack = <span class="keyword">new</span> ArrayDeque<listnode>();</listnode></listnode></span><br><span class="line">      <span class="comment">//新建头节点</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode p = dummy;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">          <span class="comment">//tmp一直往后next,最后是每段长度为k链表尾部的下一个，也就是下一段未反转链表的开始</span></span><br><span class="line">          <span class="comment">//head一直处于每段链表的开始</span></span><br><span class="line">            ListNode tmp = head;</span><br><span class="line">          <span class="comment">//入栈</span></span><br><span class="line">            <span class="keyword">while</span> (tmp != <span class="keyword">null</span> && count < k) {</span><br><span class="line">                stack.add(tmp);</span><br><span class="line">                tmp = tmp.next;</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">          <span class="comment">//如果最后一段长度不够k</span></span><br><span class="line">            <span class="keyword">if</span> (count != k) {</span><br><span class="line">              <span class="comment">//p直接指向这段链表的头部head就可以，不用再管栈里的</span></span><br><span class="line">                p.next = head;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//出栈，并把每个节点接到p后</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()){</span><br><span class="line">                p.next = stack.pollLast();</span><br><span class="line">                p = p.next;</span><br><span class="line">            }</span><br><span class="line">          <span class="comment">//head重新指向下一段链表的头</span></span><br><span class="line">            head = tmp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>总结：p和tmp结点实现了利用栈，反转链表。head结点一直保存每段链表的头部，保证了在最后一段长度不够的时候，能直接让剩下的指向它。</p><p>另外还有一个思路，就是灵活运用头插法。虽然也想到了，但是不知道怎么实现，逻辑没，捋清楚。</p><p>来自大佬的<a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/solution/tu-jie-kge-yi-zu-fan-zhuan-lian-biao-by-user7208t/" target="_blank" rel="noopener">题解</a></p><p>步骤分解:</p><ol><li>链表分区为已翻转部分+待翻转部分+未翻转部分</li><li>每次翻转前，要确定翻转链表的范围，这个必须通过 k 次循环来确定</li><li>需记录翻转链表前驱和后继，方便翻转完成后把已翻转部分和未翻转部分连接起来</li><li>初始需要两个变量 pre 和 end，pre 代表待翻转链表的前驱，end 代表待翻转链表的末尾</li><li>经过k次循环，end 到达末尾，记录待翻转链表的后继 next = end.next</li><li>翻转链表，然后将三部分链表连接起来，然后重置 pre 和 end 指针，然后进入下一次循环</li><li>特殊情况，当翻转部分长度不足 k 时，在定位 end 完成后，end==null，已经到达末尾，说明题目已完成，直接返回即可</li></ol><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200517104458398.png" data-fancybox="group" data-caption="image-20200517104458398" class="fancybox"><img alt="image-20200517104458398" title="image-20200517104458398" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200517104458398.png" class="lazyload"></a></p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200517104556154.png" data-fancybox="group" data-caption="image-20200517104556154" class="fancybox"><img alt="image-20200517104556154" title="image-20200517104556154" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200517104556154.png" class="lazyload"></a></p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200517104703372.png" data-fancybox="group" data-caption="image-20200517104703372" class="fancybox"><img alt="image-20200517104703372" title="image-20200517104703372" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200517104703372.png" class="lazyload"></a></p><p>代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">    ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line"></span><br><span class="line">    ListNode pre = dummy;</span><br><span class="line">    ListNode end = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (end.next != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < k && end != <span class="keyword">null</span>; i++) end = end.next;</span><br><span class="line">        <span class="keyword">if</span> (end == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">        ListNode start = pre.next;</span><br><span class="line">        ListNode next = end.next;</span><br><span class="line">        end.next = <span class="keyword">null</span>;</span><br><span class="line">        pre.next = reverse(start);</span><br><span class="line">        start.next = next;</span><br><span class="line">        pre = start;</span><br><span class="line"></span><br><span class="line">        end = pre;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) {</span><br><span class="line">        ListNode next = curr.next;</span><br><span class="line">        curr.next = pre;</span><br><span class="line">        pre = curr;</span><br><span class="line">        curr = next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>24-二叉搜索树的后序遍历序列</title>
      <link href="/2020/05/16/24-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
      <url>/2020/05/16/24-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><p>参考以下这颗二叉搜索树：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></tbody></table></figure></div><p>思路：</p><p>观察二叉搜索树的后序遍历，比如x x x x y y y y y y R，x都比R小，y都比R大，R是根结点，x是左子树上的所有节点，y是右子树上的所有结点。明显的递归。要注意的是，二叉搜索树没有键值相等的点。另外在处理递归的时候，可以用两个指针标记一下，而不是截取复制数组。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(sequence.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> verify(sequence, <span class="number">0</span>, sequence.length-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">int</span> [] sequence, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>{</span><br><span class="line">        <span class="comment">//递归退出条件。这里值得好好想一下。如果start==end说明该树为空。如果start>end,也说明该树为空。</span></span><br><span class="line">        <span class="keyword">if</span>(start >= end)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> root = sequence[end];</span><br><span class="line">        <span class="keyword">int</span> i,j;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找出左右子树的范围start～i-1, i~end</span></span><br><span class="line">        i = start;</span><br><span class="line">        <span class="keyword">while</span>(sequence[i] < root)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>; j < end; j++)</span><br><span class="line">            <span class="keyword">if</span>(sequence[j] < root)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//左右子树递归判断</span></span><br><span class="line">        <span class="keyword">return</span> verify(sequence, start, i-<span class="number">1</span>)&&verify(sequence, i, end-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>102-二叉树的层序遍历</title>
      <link href="/2020/05/13/102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2020/05/13/102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></tbody></table></figure></div><p>返回其层次遍历结果：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p>思路：记录当前层和下一层的结点个数，用队列保存孩子结点</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> List<list<integer>> levelOrder(TreeNode root) {</list<integer></span><br><span class="line">        List<list<integer>> res = <span class="keyword">new</span> ArrayList<list<integer>>();</list<integer></list<integer></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)    <span class="keyword">return</span> res;</span><br><span class="line">      <span class="comment">//当前层结点数量</span></span><br><span class="line">        <span class="keyword">int</span> curCount = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//下一层结点数量</span></span><br><span class="line">        <span class="keyword">int</span> nextCount = <span class="number">0</span>;</span><br><span class="line">        Queue<treenode> queue = <span class="keyword">new</span> LinkedList<>();</treenode></span><br><span class="line">      <span class="comment">//根节点入队</span></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.peek() != <span class="keyword">null</span>){</span><br><span class="line">          <span class="comment">//开始添加一层的结点</span></span><br><span class="line">            List<integer> level = <span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">            <span class="keyword">while</span>(curCount != <span class="number">0</span>){</span><br><span class="line">                TreeNode tmp = queue.poll();</span><br><span class="line">                level.add(tmp.val);</span><br><span class="line">              <span class="comment">//左右子节点入队</span></span><br><span class="line">                <span class="keyword">if</span>(tmp.left != <span class="keyword">null</span>){</span><br><span class="line">                    queue.offer(tmp.left);</span><br><span class="line">                  <span class="comment">//记得下一层结点数量要加1</span></span><br><span class="line">                    nextCount++;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span>(tmp.right != <span class="keyword">null</span>){</span><br><span class="line">                    queue.add(tmp.right);</span><br><span class="line">                    nextCount++;</span><br><span class="line">                }</span><br><span class="line">              <span class="comment">//当前层数量减1</span></span><br><span class="line">                curCount--;</span><br><span class="line">            }</span><br><span class="line">          <span class="comment">//把这一层加到res中</span></span><br><span class="line">            res.add(level);</span><br><span class="line">          <span class="comment">//进入到下一层。更新当前层和下一层的结点数量</span></span><br><span class="line">            curCount = nextCount;</span><br><span class="line">            nextCount = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>22-替换空格</title>
      <link href="/2020/05/13/22-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>/2020/05/13/22-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p>思路：最简单的方式是用空间换时间，新建一个stringbuffer，根据条件往里append。如果在原字符串的基础上修改，首先算出空格的数量，然后得出新的字符串长度，并进行扩展，然后用两个指针从后往前赋值。</p><p>简单粗暴空间占用大的方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        StringBuffer in = <span class="keyword">new</span> StringBuffer(s);</span><br><span class="line">        StringBuffer out = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < s.length(); i++){</span><br><span class="line">            <span class="keyword">char</span> b = s.charAt(i);</span><br><span class="line">            <span class="comment">//String.valueOf(char c)表示将 char 变量 c 转换成字符串</span></span><br><span class="line">            <span class="keyword">if</span>(String.valueOf(b).equals(<span class="string">" "</span>)){</span><br><span class="line">                out.append(<span class="string">"%20"</span>);</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                out.append(b);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> out.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>在原字符串上修改的方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>{</span><br><span class="line">        <span class="comment">//空格数量</span></span><br><span class="line">        <span class="keyword">int</span> space_num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = str.length();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算空格数量</span></span><br><span class="line">        <span class="keyword">while</span>(i < length){</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == <span class="string">' '</span>)</span><br><span class="line">                space_num++;</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//计算新的长度</span></span><br><span class="line">        <span class="keyword">int</span> new_length = length + <span class="number">2</span>*space_num;</span><br><span class="line">        str.setLength(new_length);</span><br><span class="line">        <span class="comment">//两个指针</span></span><br><span class="line">        <span class="keyword">int</span> p = length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> q = new_length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(p > -<span class="number">1</span>){</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(p) == <span class="string">' '</span>){</span><br><span class="line">                str.setCharAt(q, <span class="string">'0'</span>);</span><br><span class="line">                str.setCharAt(q-<span class="number">1</span>, <span class="string">'2'</span>);</span><br><span class="line">                str.setCharAt(q-<span class="number">2</span>, <span class="string">'%'</span>);</span><br><span class="line">                q = q - <span class="number">3</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                str.setCharAt(q, str.charAt(p));</span><br><span class="line">                q--;</span><br><span class="line">            }</span><br><span class="line">            p--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>236-二叉树的最近公共祖先</title>
      <link href="/2020/05/10/236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <url>/2020/05/10/236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200510230610425.png" data-fancybox="group" data-caption="image-20200510230610425" class="fancybox"><img alt="image-20200510230610425" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200510230610425.png" class="lazyload" title="image-20200510230610425"></a></p><p>示例 1:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></tbody></table></figure></div><p><strong>说明:</strong></p><ul><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ul><p>思路：后序遍历是精髓。<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/" target="_blank" rel="noopener">别人的题解</a>也是看了好几遍才大致看懂</p><p><strong>祖先的定义：</strong> 若节点 p 在节点 root的左（右）子树中，或 p = root ，则称 root是 p 的祖先</p><p><strong>最近公共祖先的定义</strong>： 设节点 root 为节点 p,q 的某公共祖先，若其左子节点 root.left 和右子节点 root.right 都不是 p,q 的公共祖先，则称 root 是 “最近的公共祖先” 。</p><p>根据以上定义，若 root 是 p, q 的 最近公共祖先 ，则只可能为以下情况之一：</p><p>p 和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）；<br>p=root ，且 q 在 root 的左或右子树中；<br>q=root ，且 p 在 root 的左或右子树中；</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200510231014769.png" data-fancybox="group" data-caption="image-20200510231014769" class="fancybox"><img alt="image-20200510231014769" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200510231014769.png" class="lazyload" title="image-20200510231014769"></a></p><p><strong>考虑通过递归对二叉树进行后序遍历，当遇到节点 p 或 q 时返回。从底至顶回溯，当节点 p,q 在节点 root 的异侧时，节点 root 即为最近公共祖先，则向上返回 root 。</strong></p><p>递归解析：</p><ul><li>终止条件：<br>当越过叶节点，则直接返回 null ；<br>当 root 等于 </li><li>递推工作：<br>开启递归左子节点，返回值记为 left ；<br>开启递归右子节点，返回值记为 right ；</li><li>返回值： 根据left 和 right ，可展开为四种情况；<ul><li>当 left 和 right 同时为空 ：说明 root 的左 / 右子树中都不包含 p,q ，返回 null ；</li><li>当 left 和 right 同时不为空 ：说明 p, qp,q 分列在 root 的 异侧 （分别在 左 / 右子树），因此 root 为最近公共祖先，返回 root ；</li><li><strong>当 leftleft 为空 ，right 不为空 ：p,q 都不在 root 的左子树中，直接返回 right 。具体可分为两种情况：</strong><ol><li>p,q 其中一个在 root 的 右子树 中，此时 right 指向 p（假设为 p ）；<strong>（你可能会问：为什么会存在当left为空，right不为空的时候，p，q其中一个在root的右子树中的情况？left为空不就说明都在右边吗？举个栗子更好理解：假设当前节点 root ， p 在右子树中， q 在 root 的父节点的某个子树中，此时也是 left为空，right不为空的情况：只有 p 一个节点在 root 的子树中， 而 q 在 root 的祖先节点的其他子树中）</strong></li><li>p,q 两节点都在 root 的 右子树 中，此时的 right 指向 最近公共祖先节点 ；</li></ol></li><li>当 leftleft 不为空 ， right 为空 ：与情况 3. 同理；</li></ul></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> && right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 1.</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span>) <span class="keyword">return</span> right; <span class="comment">// 3.</span></span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>) <span class="keyword">return</span> left; <span class="comment">// 4.</span></span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// 2. if(left != null and right != null)</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 后序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21-二维数组中的查找</title>
      <link href="/2020/05/09/21-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>/2020/05/09/21-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p>思路：利用矩阵特点引入标志数，并通过标志数性质降低算法时间复杂度。</p><p>观察数组的性质，发现<strong>左下角元素为所在列最大元素，所在行最小元素，右上角元素为所在行最大元素，所在列最小元素</strong>。将 matrix 中的左下角元素（标志数）记作 flag ，则有:</p><ul><li>若 flag > target ，则 target 一定在 flag 所在行的上方，即 flag 所在行可被消去。</li><li>若 flag < target ，则 target 一定在 flag 所在列的右方，即 flag 所在列可被消去。</li></ul><p>所以如果以右上角（或左下角）为参考点，与target比较，可消去一行/列，筛选出新的矩形。如此往复，直到找到为止。选左下角当然也可以。</p><p>PS :此处不要想当然的把二维数组当做正方形，也可能是长方形</p><p>选用右上角作为标志点的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>{</span><br><span class="line">        <span class="comment">//（x, y）始终表示右上角的点</span></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x < array.length && y >= <span class="number">0</span>){</span><br><span class="line">            <span class="comment">//如果找到直接return true</span></span><br><span class="line">            <span class="keyword">if</span>(array[x][y] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//如果比目标值小</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[x][y] < target){</span><br><span class="line">                x++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//如果比目标值大</span></span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                y--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>221-最大正方形</title>
      <link href="/2020/05/08/221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
      <url>/2020/05/08/221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p><p>示例:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line"></span><br><span class="line">1 0 1 0 0</span><br><span class="line">1 0 1 1 1</span><br><span class="line">1 1 1 1 1</span><br><span class="line">1 0 0 1 0</span><br><span class="line"></span><br><span class="line">输出: 4</span><br></pre></td></tr></tbody></table></figure></div><p>思路：理解 min(上, 左, 左上) + 1</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (grid(i, j) == 1) {</span><br><span class="line">    dp(i, j) = min(dp(i-1, j), dp(i, j-1), dp(i-1, j-1)) + 1;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>其中，<strong>dp(i, j) 是以 <code>matrix[i][j]</code>为 右下角 的正方形的最大边长</strong></p><p>也就是：<strong>若某格子值为 1 ，则以此为右下角的正方形的、最大边长为：上面的正方形、左面的正方形或左上的正方形中，最小的那个，再加上此格</strong></p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200508172740321.png" data-fancybox="group" data-caption="image-20200508172740321" class="fancybox"><img alt="image-20200508172740321" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200508172740321.png" class="lazyload" title="image-20200508172740321"></a></p><p>理解了这个思路和上面的递推公式，代码就好写了</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>{</span><br><span class="line">    <span class="comment">// 基础判断</span></span><br><span class="line">    <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length < <span class="number">1</span> || matrix[<span class="number">0</span>].length < <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> height = matrix.length;</span><br><span class="line">    <span class="keyword">int</span> width = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> maxSide = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相当于已经预处理：新增第一行、第一列均为0。防止下面数组越界</span></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[height + <span class="number">1</span>][width + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row < height; row++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col < width; col++) {</span><br><span class="line">            <span class="keyword">if</span> (matrix[row][col] == <span class="string">'1'</span>) {</span><br><span class="line">              <span class="comment">//Math.min函数只接收两个参数，所以用两次</span></span><br><span class="line">                dp[row + <span class="number">1</span>][col + <span class="number">1</span>] = Math.min(Math.min(dp[row + <span class="number">1</span>][col], dp[row][col + <span class="number">1</span>]), dp[row][col]) + <span class="number">1</span>;</span><br><span class="line">                maxSide = Math.max(maxSide, dp[row + <span class="number">1</span>][col + <span class="number">1</span>]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> maxSide * maxSide;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>20-栈的压入、弹出序列</title>
      <link href="/2020/05/08/20-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/"/>
      <url>/2020/05/08/20-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><p>思路：</p><p>​    用辅助栈。按照要求的入栈顺序，依次入栈，同时检查，如果下一个要弹出的数字刚好是辅助栈的栈顶数字，那么直接弹出，如果不是，则继续入栈。但是如果按照这个思路写代码，可能有点难下手。</p><p>​    换一种说法：<strong>下个要弹出的数字如果是栈顶，直接弹出，如果不是，就辅助栈入栈直到满足条件，如果所有数字都压入栈后仍然没找到下个弹出的数字，结果就是false。</strong>两种思路描述的其实都是同样的流程，但是第一种描述的实现逻辑会更复杂。要看透题目思路的本质。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>{</span><br><span class="line">        Stack<integer> stack = <span class="keyword">new</span> Stack<>();</integer></span><br><span class="line">        <span class="comment">//用于标识弹出序列的位置</span></span><br><span class="line">        <span class="keyword">int</span> popIndex = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < pushA.length; i++){</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            <span class="comment">//如果栈不为空，且栈顶元素等于弹出序列</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.empty()&&stack.peek() == popA[popIndex]){</span><br><span class="line">                <span class="comment">//出栈</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">//弹出序列向后一位</span></span><br><span class="line">                popIndex++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>按照第一种描述写的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>{</span><br><span class="line">        Stack<integer> stack = <span class="keyword">new</span> Stack<>();  </integer></span><br><span class="line">        <span class="comment">//i，k保存位置</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        stack.push(pushA[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(i < pushA.length)</span><br><span class="line">            <span class="keyword">if</span>(stack.peek() != popA[k]){</span><br><span class="line">                <span class="keyword">while</span>(pushA[i] != popA[k]){</span><br><span class="line">                    stack.push(pushA[i]);</span><br><span class="line">                    i++;</span><br><span class="line">                }</span><br><span class="line">                i++;</span><br><span class="line">                k++;</span><br><span class="line">            }        </span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                stack.pop();</span><br><span class="line">                k++;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//画个图走一遍。很多细节写的时候才能注意到</span></span><br><span class="line">        <span class="keyword">while</span>(k < popA.length && stack.peek() == popA[k]){</span><br><span class="line">            stack.pop();</span><br><span class="line">            k++;</span><br><span class="line">        }   </span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>572-另一个树的子树</title>
      <link href="/2020/05/07/572-%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/"/>
      <url>/2020/05/07/572-%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p><p><strong>示例 1:</strong><br>给定的树 s:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \</span><br><span class="line">1   2</span><br></pre></td></tr></tbody></table></figure></div><p>给定的树 t：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  4 </span><br><span class="line"> / \</span><br><span class="line">1   2</span><br></pre></td></tr></tbody></table></figure></div><p>返回 <strong>true</strong>，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p><p><strong>示例 2:</strong><br>给定的树 s：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  4   5</span><br><span class="line"> / \</span><br><span class="line">1   2</span><br><span class="line">   /</span><br><span class="line">  0</span><br></pre></td></tr></tbody></table></figure></div><p>给定的树 t：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  4</span><br><span class="line"> / \</span><br><span class="line">1   2</span><br></pre></td></tr></tbody></table></figure></div><p>返回 <strong>false</strong>。</p><p>思路：这题和<a href="https://www.yanyunlong.cn/2020/05/04/18-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/">18-树的子结构</a>不一样，这道题的判断标准是t是s的一个子树而不是子结构。</p><p>递归实现：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(isSametree(s, t)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;   </span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      <span class="comment">//这里记得调用isSubtree，而不是isSametree。因为要递归</span></span><br><span class="line">        <span class="keyword">return</span> isSubtree(s.left, t)||isSubtree(s.right, t);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断两个数是否完全相同</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSametree</span><span class="params">(TreeNode s, TreeNode t)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> && t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || t == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.val != t.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSametree(s.left, t.left)&&isSametree(s.right, t.right);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库系统概论</title>
      <link href="/2020/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
      <url>/2020/05/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><h3 id="数据管理的三个阶段"><a href="#数据管理的三个阶段" class="headerlink" title="数据管理的三个阶段"></a>数据管理的三个阶段</h3><ul><li>人工管理阶段</li><li>文件系统阶段</li><li>数据库系统阶段</li></ul><h3 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h3><ul><li>数据（Data）<ul><li>计算机用来描述事物的记录（文字．图形．图像．声音）</li><li>数据的形式本身并不能完全表达其内容，需要经过语义解释。数据与其语义是不可分的</li></ul></li><li>数据库（Database，简称DB）<ul><li>数据库是长期存储在计算机内有结构的大量的共享的数据集合。</li></ul></li><li>数据库管理系统（DBMS）<ul><li>数据库管理系统是位于用户与操作系统之间的一层数据管理软件。</li><li>数据库在建立、运用和维护时由数据库管理系统统一管理、统一控制。</li><li>数据库系统（DBS）<ul><li>数据库系统是指在计算机系统中引入数据库后的系统构成，一般由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员和用户构成。 </li></ul></li></ul></li><li>数据冗余度：<ul><li>指同一数据重复存储时的重复程度。 </li></ul></li><li>数据的安全性（Security）<ul><li>数据的安全性是指保护数据，防止不合法使用数据造成数据的泄密和破坏，使每个用户只能按规定，对某些数据以某些方式进行访问和处理。 </li></ul></li><li>数据的完整性（Integrity）<ul><li>数据的完整性指数据的正确性、有效性和相容性。即将数据控制在有效的范围内，或要求数据之间满足一定的关系。 </li></ul></li><li>并发（Concurrency）控制<ul><li>当多个用户的并发进程同时存取、修改数据库时，可能会发生相互干扰而得到错误的结果并使得数据库的完整性遭到破坏，因此必须对多用户的并发操作加以控制和协调。</li></ul></li><li>数据库恢复（Recovery）<ul><li>计算机系统的硬件故障、软件故障、操作员的失误以及故意的破坏也会影响数据库中数据的正确性，甚至造成数据库部分或全部数据的丢失。DBMS必须具有将数据库从错误状态恢复到某一已知的正确状态（亦称为完整状态或一致状态）的功能。</li></ul></li></ul><h3 id="数据库的三要素"><a href="#数据库的三要素" class="headerlink" title="数据库的三要素"></a>数据库的三要素</h3><ul><li>数据（描述事物的符号记录，数据库里面存储的内容） </li><li>存储器（外存，一般是硬盘，数据库的载体）</li><li>数据库管理系统（DBMS，数据库的管理软件）</li></ul><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><ul><li>模型<ul><li>是现实世界特征的模拟和抽象</li></ul></li><li>数据模型<ul><li>也是一种模型，它是现实世界数据特征的抽象，表示实体以及实体间的联系</li><li>一个用于描述数据、数据间关系、数据语义和数据约束的概念工具的集合</li></ul></li><li>两级模型的抽象<ul><li>一是概念模型<ul><li>（也称信息模型，用于信息世界的建模），它是按用户的观点来对数据和信息建模，主要用于数据库设计。这类模型强调其语义表达能力，要能够较方便、直接地表达应用中的各种语义知识，这类模型应为概念简单、清晰、易于用户理解，是用户和数据库设计人员之间进行交流的语言。</li></ul></li><li>二是数据模型<ul><li>（如层次、网状、关系模型，用于机器世界），它是按计算机系统的观点对数据建模，主要用于DBMS的实现。这类模型通常需要有严格的形式化定义，而且常常会加上一些限制或规定，以便于机器上的实现。还通常有一组严格定义了语法和语义的语言，人们可以使用它来定义、操纵数据库中的数据。</li></ul></li></ul></li><li>数据模型的三要素<ul><li>（1） 数据结构<ul><li>数据结构是所研究的对象类型（Object Type）的集合。这些对象是数据库的组成部分。一般可分为两类：一类是与数据类型、内容、性质有关的对象，如网状模型中的数据项、记录，关系模型中的属性、关系等；一类是与数据之间联系有关的对象，如网状模型中的系型（Set Type）等。</li></ul></li><li>（2） 数据操作<ul><li>数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合。数据库主要有检索和更新（插入、删除、修改）两大类操作。</li><li>数据结构是对系统静态特性的描述，数据操作是对系统动态特性的描述。</li></ul></li><li>（3） 数据的约束条件<ul><li>数据的约束条件是完整性规则的集合。完整性规则是给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据状态以及状态的变化，以保证数据的正确、有效、相容。</li></ul></li></ul></li><li>概念模型<ul><li>实体（Entity）<ul><li>客观存在并可相互区别的事物称为实体。实体可以是具体的人、事、物，也可以是抽象的概念或联系，如学生、部门、课程、银行帐户、选课、订货、演出、比赛等。</li></ul></li><li>属性（Attribute）<ul><li>实体所具有的某一特性称为属性。如学生实体可以由学号、姓名、性别、出生年月、系、入学时间等属性组成</li></ul></li><li>码（关键字，Key）<ul><li>唯一标识实体的（最小的）属性集称为码。例如学号学生实体的码</li></ul></li><li>域（Domain）<ul><li>属性的取值范围称为该属性的域。例如学号的域为8位整数，姓名的域为字符串集合，，性别的域为（男，女）。</li></ul></li><li>实体型（Entity Type）<ul><li>具有相同属性的实体必然具有共同的特征和性质。用实体名及其属性名集合来抽象和刻划同类实体，称为实体型。例如：学生（学号，姓名，性别，出生年月，系，入学时间）</li></ul></li><li>实体集（Entity Set）<ul><li>同型实体的集合称为实体集。例如，全体学生就是一个实体集。</li></ul></li><li>联系（Relationship）<ul><li>在现实世界中，事物内部以及事物之间是有联系的，这些联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。〖组成实体的各属性之间以及不同实体集之间的联系〗</li></ul></li></ul></li></ul><h3 id="联系的种类"><a href="#联系的种类" class="headerlink" title="联系的种类"></a>联系的种类</h3><ul><li>1对1联系<ul><li>定义：若对于实体集A中的每一个实体，实体集B中至多有一个实体与之联系，反之亦然，则称实体集A与实体集B具有一对一联系，记为1:1。</li></ul></li><li>1对多联系<ul><li>定义：若对于实体集A中的每一个实体，实体集B中有n个实体(n≥0)与之联系，反之，对于对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，则称实体集A与实体集B具有一对多联系，记为1:n</li></ul></li><li>多对多联系<ul><li>定义：若对于实体集A中的每一个实体，实体集B中有n个实体(n≥0)与之联系，反之，对于对于实体集B中的每一个实体，实体集A中也有m个实体(m≥0)与之联系，则称实体集A与实体集B具有多对多联系，记为m:n</li></ul></li></ul><h3 id="概念模型的表示方法"><a href="#概念模型的表示方法" class="headerlink" title="概念模型的表示方法"></a>概念模型的表示方法</h3><ul><li>E-R图<ul><li>使用长方形来表示实体型，框内写上实体名</li><li>椭圆型表示实体的属性，并用无向边把实体和属性连接起来</li><li>用菱形表示实体间的联系，菱形框内写上联系名，用无向边把菱形分别与有关实体相连接，在无向边旁标上联系的类型，若实体之间联系也具有属性，则把属性和菱形也用无向边连接上</li><li></li></ul></li></ul><h3 id="基本数据模型"><a href="#基本数据模型" class="headerlink" title="基本数据模型"></a>基本数据模型</h3><ul><li>层次模型(Hierarchical Model)<ul><li>最早使用的一种模型</li><li>数据结构是一棵有向树</li><li>特点<ul><li>(1) 有且仅有一个结点无双亲，该结点称为根结点。</li><li>(2) 其他结点有且只有一个双亲</li></ul></li></ul></li><li>网状模型(Network Model)<ul><li>数据结构是一个有向图</li><li>特点<ul><li>（1）有一个以上的结点没有双亲</li><li>（2）结点可以有多于一个的双亲</li></ul></li><li>能表示实体之间的多种复杂联系</li></ul></li><li>关系模型(Relational Model)<ul><li>关系模型是用二维表格结构来表示实体及实体之间的联系的模型</li><li>数据结构是一个“二维表框架”组成的集合</li><li>关系模型概念简单,清晰,用户易懂易用,有严格的数学基础</li><li>大多数数据库系统都是关系型的</li><li>主要术语<ul><li>关系：一个关系对应于我们平常讲的一张表</li><li>元组：表中的一行称为一个元组</li><li>属性：表中的一列称为属性，每列的名称为属性名</li><li>主码：表中的某个属性组，它们的值唯一的标识一个元组</li><li>域：属性的取值范围</li><li>分量：元组中的一个属性值</li><li>关系模式：对关系的描述，用关系名（属性名1，属性名2，…，属性名n）来表示</li></ul></li><li>特点<ul><li><ol><li>概念单一：<ul><li>实体或实体之间的联系都用关系表示</li><li>用户的观点里，数据的逻辑结构就是表</li></ul></li></ol></li><li><ol start="2"><li>关系必须是规范化的关系<ul><li>指在关系模型中，每一个关系模式要满足一定的要求或者称为规范条件</li><li>其最基本的要求是每一个分量是一个不可分的数据项，也就是说，不允许表中还有表。</li></ul></li></ol></li><li><ol start="3"><li>用户对数据的检索操作不过是从原来的表中得到一张新的表<ul><li>在用户眼中，无论是原始数据还是结果数据，都是同一种数据结构——二维表。</li><li>数据操作是集合操作，即操作对象和操作结果都是若干元组的集合，而不象非关系模型中那样单记录的操作方式。</li><li>把存取路径向用户隐藏起来，提高了数据的独立性。</li></ul></li></ol></li></ul></li></ul></li></ul><h3 id="数据库系统的体系结构"><a href="#数据库系统的体系结构" class="headerlink" title="数据库系统的体系结构"></a>数据库系统的体系结构</h3><ul><li>三层模式：外模式、模式、内模式 <ul><li>外模式<ul><li>又称为用户模式，是数据库用户和数据库系统的接口，是数据库用户的数据视图，是数据库用户可以看见和使用的局部数据的逻辑结构和特征的描述</li><li>一个数据库通常都有多个外模式。一个应用程序只能使用一个外模式，但同一外模式可为多个应用程序所用</li></ul></li><li>模式<ul><li>可细分为概念模式和逻辑模式，是所有数据库用户的公共数据视图，是数据库中全部数据的逻辑结构和特征的描述。 </li><li>•一个数据库只有一个模式。模式不但要描述数据的逻辑结构，还要描述数据之间的联系、数据的完整性、安全性要求。 </li></ul></li><li>内模式<ul><li>又称为存储模式，是数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。 </li><li>•一个数据库只有一个内模式。内模式并不涉及物理记录，也不涉及硬件设备。</li></ul></li></ul></li><li>•二层映象功能：外模式/模式映象和模式/内模式映象 <ul><li>三层模式关系<ul><li>数据库模式是数据库的核心和关键，外模式通常是模式的子集。数据按外模式的描述提供给用户，按内模式的描述存储在硬盘上，而模式介于外、内模式之间，既不涉及外部的访问，也不涉及内部的存储，从而起到隔离作用，有利于保持数据的独立性，内模式依赖于全局逻辑结构，但可以独立于具体的存储设备</li></ul></li><li>映象<ul><li>是一种对应规则，说明映象双方如何进行转换。 </li></ul></li><li>外模式/模式映象<ul><li>作用：把描述局部逻辑结构的外模式与描述全局逻辑结构的模式联系趣来</li><li>当模式改变时，只要对外模式/模式映象做相应的改变，使外模式保持不变，则以外模式为依据的应用程序不受影响，从而保证了数据与程序之间的逻辑独立性，也就是数据的逻辑独立性 </li></ul></li><li>模式/内模式映象<ul><li>作用：把描述全局逻辑结构的模式与描述物理结构的内模式联系起来</li><li>当内模式改变时，比如存储设备或存储方式有所改变，只要模式/内模式映象做相应的改变，使模式保持不变，则应用程序就不受影响，从而保证了数据与程序之的物理独立性。</li></ul></li></ul></li></ul><h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><h3 id="关系模型组成的三要素"><a href="#关系模型组成的三要素" class="headerlink" title="关系模型组成的三要素"></a>关系模型组成的三要素</h3><ul><li>关系数据结构<ul><li>基本概念<ul><li>关系</li><li>关系模式<ul><li>什么是关系模式<ul><li>关系模式（Relation Schema）是型</li></ul></li><li>关系是值<ul><li>关系模式是对关系的描述</li></ul></li></ul></li><li>关系数据库</li></ul></li></ul></li><li>关系操作集合</li><li>关系完整性约束<ul><li>关系模型的完整性规则是对关系的某种约束条件</li><li>实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性，应该由关系系统自动支持。</li></ul></li></ul><h3 id="基本关系的六大性质"><a href="#基本关系的六大性质" class="headerlink" title="基本关系的六大性质"></a>基本关系的六大性质</h3><ul><li><p>① 列是同质的（Homogeneous）</p><ul><li>每一列中的分量是同一类型的数据，来自同一个域</li></ul></li><li><p>② 不同的列可出自同一个域</p><ul><li>其中的每一列称为一个属性</li><li>不同的属性要给予不同的属性名</li></ul></li><li><p>③ 列的顺序无所谓</p><ul><li>列的次序可以任意交换</li><li>遵循这一性质的数据库产品(如ORACLE)，增加新属性时，永远是插至最后一列。但也有许多关系数据库产品没有遵循这一性质，例如FoxPro仍然区分了属性顺序</li></ul></li><li><p>④ 任意两个元组的候选码不能完全相同</p><ul><li>候选码是可以惟一标识一个元组的属性或属性组。若一个关系中的候选码有多个，则选择一个作为主码</li></ul></li><li><p>⑤ 行的顺序无所谓</p><ul><li>行的次序可以任意交换</li><li>遵循这一性质的数据库产品(如ORACLE)，插入一个元组时永远插至最后一行。但也有许多关系数据库产品没有遵循这一性质，例如FoxPro仍然区分了元组的顺序</li></ul></li><li><p>⑥ 分量必须取原子值</p><ul><li>每一个分量都必须是不可分的数据项。</li></ul></li></ul><h3 id="关系模型中的三类完整性约束"><a href="#关系模型中的三类完整性约束" class="headerlink" title="关系模型中的三类完整性约束"></a>关系模型中的三类完整性约束</h3><ul><li>实体完整性</li><li>参照完整性<ul><li>外码（Foreign Key）</li></ul></li><li>用户定义的完整性</li></ul><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>关系代数是一种抽象的查询语言，用对关系的运算来表达查询，作为研究关系数据语言的数学工具。</li><li>关系代数的运算对象是关系，运算结果亦为关系。 </li></ul><h3 id="关系代数的运算"><a href="#关系代数的运算" class="headerlink" title="关系代数的运算"></a>关系代数的运算</h3><ul><li>普通的集合运算<ul><li>并、交、差</li></ul></li><li>删除部分关系的运算<ul><li>选择、投影</li></ul></li><li>合并两个关系元组的运算<ul><li>连接、积</li></ul></li><li>改名运算</li></ul><h3 id="关系代数-1"><a href="#关系代数-1" class="headerlink" title="关系代数"></a>关系代数</h3><ul><li>并Union (∪)<ul><li>R和S的并，R∪S，是在R或S或两者中的元素的集合</li><li>一个元素在并集中只出现一次</li><li>R和S必须同类型（属性集相同、次序相同，但属性名可以不同）</li></ul></li><li>交Intersect (∩)<ul><li>R和S的交，R∩S，是在R和S中都存在的元素的集合</li><li>一个元素在交集中只出现一次</li><li>R和S必须同类型（属性集相同、次序相同，但属性名可以不同）</li></ul></li><li>差Minus (-)<ul><li>R和S的差，R-S，是在R中而不在S中的元素的集合</li><li>R和S必须同类型（属性集相同、次序相同，但属性名可以不同）</li></ul></li><li>投影Projection(π)<ul><li>从关系R中选择若干属性组成新的关系</li><li>πA1,A2,…,An(R),表示从R中选择属性集A1,A2,…,An组成新的关系</li><li>列的运算</li><li>投影运算的结果中,也要去除可能的重复元组</li></ul></li><li>广义笛卡儿积(×)<ul><li>关系R、S的广义笛卡儿积是两个关系的元组对的集合所组成的新关系</li><li>R×S：<ul><li>属性是R和S的组合（有重复）</li><li>元组是R和S所有元组的可能组合</li><li>是R、S的无条件连接，使任意两个关系的信息能组合在一起</li></ul></li></ul></li><li>选择Selection(σ)<ul><li>从关系R中选择符合条件的元组构成新的关系</li><li>σC(R),表示从R中选择满足条件(使逻辑表达式C为真)的元组</li><li>行的运算</li></ul></li><li>条件连接(θ)<ul><li>从R×S的结果集中，选取在指定的属性集上满足AθB条件的元组，组成新的关系</li><li>θ是一个关于属性集的比较运算符</li><li>θ为“＝”的连接运算称为等值连接。</li></ul></li><li>自然连接<ul><li>从R×S的结果集中，选取在某些公共属性上具有相同值的元组，组成新的关系</li><li>R、S的公共属性<ul><li>属性集的交集（名称及类型相同）</li></ul></li><li>公共属性在结果中只出现一次</li><li>等值连接</li></ul></li><li>关系代数—除( ÷ )<ul><li>给定关系R(X,Y)和S(Y,Z)，其中X, Y, Z为属性组。R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集。R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在X属性列上的投影：元组在X上分量值x的象集Yx包含S在Y上投影的集合。</li><li>R÷S = {tr[X]| tr∈R∧πy       (S)Yx} </li><li>其中Yx为x在R中的象集，x=tr[X]。 </li><li>例子</li></ul></li></ul><h2 id="数据库语言SQL"><a href="#数据库语言SQL" class="headerlink" title="数据库语言SQL"></a>数据库语言SQL</h2><h3 id="SQL的发展"><a href="#SQL的发展" class="headerlink" title="SQL的发展"></a>SQL的发展</h3><ul><li>1974年，由Boyce和Chamberlin提出</li><li>1975~1979，IBM San Jose Research Lab的关系数据库管理系统原型System R实施了这种语言</li><li>SQL-86是第一个SQL标准</li><li>SQL-89、SQL-92(SQL2)、SQL-99(SQL3)</li></ul><h3 id="非过程化语言"><a href="#非过程化语言" class="headerlink" title="非过程化语言"></a>非过程化语言</h3><ul><li>SQL语言进行数据库操作时，只需要提出“做什么”，不需要指明“怎么做”。“怎么做”是由DBMS来完成</li></ul><h3 id="SQL的形式"><a href="#SQL的形式" class="headerlink" title="SQL的形式"></a>SQL的形式</h3><ul><li>交互式SQL<ul><li>一般DBMS都提供联机交互工具</li><li>用户可直接键入SQL命令对数据库进行操作</li><li>由DBMS来进行解释</li></ul></li><li>嵌入式SQL<ul><li>能将SQL语句嵌入到高级语言（宿主语言）</li><li>使应用程序充分利用SQL访问数据库的能力、宿主语言的过程处理能力</li><li>一般需要预编译，将嵌入的SQL语句转化为宿主语言编译器能处理的语句</li></ul></li></ul><h3 id="SQL语言主要组成部分"><a href="#SQL语言主要组成部分" class="headerlink" title="SQL语言主要组成部分"></a>SQL语言主要组成部分</h3><ul><li>数据定义语言（DDL，Data Definition Language）<ul><li>数据定义语言是指用来定义和管理数据库以及数据库中的各种对象的语句，这些语句包括CREATE、ALTER和DROP等语句。在SQL Server中，数据库对象包括表、视图、触发器、存储过程、规则、缺省、用户自定义的数据类型等。这些对象的创建、修改和删除等都可以通过使用CREATE、ALTER、DROP等语句来完成。</li><li>常见的数据类型<ul><li>字符型：<ul><li>定长字符型 char(n) 由于是定长，所以速度快</li><li>变长字符型 varchar(n)   </li></ul></li><li>数值型：<ul><li>整型 int(或integer)   -231~+231</li><li>短整型 smallint -215~+215的</li><li>浮点型 real、float、double</li><li>数值型 numeric (p [,d])</li></ul></li><li>日期／时间型：<ul><li>DateTime</li></ul></li><li>文本和图像型<ul><li>Text：存放大量文本数据。在SQLServer中，Text对象实际为一指针</li><li>Image：存放图形数据</li></ul></li></ul></li></ul></li><li>数据操纵语言（DML，Data Manipulation Language）<ul><li>数据操纵语言是指用来查询、添加、修改和删除数据库中数据的语句，这些语句包括SELECT、INSERT、UPDATE、DELETE等。在默认情况下，只有sysadmin、dbcreator、db_owner或db_datawriter等角色的成员才有权利执行数据操纵语言。</li></ul></li><li>数据控制语言（DCL，Data Control Language）<ul><li>数据控制语言（DCL）是用来设置或者更改数据库用户或角色权限的语句，这些语句包括GRANT、REVOKE 、DENY等语句，在默认状态下，只有sysadmin、dbcreator、db_owner或db_securityadmin等角色的成员才有权利执行数据控制语言。</li></ul></li></ul><h3 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h3><ul><li><p>建立表结构 Create</p><ul><li>定义基本表的语句格式：</li><li>CREATE TABLE <表名>(<列定义>[{,<列定义>,<表约束>}])</li><li>表名：</li><li>列定义：列名、列数据类型、长度、是否允许空值等。</li><li>定义完整性约束：列约束和表约束</li><li>[CONSTRAINT<约束名>] <约束定义></li></ul></li><li><p>删除表结构 Drop</p><ul><li>用SQL删除关系（表）<ul><li>将整个关系模式（表结构）彻底删除</li><li>表中的数据也将被删除</li></ul></li></ul></li><li><p>修改表结构 Alter</p><ul><li>增加表中的属性<ul><li>向已经存在的表中添加属性</li><li>allow null （新添加的属性要允许为空）</li><li>已有的元组中该属性的值被置为Null</li></ul></li><li>修改表中的某属性(某列)<ul><li>修改属性类型或精度</li></ul></li><li>删除表中的某属性(某列)<ul><li>去除属性及相应的数据</li></ul></li></ul></li><li><p>向表中添加数据(Insert)</p><ul><li>数据添加<ul><li>用SQL的插入语句，向数据库表中添加数据</li><li>按关系模式的属性顺序</li><li>按指定的属性顺序，也可以只添加部分属性（非Null属性为必需）</li></ul></li></ul></li><li><p>数据删除（Delete）</p><ul><li>只能对整个元组操作，不能只删除某些属性上的值</li><li>只能对一个关系起作用，若要从多个关系中删除元组，则必须对每个关系分别执行删除命令</li><li>删除单个元组</li><li>删除多个元组</li><li>删除整个关系中的所有数据</li></ul></li><li><p>数据更新（Update）</p><ul><li>改变符合条件的某个（某些）元组的属性值</li></ul></li><li><p>数据查询（Select）</p><ul><li><p>数据查询是数据库应用的核心功能</p></li><li><p>Select子句——重复元组</p><ul><li>SQL具有包的特性</li><li>Select 子句的缺省情况是保留重复元组（ ALL ），可用 Distinct 去除重复元组</li><li>去除重复元组:费时</li><li>需要临时表的支持</li></ul></li><li><p>Select子句—— *与属性列表</p><ul><li>星号 * 表示所有属性<ul><li>星号 * ：按关系模式中属性的顺序排列</li><li>显式列出属性名：按用户顺序排列</li></ul></li></ul></li><li><p>Select子句——更名</p><ul><li>为结果集中的某个属性改名</li><li>使结果集更具可读性</li></ul></li><li><p>Where 子句</p><ul><li>查询满足指定条件的元组可以通过Where子句来实现</li><li>使where子句中的逻辑表达式返回True值的元组，是符合要求的元组，将被选择出来</li><li>Where 子句——运算符<ul><li>比较：<、<=、>、>=、=、<> 等</li><li>确定范围：<ul><li>Between  A  and  B、Not Between A and B</li></ul></li><li>确定集合：IN、NOT IN</li><li>字符匹配：LIKE，NOT LIKE</li><li>空值：IS NULL、IS NOT NULL</li><li>多重条件：AND、OR、NOT</li></ul></li><li>Where 子句——Like<ul><li>字符匹配：Like、Not Like</li><li>通配符</li><li>% —— 匹配任意字符串</li><li>_   —— 匹配任意一个字符</li><li>大小写敏感</li></ul></li><li>Where 子句——转义符 escape </li></ul></li><li><p>From 子句</p><ul><li>列出将被查询的关系（表）</li><li>From 子句——元组变量<ul><li>为 From 子句中的关系定义元组变量</li><li>方便关系名的引用</li></ul></li><li>连接子句<ul><li>内连接<ul><li>内连接是指包括符合条件的每个表的记录，也称之为全记录操作。</li></ul></li><li>外连接<ul><li>外连接是指把两个表分为左右两个表。右外连接是指连接满足条件右侧表的全部记录。左外连接是指连接满足条件左侧表的全部记录。全外连接是指连接满足条件表的全部记录。</li><li>左外连接</li><li>右外连接</li><li>全外连接</li></ul></li></ul></li></ul></li><li><p>Order By子句</p><ul><li>指定结果集中元组的排列次序</li><li>耗时</li><li>ASC升序（缺省）、DESC降序</li></ul></li><li><p>子查询（Subquery ）</p><ul><li><p>子查询是嵌套在另一查询中的 Select-From-Where 表达式（Where/Having）</p></li><li><p>SQL允许多层嵌套，由内而外地进行分析，子查询的结果作为父查询的查找条件</p></li><li><p>可以用多个简单查询来构成复杂查询，以增强SQL的查询能力</p></li><li><p>子查询中不使用 Order By 子句，Order By子句只能对最终查询结果进行排序</p></li><li><p>子查询——单值比较</p><ul><li>返回单值的子查询，只返回一行一列</li><li>父查询与单值子查询之间用比较运算符进行连接<ul><li>运算符：>、>=、=、<=、<、 <></li></ul></li></ul></li><li><p>子查询——多值</p><ul><li><p>子查询返回多行一列</p></li><li><p>运算符：In、All、Some(或Any)、Exists</p><ul><li><p>子查询——多值成员In</p><ul><li>若值与子查询返回集中的某一个相等，则返回true<ul><li>IN 被用来测试多值中的成员</li></ul></li></ul></li><li><p>子查询——多值比较 ALL</p><ul><li><p>父查询与多值子查询之间的比较用All来连接</p></li><li><p>值s比子查询返回集R中的每个都大时，s>All R 为True </p></li><li><p>All表示所有</p></li><li><blockquote><p>all、< all、<=all、>=all、<> all</p></blockquote></li><li><p><> all 等价于 not in</p></li></ul></li><li><p>子查询——多值比较Some/Any</p><ul><li><p>父查询与多值子查询之间的比较需用Some/Any来连接</p></li><li><p>值s比子查询返回集R中的某一个都大时返回 Ture</p><ul><li>s > Some R为True  或 </li><li>s > Any R为True </li></ul></li><li><p>Some(早期用Any)表示某一个（任意一个）</p></li><li><blockquote><p>some、< some、<=some、>=some、<> some</p></blockquote></li><li><p>= some 等价于 in、<> some 不等价于 not in</p></li></ul></li></ul></li></ul></li><li><p>子查询——存在判断Exists</p><ul><li>Exists + 子查询用来判断该子查询是否返回元组</li><li>当子查询的结果集非空时，Exists为True</li><li>当子查询的结果集为空时，Exists为False</li><li>不关心子查询的具体内容，因此用 Select *</li><li>具有外部引用的子查询，称为相关子查询（Correlated Queries）</li><li>外层元组的属性作为内层子查询的条件</li></ul></li></ul></li><li><p>聚合函数</p><ul><li>把一列中的值进行聚合运算，返回单值的函数</li><li>五个预定义的聚合函数<ul><li>平均值：Avg( )</li><li>总和：  Sum( )</li><li>最小值：Min( )</li><li>最大值：Max( )</li><li>计数：  Count( )  返回所选列中不为NULL的数</li></ul></li><li>Group By<ul><li>将查询结果集按某一列或多列的值分组，值相等的为一组，一个分组以一个元组的形式出现</li><li>只有出现在Group By子句中的属性，才可出现在Select子句中</li></ul></li><li>Having<ul><li>针对聚合函数的结果值进行筛选（选择），它作用于分组计算结果集</li><li>跟在Group By子句的后面。</li></ul></li><li>Having 与 Where的区别<ul><li>Where 决定哪些元组被选择参加运算，作用于关系中的元组</li><li>Having 决定哪些分组符合要求，作用于分组</li><li>聚合函数的条件关系必须用Having，Where中不应出现聚合函数</li></ul></li><li>聚合函数对Null的处理<ul><li>Count：不计</li><li>Sum：不将其计入</li><li>Avg：具有 Null 的元组不参与</li><li>Max / Min：不参与</li></ul></li></ul></li></ul></li></ul><h3 id="视-图-VIEW"><a href="#视-图-VIEW" class="headerlink" title="视     图   (VIEW)"></a>视     图   (VIEW)</h3><ul><li>视图是从一个或者多个表或视图中导出的表，其结构和数据是建立在对表的查询基础上的。和真实的表一样，视图也包括几个被定义的数据列和多个数据行，但从本质上讲，这些数据列和数据行来源于其所引用的表。因此，视图不是真实存在的基础表而是一个虚拟表，视图所对应的数据并不实际地以视图结构存储在数据库中，而是存储在视图所引用的表中。</li><li>创建视图</li><li>视图的更新</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li>数据库中的索引与书籍中的索引类似，在一本书中，利用索引可以快速查找所需信息，无须阅读整本书。在数据库中，索引使数据库程序无须对整个表进行扫描，就可以在其中找到所需数据。书中的索引是一个词语列表，其中注明了包含各个词的页码。而数据库中的索引是某个表中一列或者若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单</li><li>索引的作用<ul><li>通过创建唯一索引，可以保证数据记录的唯一性。</li><li>可以大大加快数据检索速度。</li><li>可以加速表与表之间的连接，这一点在实现数据的参照完整性方面有特别的意义。</li><li>在使用ORDER BY和GROUP BY子句中进行检索数据时，可以显著减少查询中分组和排序的时间。</li><li>使用索引可以在检索数据的过程中使用优化隐藏器，提高系统性能</li></ul></li><li>聚集索引与非聚集索引<ul><li>聚集索引对表的物理数据页中的数据按列进行排序，然后再重新存储到磁盘上，即聚集索引与数据是混为一体的，它的叶节点中存储的是实际的数据</li><li>非聚集索引具有完全独立于数据行的结构，使用非聚集索引不用将物理数据页中的数据按列排序。非聚集索引的叶节点存储了组成非聚集索引的关键字值和行定位器</li></ul></li><li>创建索引</li></ul><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><ul><li>主键约束（primary key constraint）</li><li>唯一性约束（unique constraint）</li><li>检查约束（check constraint）</li><li>缺省约束（default constraint）</li><li>外部键约束（foreign key constraint）</li></ul><h3 id="SQL-SERVER权限管理"><a href="#SQL-SERVER权限管理" class="headerlink" title="SQL SERVER权限管理"></a>SQL SERVER权限管理</h3><ul><li>SQL Server权限管理策略 <ul><li>安全帐户认证 <ul><li>安全帐户认证是用来确认登录SQL Server的用户的登录帐号和密码的正确性，由此来验证其是否具有连接SQL Server的权限。 SQL Server 2000提供了两种确认用户的认证模式：<ul><li>（一）Windows NT认证模式。<ul><li>SQL Server数据库系统通常运行在Windows NT服务器平台上，而NT作为网络操作系统，本身就具备管理登录、验证用户合法性的能力，因此Windows NT认证模式正是利用了这一用户安全性和帐号管理的机制，允许SQL Server也可以使用NT的用户名和口令。在这种模式下，用户只需要通过Windows NT的认证，就可以连接到SQL Server，而SQL Server本身也就不需要管理一套登录数据。</li></ul></li><li>（二）混合认证模式。<ul><li>混合认证模式允许用户使用Windows NT安全性或SQL Server安全性连接到SQL Server，这就意味着用户可以使用他的帐号登录到Windows NT，或者使用他的登录名登录到SQL Server系统。NT的用户既可以使用NT认证，也可以使用SQL Server认证</li></ul></li></ul></li></ul></li><li>访问许可确认 <ul><li>但是通过认证阶段并不代表用户能够访问SQL Server中的数据，同时他还必须通过许可确认。用户只有在具有访问数据库的权限之后，才能够对服务器上的数据库进行权限许可下的各种操作，这种用户访问数据库权限的设置是通过用户帐号来实现的。</li></ul></li></ul></li><li>用户权限管理<ul><li>服务器登录帐号和用户帐号管理 <ul><li>1.利用企业管理器创建、管理SQL Server登录帐号<ul><li>（１）打开企业管理器，单击需要登录的服务器左边的“+”号，然后展开安全性文件夹。 </li><li>（２）用右键单击登录（login）图标，从快捷菜单中选择新建登录（new login）选项，则出现SQL Server登录属性—新建登录对话框，如图6-2所示。</li><li>（3）在名称编辑框中输入登录名，在身份验证选项栏中选择新建的用户帐号是Windows NT认证模式，还是SQL Server认证模式。 </li><li>（４）选择服务器角色页框。在服务器角色列表框中，列出了系统的固定服务器角色。 </li><li>（５）选择用户映射页框。上面的列表框列出了该帐号可以访问的数据库，单击数据库左边的复选框，表示该用户可以访问相应的数据库以及该帐号在数据库中的用户名。 </li><li>（６）设置完成后，单击“确定”按钮即可完成登录帐号的创建。 </li></ul></li><li>使用SQL 语句创建登录帐号</li><li>2.用户帐号管理 <ul><li>在数据库中，一个用户或工作组取得合法的登录帐号，只表明该帐号通过了Windows NT认证或者SQL Server认证，但不能表明其可以对数据库数据和数据库对象进行某种或者某些操作，只有当他同时拥有了用户权限后，才能够访问数据库。 </li><li>利用企业管理器可以授予SQL Server登录访问数据库的许可权限。使用它可创建一个新数据库用户帐号 </li></ul></li></ul></li><li>许可（权限）管理 <ul><li>许可用来指定授权用户可以使用的数据库对象和这些授权用户可以对这些数据库对象执行的操作。用户在登录到SQL Server之后，其用户帐号所归属的NT组或角色所被赋予的许可（权限）决定了该用户能够对哪些数据库对象执行哪种操作以及能够访问、修改哪些数据。在每个数据库中用户的许可独立于用户帐号和用户在数据库中的角色，每个数据库都有自己独立的许可系统，在SQL Server中包括三种类型的许可：即对象许可、语句许可和预定义许可。 <ul><li>三种许可类型<ul><li>1、对象许可<ul><li>表示对特定的数据库对象，即表、视图、字段和存储过程的操作许可，它决定了能对表、视图等数据库对象执行哪些操作。</li></ul></li><li>2、语句许可<ul><li>表示对数据库的操作许可，也就是说，创建数据库或者创建数据库中的其它内容所需要的许可类型称为语句许可。</li></ul></li><li>3、预定义许可<ul><li>是指系统安装以后有些用户和角色不必授权就有的许可。 </li></ul></li></ul></li></ul></li></ul></li><li>角色管理<ul><li>角色是SQL Server 7.0版本引进的新概念，它代替了以前版本中组的概念。利用角色，SQL Server管理者可以将某些用户设置为某一角色，这样只对角色进行权限设置便可以实现对所有用户权限的设置，大大减少了管理员的工作量。SQL Server提供了用户通常管理工作的预定义服务器角色和数据库角色。<ul><li>1、服务器角色<ul><li>服务器角色是指根据SQL Server的管理任务，以及这些任务相对的重要性等级来把具有SQL Server管理职能的用户划分为不同的用户组，每一组所具有的管理SQL Server的权限都是SQL Server内置的，即不能对其进行添加、修改和删除，只能向其中加入用户或者其他角色。 </li><li>几种常用的固定服务器角色 <ul><li>系统管理员：拥有SQL Server所有的权限许可。</li><li>服务器管理员：管理SQL Server服务器端的设置。</li><li>磁盘管理员：管理磁盘文件。</li><li>进程管理员：管理SQL Server系统进程。</li><li>安全管理员：管理和审核SQL Server系统登录。</li><li>安装管理员：增加、删除连接服务器，建立数据库复制以及管理扩展存储过程。</li><li>数据库创建者：创建数据库，并对数据库进行修改。</li></ul></li></ul></li><li>2、数据库角色 <ul><li>数据库角色是为某一用户或某一组用户授予不同级别的管理或访问数据库以及数据库对象的权限，这些权限是数据库专有的，并且还可以使一个用户具有属于同一数据库的多个角色。SQL Server提供了两种类型的数据库角色：即固定的数据库角色和用户自定义的数据库角色。 </li><li>（１）固定的数据库角色<ul><li>public：维护全部默认许可。</li><li>db_owner：数据库的所有者，可以对所拥有的数据库执行任何操作。</li><li>db_accessadmin：可以增加或者删除数据库用户、工作组和角色。</li><li>db_addladmin：可以增加、删除和修改数据库中的任何对象。</li><li>db_securityadmin：执行语句许可和对象许可。</li><li>db_backupoperator：可以备份和恢复数据库。</li><li>db_datareader：能且仅能对数据库中的任何表执行select操作，从而读取所有表的信息。</li><li>db_datawriter：能够增加、修改和删除表中的数据，但不能进行select操作。</li><li>db_denydatareader：不能读取数据库中任何表中的数据。</li><li>db_denydatawriter：不能对数据库中的任何表执行增加、修改和删除数据操作。 </li></ul></li><li>（２）用户自定义角色 <ul><li>创建用户定义的数据库角色就是创建一组用户，这些用户具有相同的一组许可。如果一组用户需要执行在SQL Server中指定的一组操作并且不存在对应的Windows NT组，或者没有管理Windows NT用户帐号的许可，就可以在数据库中建立一个用户自定义的数据库角色。用户自定义的数据库角色有两种类型：即标准角色和应用程序角色。</li></ul></li></ul></li></ul></li></ul></li></ul></li><li>Transaction_SQL 语句<ul><li>赋权语句——Grant</li><li>收回权限——Revoke </li><li>收回权限——Deny </li></ul></li></ul><h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li>关系系统和关系模型是两个密切相关而有不同的概念。支持关系模型的数据库管理系统称为关系系统。但是关系模型中并非每一部分都是同等重要的，所以我们不苛求完全支持关系模型的系统才能称为关系系统。因此，我们给出一个关系系统的最小要求以及分类的定义。 </li><li>关系系统的定义<ul><li>1.支持关系数据库（关系数据结构）<ul><li>从用户观点看，数据库由表构成，并且只有表这一种结构。</li></ul></li><li>2.支持选择、投影和（自然）连接运算，对这些运算不必要求定义任何物理存取路径 <ul><li>当然并不要求关系系统的选择、投影、连接运算和关系代数的相应运算完全一样，而只要求有等价的这三种运算功能就行。 </li></ul></li></ul></li></ul><h3 id="查询优化-1"><a href="#查询优化-1" class="headerlink" title="查询优化"></a>查询优化</h3><ul><li>查询优化：对于给定的查询选择代价最小的操作序列，使查询过程既省时间，具有较高的效率，这就是所谓的查询优化。对于关系数据库系统，用户只要提出“做什么”，而由系统解决“怎么做”的问题。具体来说，是数据库管理系统中的查询处理程序自动实现查询优化。</li><li>关系查询优化是影响RDBMS性能的关键因素。关系系统的查询优化既是RDBMS实现的关键技术又是关系系统的优点所在。</li><li>查询优化的优点不仅在于用户不必考虑如何最好地表达查询以获得较好的效率，而且在于系统可以比用户程序的“优化”做得更好。 </li><li>查询优化的一般准则<ul><li>1.选择运算应尽可能先做。在优化策略中这是最重要、最基本的一条。它常常可使执行时节约几个数量级，因为选择运算一般使计算的中间结果大大变小</li><li>2.在执行连接前对关系适当地预处理。预处理方法主要有两种，在连接属性上建立索引和对关系排序 。</li><li>3.把投影运算和选择运算同时进行。如有若干投影和选择运算，并且它们都对同一个关系操作，则可以在扫描此关系的同时完成所有的这些运算以避免重复扫描关系。 </li><li>4.把投影同其前或其后的双目运算结合起来，没有必要为了去掉某些字段而扫描一遍关系</li><li>5.杷某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算，连接特别是等值连接运算要比同样关系上的笛卡尔积省很多时间 </li><li>6.找出公共子表达式。</li></ul></li></ul><h2 id="关系数据库设计理论"><a href="#关系数据库设计理论" class="headerlink" title="关系数据库设计理论"></a>关系数据库设计理论</h2><h3 id="设计一个好的关系数据库系统，关键是要设计一个好的数据库模式（数据库逻辑设计问题）"><a href="#设计一个好的关系数据库系统，关键是要设计一个好的数据库模式（数据库逻辑设计问题）" class="headerlink" title="设计一个好的关系数据库系统，关键是要设计一个好的数据库模式（数据库逻辑设计问题）"></a>设计一个好的关系数据库系统，关键是要设计一个好的数据库模式（数据库逻辑设计问题）</h3><h3 id="数据库逻辑设计主要解决的问题"><a href="#数据库逻辑设计主要解决的问题" class="headerlink" title="数据库逻辑设计主要解决的问题"></a>数据库逻辑设计主要解决的问题</h3><ul><li>关系数据库应该组织成几个关系模式</li><li>关系模式中包括哪些属性</li></ul><h3 id="“不好”的数据库设计"><a href="#“不好”的数据库设计" class="headerlink" title="“不好”的数据库设计"></a>“不好”的数据库设计</h3><ul><li>举例：为学校设计一个关系数据库</li><li>关系模式: UN(Sno,Cno,G,Sdept,MN)<ul><li>Sno:描述学生</li><li>Sdept:描述系名</li><li>MN:描述系主任</li><li>Cno:描述课程</li><li>G:描述学习成绩</li><li>根据对现实世界的分析,可得出:Sno,Cno是码</li><li>按照关系模式UN装入部分数据</li></ul></li><li></li><li>对数据库操作时,会出现以下问题<ul><li><ol><li>数据冗余(系主任名的存储次数)<ul><li>数据重复存储:浪费存储空间,数据库维护困难(更新异常)</li></ul></li></ol></li><li><ol start="2"><li>插入异常(一个系刚成立)<ul><li>主码为空的记录不能存在与数据库,导致不能进行插入操作</li></ul></li></ol></li><li><ol start="3"><li>删除异常(一个系的学生全部毕业)<ul><li>删除操作后,一些相关信息无法保存在数据库中</li></ul></li></ol></li></ul></li><li>要消除以上的“弊病”,把上面的关系数据库模式分解为三个关系模式<ul><li>S(Sno,Sdept)</li><li>SG(Sno,Cno,G)</li><li>Dept(Sdept,MN)</li></ul></li></ul><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><ul><li>类似于变量之间的单值函数关系</li><li>Y=F(X),其中自变量X的值,决定一个唯一的函数值Y</li><li>在一个关系模式里的属性,由于它在不同元组里属性值可能不同,由此可以把关系中的属性看作变量</li><li>一个属性与另一个属性在取值上可能存在制约关系</li><li>函数依赖就是属性间的逻辑依赖关系</li><li>定义1 设R(U)是一个关系模式,U是R的属性集合,X和Y是U的子集.对于R(U)的任何一个可能的关系r,如果r中不存在两个元组,它们在X上的属性值相同,而在Y上的属性值不同,则称X函数决定Y,或Y函数依赖于X,记作:X  Y.</li><li>X通常称为“决定因素”</li><li>几点说明<ul><li><ol><li>函数依赖是语义范畴的概念.它反映了一种语义完整性约束,只能根据语义来确定一个函数依赖.</li></ol></li><li><ol start="2"><li>函数依赖是指关系R模式的所有关系元组均应满足的约束条件,而不是关系模式中的某个或某些元组满足的约束条件</li></ol></li><li><ol start="3"><li>函数依赖与属性间的联系类型有关<ul><li>(1)若属性X和Y之间有“一对一”的联系,</li><li>(2)若属性X和Y之间有“多对一”的联系,</li><li>(3)若属性X和Y之间有“多对多”的联系,</li></ul></li></ol></li><li><ol start="4"><li>如果X   Y,并且Y不是X的子集,则称X   Y是非平凡的函数依赖;如果Y是X的子集,则称X   Y是平凡的函数依赖;</li></ol></li></ul></li></ul><h3 id="完全函数依赖与部分函数依赖"><a href="#完全函数依赖与部分函数依赖" class="headerlink" title="完全函数依赖与部分函数依赖"></a>完全函数依赖与部分函数依赖</h3><ul><li>完全函数依赖</li><li>部分函数依赖</li></ul><h3 id="码的形式定义"><a href="#码的形式定义" class="headerlink" title="码的形式定义"></a>码的形式定义</h3><ul><li>候选码的两个性质<ul><li><ol><li>标识的唯一性: 对于R(U)中的每一元组,K的值确定后,该元组就相应确定了.</li></ol></li><li><ol start="2"><li>无冗余性: K是属性组的情况下,K的任何一部分都不能唯一标识该元组(定义中的完全函数依赖的意义) </li></ol></li></ul></li></ul><h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><ul><li>简介<ul><li>用几个简单的关系去取代原来结构复杂的关系的过程叫做关系规范化.</li><li>规范化理论是研究如何把一个不好的关系模式转化为好的关系模式的理论</li><li>规范化理论是E.E.Codd在1971年首先提出的</li><li>规范化理论是数据库设计过程中的一个非常有用的辅助工具</li></ul></li><li>范式<ul><li>简介<ul><li>规范化理论是围绕着范式建立的.</li><li>满足不同程度要求的约束集则称为不同的范式.</li><li>如果一个关系满足某个指定的约束集,则称它属于某个特定的范式.</li><li>较高层次的范式比较低层次的范式具有“更合乎要求的性质”</li><li>一个低一级范式的关系模式,通过投影运算可以转化为若干个高一级范式的关系模式的集合,这个过程叫做规范化.</li><li>如果一个关系满足某个范式要求,则它也会满足较其级别低的所有范式的要求</li></ul></li><li>范式层次</li><li>第一范式(1NF)<ul><li>定义5: 在关系模式R中的每一个具体关系r中,如果每个属性值都是不可再分的最小数据单位,则称R是第一范式的关系,记作R∈1NF.</li><li>数据库理论研究的是规范化关系.</li><li>1NF规范化: 把非规范化关系规范提高到1NF关系模式的集合.</li></ul></li><li>第二范式(2NF)<ul><li>定义6: 若关系模式R∈1NF,且每个非主属性都完全依赖于R的任意候选码,则关系模式R属于第二范式,记作R ∈2NF.</li><li>2NF规范化是把1NF关系模式规范提高到变成2NF关系模式的集合.</li><li>从1NF中消除非主属性对候选码的部分函数依赖,则获得2NF关系.</li><li>举例:UN(Sno,Cno,G,SDN,MN)</li></ul></li><li>第三范式(3NF)<ul><li>定义7: 若关系模式R∈2NF,且每个非主属性都不传递依赖于R的任意候选码,则R∈3NF.</li><li>从2NF关系中,消除非主属性对码的传递依赖函数而获得3NF关系</li><li>R∈3NF,则每个非主属性既不部分依赖,也不传递依赖于R的任何候选码.</li><li>3NF的规范化</li></ul></li><li>BCNF范式<ul><li>3NF的不完善性<ul><li>定义8: 若R∈1NF,且R中每个决定因素都是候选码,则R ∈BCNF.</li><li>满足BCNF的关系将消除任何属性对候选码的部分依赖与传递依赖</li><li>应用BCNF定义时,可直接判断1NF是否属于BCNF</li><li>BCNF规范化</li></ul></li></ul></li></ul></li></ul><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ul><li>数据库技术是信息资源管理最有效的手段。数据库设计是指对于一个给定的应用环境，构造最优的数据库模式，建立数据库极其应用系统，有效存储数据，满足用户信息要求和处理要求。 </li></ul><h3 id="数据库设计的步骤"><a href="#数据库设计的步骤" class="headerlink" title="数据库设计的步骤"></a>数据库设计的步骤</h3><ul><li>⒈需求分析阶段 <ul><li>收集和分析用户需求，结果得到数据字典描述的数据需求。 </li><li>常用的调查方法<ul><li>⑴跟班作业 </li><li>⑵开调查会</li><li>⑶请专人介绍</li><li>⑷询问对某些调查中的问题，可以找专人询问。</li><li>⑸设计调查表请用户填写</li><li>⑹查阅记录</li></ul></li></ul></li><li>⒉概念结构设计阶段<ul><li>通过对用户需求进行综合、归纳与抽象，形成一个独立于具体DBMS的概念模型，可以用E-R图表示。这是数据库设计的关键</li></ul></li><li>⒊逻辑结构设计阶段<ul><li>将概念结构转换为某个DBMS所支持的数据模型（例如关系模型），并对其进行优化（例如使用范式理论）</li></ul></li><li>⒋数据库物理设计阶段<ul><li>为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构和存取方法）。</li></ul></li><li>⒌数据库实施阶段<ul><li>运用DBMS提供的数据语言（例如SQL）及其宿主语言（例如C），根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行</li></ul></li><li>⒍数据库运行和维护阶段<ul><li>数据库应用系统经过试运行后即可投入正式运行。在数据库系统运行过程中必须不断地对其进行评价、调整与修改</li></ul></li></ul><h3 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h3><ul><li>对数据库设计来讲，数据字典是进行数据收集和数据分析所获得的主要成果。数据字典是各类数据描述的集合。 </li><li>数据字典通常包括数据项、数据结构、数据流、数据存储和处理过程五个部分。 <ul><li>数据项是不可再分的数据单位</li><li>数据结构反映了数据之间的组合关系。一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成</li><li>数据流是数据结构在系统内传输的路径</li><li>数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一</li><li>处理过程描述＝｛处理过程名，说明，输入:｛数据流｝，输出:｛数据流｝, 处理:｛简要说明｝｝</li></ul></li></ul><h3 id="设计概念结构通常有四类方法"><a href="#设计概念结构通常有四类方法" class="headerlink" title="设计概念结构通常有四类方法"></a>设计概念结构通常有四类方法</h3><ul><li>自顶向下<ul><li>即首先定义全局概念结构的框架，然后逐步细化。</li></ul></li><li>自底向上 <ul><li>即首先定义各局部应用的概念结构，然后将它们集成起来，得到全局概念结构。这是最经常采用的策略。即自顶向下地进行需求分析，然后再自底向上地设计概念结构</li></ul></li><li>逐步扩张 <ul><li>首先定义最重要的核心概念结构，然后向外扩充，以滚雪球的方式逐步生成其他概念结构，直至总体概念结构</li></ul></li><li>混合策略<ul><li>即将自顶向下和自底向上相结合，用自顶向下策略设计一个全局概念结构的框架，以它为骨架集成由自底向上策略中设计的各局部概念结构</li></ul></li></ul><h3 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h3><ul><li>E-R方法是抽象和描述现实世界的有力工具</li><li>要点<ul><li>使用长方形来表示实体型，框内写上实体名</li><li>椭圆型表示实体的属性，并用无向边把实体和属性连接起来。</li><li>用菱形表示实体间的联系，菱形框内写上联系名，用无向边把菱形分别与有关实体相连接，在无向边旁标上联系的类型，若实体之间联系也具有属性，则把属性和菱形也用无向边连接上。</li></ul></li><li>E-R图之间的冲突主要有三类<ul><li>属性冲突 <ul><li>(1) 属性域冲突，即属性值的类型、取值范围或取值集合不同。 </li><li>(2) 属性取值单位冲突</li></ul></li><li>命名冲突<ul><li>(1) 同名异义</li><li>(2) 异名同义（一义多名）</li></ul></li><li>结构冲突 <ul><li>(1) 同一对象在不同应用中具有不同的抽象。例如“教材”在某一局部应用中被当作实体，而在另一局部应用中则被当作属性</li><li>(2) 同一实体在不同局部视图中所包含的属性不完全相同，或者属性的排列次序不完全相同</li><li>(3) 实体之间的联系在不同局部视图中呈现不同的类型。例如实体E1与E2在局部应用A中是多对多联系，而在局部应用B中是一对多联系；又如在局部应用X中E1与E2发生联系，而在局部应用Y中E1、E2、E3三者之间有联系</li></ul></li></ul></li></ul><h3 id="逻辑结构设计阶段"><a href="#逻辑结构设计阶段" class="headerlink" title="逻辑结构设计阶段"></a>逻辑结构设计阶段</h3><ul><li>⒈一个实体型转换为一个关系模式。实体的属性就是关系的属性。实体的码就是关系的码。</li><li>⒉一个m:n联系转换为一个关系模式。与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性。而关系的码为各实体码的组合。</li><li>⒊一个1:n联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并。如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为n端实体的码。</li><li>⒋一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的候选码。如果与某一端对应的关系模式合并，则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性。</li><li>⒌三个或三个以上实体间的一个多元联系转换为一个关系模式。与该多元联系相连的各实体的码以及联系本身的属性均转换为关系的属性。而关系的码为各实体码的组合。</li><li><ol start="6"><li>具有相同码的关系模式可合并。</li></ol></li></ul><h3 id="数据模型的优化"><a href="#数据模型的优化" class="headerlink" title="数据模型的优化"></a>数据模型的优化</h3><ul><li>确定数据依赖</li><li>对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系。</li><li>按照数据依赖的理论对关系模式逐一进行分析，考查是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式。</li><li>按照需求分析阶段得到的各种应用对数据处理的要求，分析对于这样的应用环境这些模式是否合适，确定是否要对它们进行合并或分解。 </li><li>对关系模式进行必要的分解。</li></ul><h3 id="设计用户子模式"><a href="#设计用户子模式" class="headerlink" title="设计用户子模式"></a>设计用户子模式</h3><ul><li>(1) 使用更符合用户习惯的别名 </li><li>(2) 针对不同级别的用户定义不同的视图，以满足系统对安全性的要求</li><li>(3) 简化用户对系统的使用</li></ul><h3 id="数据库物理设计"><a href="#数据库物理设计" class="headerlink" title="数据库物理设计"></a>数据库物理设计</h3><ul><li>确定数据库存储结构时要综合考虑存取时间、存储空间利用率和维护代价三方面的因素。这三个方面常常是相互矛盾的。</li><li>为了提高系统性能，数据应该根据应用情况将易变部分与稳定部分、经常存取部分和存取频率较低部分分开存放</li></ul><h2 id="数据库恢复技术"><a href="#数据库恢复技术" class="headerlink" title="数据库恢复技术"></a>数据库恢复技术</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><ul><li>事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位</li><li>事务和程序是两个概念<ul><li>在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序</li><li>一个应用程序通常包含多个事务</li></ul></li><li>事务是恢复和并发控制的基本单位</li></ul><h3 id="事务结束"><a href="#事务结束" class="headerlink" title="事务结束"></a>事务结束</h3><ul><li>COMMIT<ul><li>事务正常结束   </li><li>提交事务的所有操作（读+更新）</li><li>事务中所有对数据库的更新永久生效</li></ul></li><li>ROLLBACK<ul><li>事务异常终止<ul><li>事务运行的过程中发生了故障，不能继续执行</li><li>回滚事务的所有更新操作</li><li>事务滚回到开始时的状态</li></ul></li></ul></li></ul><h3 id="事务的特性-ACID特性"><a href="#事务的特性-ACID特性" class="headerlink" title="事务的特性(ACID特性)"></a>事务的特性(ACID特性)</h3><ul><li><p>原子性（Atomicity）</p><ul><li>事务是数据库的逻辑工作单位</li><li>事务中包括的诸操作要么都做，要么都不做</li></ul></li><li><p>一致性（Consistency）</p><ul><li>事务执行的结果必须是使数据库从一个   一致性状态变到另一个一致性状态</li><li>一致性状态：<ul><li>数据库中只包含成功事务提交的结果</li></ul></li><li>不一致状态：<ul><li>数据库中包含失败事务的结果</li></ul></li></ul></li><li><p>隔离性（Isolation）</p><ul><li><p>对并发执行而言一个事务的执行不能被其他事务干扰</p></li><li><p>一个事务内部的操作及使用的数据对其他并发事务是隔离的</p></li><li><p>并发执行的各个事务之间不能互相干扰</p></li></ul></li><li><p>持续性（Durability ）</p><ul><li>持续性也称永久性（Permanence）</li><li>一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。</li><li>接下来的其他操作或故障不应该对其执行结果有任何影响。</li></ul></li></ul><h3 id="故障"><a href="#故障" class="headerlink" title="故障"></a>故障</h3><ul><li>故障原因<ul><li>计算机硬件故障</li><li>系统软件和应用软件的错误</li><li>操作员的失误</li><li>恶意的破坏</li></ul></li><li>故障的影响<ul><li>运行事务非正常中断</li><li>破坏数据库</li></ul></li><li>故障的种类<ul><li>事务故障</li><li>系统故障</li><li>介质故障</li><li>计算机病毒</li></ul></li></ul><h3 id="恢复操作的基本原理"><a href="#恢复操作的基本原理" class="headerlink" title="恢复操作的基本原理"></a>恢复操作的基本原理</h3><ul><li>恢复操作的基本原理：冗余</li><li>利用存储在系统其它地方的冗余数据来重建数据库中已被破坏或不正确的那部分数据</li></ul><h3 id="恢复的实现技术"><a href="#恢复的实现技术" class="headerlink" title="恢复的实现技术"></a>恢复的实现技术</h3><ul><li>数据转储（backup）</li><li>登录日志文件（logging）</li></ul><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><h3 id="多事务执行方式"><a href="#多事务执行方式" class="headerlink" title="多事务执行方式"></a>多事务执行方式</h3><ul><li>(1)事务串行执行<ul><li>每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行</li><li>不能充分利用系统资源，发挥数据库共享资源的特点</li></ul></li><li>(2)交叉并发方式（interleaved concurrency）<ul><li>事务的并行执行是这些并行事务的并行操作轮流交叉运行</li><li>是单处理机系统中的并发方式，能够减少处理机的空闲时间，提高系统的效率</li></ul></li><li>(3)同时并发方式（simultaneous  concurrency）<ul><li>多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行</li><li>最理想的并发方式，但受制于硬件环境</li><li>更复杂的并发方式机制</li></ul></li></ul><h3 id="事务并发执行带来的问题"><a href="#事务并发执行带来的问题" class="headerlink" title="事务并发执行带来的问题"></a>事务并发执行带来的问题</h3><ul><li>可能会存取和存储不正确的数据，破坏事务的隔离性和数据库的一致性</li><li>DBMS必须提供并发控制机制</li><li>并发控制机制是衡量一个DBMS性能的重要标志之一</li></ul><h3 id="并发控制机制的任务"><a href="#并发控制机制的任务" class="headerlink" title="并发控制机制的任务"></a>并发控制机制的任务</h3><ul><li>对并发操作进行正确调度</li><li>保证事务的隔离性</li><li>保证数据库的一致性</li></ul><h3 id="并发操作带来的数据不一致性"><a href="#并发操作带来的数据不一致性" class="headerlink" title="并发操作带来的数据不一致性"></a>并发操作带来的数据不一致性</h3><ul><li>丢失修改（lost update）<ul><li>丢失修改是指事务1与事务2从数据库中读入同一数据并修改</li><li>事务2的提交结果破坏了事务1提交的结果，导致事务1的修改被丢失。</li></ul></li><li>不可重复读（non-repeatable read）<ul><li>不可重复读是指事务1读取数据后，事务2执行更新操作，使事务1无法再现前一次读取结果。</li></ul></li><li>读“脏”数据（dirty read）<ul><li>事务1修改某一数据，并将其写回磁盘</li><li>事务2读取同一数据后</li><li>事务1由于某种原因被撤消，这时事务1已修改过的数据恢复原值</li><li>事务2读到的数据就与数据库中的数据不一致，</li><li>是不正确的数据，又称为“脏”数据。</li></ul></li></ul><h3 id="封锁"><a href="#封锁" class="headerlink" title="封锁"></a>封锁</h3><ul><li>什么是封锁<ul><li>封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁</li><li>加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。</li><li>封锁是实现并发控制的一个非常重要的技术</li></ul></li><li>基本封锁类型<ul><li>排它锁（eXclusive lock，简记为X锁）<ul><li>排它锁又称为写锁</li><li>若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁</li></ul></li><li>共享锁（Share lock，简记为S锁）<ul><li>共享锁又称为读锁</li><li>若事务T对数据对象A加上S锁，则其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁</li></ul></li></ul></li><li>基本锁的相容矩阵</li><li>封锁协议<ul><li>1级封锁协议<ul><li>事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放</li><li>1级封锁协议可防止丢失修改</li><li>在1级封锁协议中，如果是读数据，不需要加锁的，所以它不能保证可重复读和不读“脏”数据。<ul><li>读“脏”数据</li><li>不可重复读</li></ul></li></ul></li><li>2级封锁协议<ul><li>1级封锁协议+事务T在读取数据R前必须先加S锁，读完后即可释放S锁</li><li>2级封锁协议可以防止丢失修改和读“脏”数据。</li><li>在2级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。</li></ul></li><li>3级封锁协议<ul><li>1级封锁协议 + 事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放</li><li>3级封锁协议可防止丢失修改、读脏数据和不可重复读。</li></ul></li><li>三级协议的主要区别</li></ul></li></ul><h2 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h2><h3 id="完整性约束的分类"><a href="#完整性约束的分类" class="headerlink" title="完整性约束的分类"></a>完整性约束的分类</h3><ul><li>静态列级约束<ul><li><ol><li>对数据类型的约束，包括数据的类型、长度单位、精度等</li></ol></li><li><ol start="2"><li>对数据格式的约束 </li></ol></li><li><ol start="3"><li>对取值范围或取值集合的约束</li></ol></li><li><ol start="4"><li>对空值的约束</li></ol></li><li><ol start="5"><li>其他约束 </li></ol></li></ul></li><li>静态元组约束<ul><li>一个元组是由若干个列值组成的，静态元组约束就是规定元组的各个列之间的约束关系</li></ul></li><li>静态关系约束<ul><li>在一个关系的各个元组之间或者若干关系之间常常存在各种联系或约束。 （参照完整性－外码约束）</li></ul></li><li>动态列级约束<ul><li><ol><li>修改列定义时的约束 </li></ol></li><li><ol start="2"><li>修改列值时的约束</li></ol></li></ul></li><li>动态元组约束 <ul><li>动态元组约束是指修改元组的值时元组中各个字段间需要满足某种约束条件</li></ul></li><li>动态关系约束<ul><li>动态关系约束是加在关系变化前后状态上的限制条件，例如事务一致性、原子性等约束条件</li></ul></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>983-最低票价</title>
      <link href="/2020/05/06/983-%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B7/"/>
      <url>/2020/05/06/983-%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B7/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。</p><p>火车票有三种不同的销售方式：</p><p>一张为期一天的通行证售价为 costs[0] 美元；<br>一张为期七天的通行证售价为 costs[1] 美元；<br>一张为期三十天的通行证售价为 costs[2] 美元。<br>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。</p><p>返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。</p><p>示例 1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：days = [1,4,6,7,8,20], costs = [2,7,15]</span><br><span class="line">输出：11</span><br><span class="line">解释： </span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：</span><br><span class="line">在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。</span><br><span class="line">在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。</span><br><span class="line">在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。</span><br><span class="line">你总共花了 $11，并完成了你计划的每一天旅行。</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]</span><br><span class="line">输出：17</span><br><span class="line">解释：</span><br><span class="line">例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： </span><br><span class="line">在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。</span><br><span class="line">在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 </span><br><span class="line">你总共花了 $17，并完成了你计划的每一天旅行。</span><br></pre></td></tr></tbody></table></figure></div><p>思路：最关键在于：今天买多少，得看后几天怎么安排，即<strong>前面依赖后面</strong>——从后向前来买。从后向前的动态规划。</p><p>决策1：买一天期，后面的不包<br>决策2：买七天期，包到第 8 + 7 - 1 天，第 8 + 7 天往后的不包<br>决策3：买三十天期，包到第 8 + 30 - 1 天，第 8 + 30 天往后的不包</p><p>dp[i] 为第 i 天开始，所需最小费用（累计）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = min(决策1, 决策2, 决策3);</span><br><span class="line">      = min(c[0] + 1天后不包, c[1] + 7天后不包, c[2] + 30天不包);</span><br><span class="line">      = min(c[0] + dp[i + 1], c[1] + dp[i + 7], c[2] + dp[i + 30]);</span><br></pre></td></tr></tbody></table></figure></div><p>详细题解<a href="https://leetcode-cn.com/problems/minimum-cost-for-tickets/solution/java-dong-tai-gui-hua-si-lu-bu-zou-cong-hou-xiang-/" target="_blank" rel="noopener">点这里</a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mincostTickets</span><span class="params">(<span class="keyword">int</span>[] days, <span class="keyword">int</span>[] costs)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = days.length, maxDay = days[len - <span class="number">1</span>], minDay = days[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[maxDay + <span class="number">31</span>]; <span class="comment">// 多扩几天，省得判断 365 的限制</span></span><br><span class="line">        <span class="keyword">int</span> index = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = maxDay; d >= minDay; d--) {</span><br><span class="line">            <span class="comment">// index 表示 days 的索引</span></span><br><span class="line">            <span class="comment">// 也可提前将所有 days 放入 Set，再通过 set.contains() 判断</span></span><br><span class="line">            <span class="keyword">if</span> (d == days[index]) {</span><br><span class="line">                dp[d] = Math.min(dp[d + <span class="number">1</span>] + costs[<span class="number">0</span>], dp[d + <span class="number">7</span>] + costs[<span class="number">1</span>]);</span><br><span class="line">                dp[d] = Math.min(dp[d], dp[d + <span class="number">30</span>] + costs[<span class="number">2</span>]);</span><br><span class="line">                index--; <span class="comment">// 别忘了递减一天</span></span><br><span class="line">            } <span class="keyword">else</span> dp[d] = dp[d + <span class="number">1</span>]; <span class="comment">// 不需要出门</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[minDay];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>98-验证二叉搜索树</title>
      <link href="/2020/05/06/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2020/05/06/98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>示例 1:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></tbody></table></figure></div><p>思路一：递归</p><p>​    设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在 (l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。</p><p>​    那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。函数递归调用的入口为 helper(root, -inf, +inf)， inf 表示一个无穷大的值。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode node, Integer lower, Integer upper)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val = node.val;</span><br><span class="line">    <span class="keyword">if</span> (lower != <span class="keyword">null</span> && val <= lower) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (upper != <span class="keyword">null</span> && val >= upper) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! helper(node.right, val, upper)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (! helper(node.left, lower, val)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> helper(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路二：中序遍历</p><p>​    二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，所以在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    Stack<treenode> stack = <span class="keyword">new</span> Stack();</treenode></span><br><span class="line">    <span class="keyword">double</span> inorder = - Double.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="keyword">null</span>) {</span><br><span class="line">      <span class="keyword">while</span> (root != <span class="keyword">null</span>) {</span><br><span class="line">        stack.push(root);</span><br><span class="line">        root = root.left;</span><br><span class="line">      }</span><br><span class="line">      root = stack.pop();</span><br><span class="line">      <span class="comment">// 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span></span><br><span class="line">      <span class="keyword">if</span> (root.val <= inorder) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      inorder = root.val;</span><br><span class="line">      root = root.right;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>19-从上往下打印二叉树</title>
      <link href="/2020/05/06/19-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/05/06/19-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><p>思路：用队列实现层次遍历。Java中的LinkedList实现了Queue接口。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root) {</span><br><span class="line">        <span class="comment">//创建队列</span></span><br><span class="line">        Queue<treenode> q = <span class="keyword">new</span> LinkedList<>();</treenode></span><br><span class="line">        <span class="comment">//返回结果</span></span><br><span class="line">        ArrayList<integer> array = <span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">        <span class="comment">//根结点入队</span></span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(q.peek() != <span class="keyword">null</span>){</span><br><span class="line">            <span class="comment">//从队列中取元素</span></span><br><span class="line">            TreeNode t = q.remove();</span><br><span class="line">            array.add(t.val);</span><br><span class="line">            <span class="comment">//左右子树入队</span></span><br><span class="line">            <span class="keyword">if</span>(t.left != <span class="keyword">null</span>)</span><br><span class="line">                q.offer(t.left);</span><br><span class="line">            <span class="keyword">if</span>(t.right != <span class="keyword">null</span>)</span><br><span class="line">                q.offer(t.right);</span><br><span class="line">        }</span><br><span class="line">      <span class="comment">//ArrayList转int数组，不能直接用toArray()，因为会转成integer数组</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[array.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i<array.size();i++){< span><br><span class="line">            res[i] = array.get(i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></array.size();i++){<></span></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>45-跳跃游戏II</title>
      <link href="/2020/05/04/45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/"/>
      <url>/2020/05/04/45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>示例:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></tbody></table></figure></div><p>说明:</p><p>假设你总是可以到达数组的最后一个位置。</p><p>我的思路：从头到尾遍历，找到第一个能一步跳到数组末尾的数字。然后再以它为结尾，向前找。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = jump_last(nums.length-<span class="number">1</span>, nums);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(last != <span class="number">0</span>){</span><br><span class="line">            last = jump_last(last, nums);</span><br><span class="line">            count++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump_last</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] nums)</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < index; i++){</span><br><span class="line">            <span class="keyword">if</span>((nums[i]+i) >= index)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>更简洁的写法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> position = nums.length - <span class="number">1</span>; <span class="comment">//要找的位置</span></span><br><span class="line">    <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (position != <span class="number">0</span>) { <span class="comment">//是否到了第 0 个位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < position; i++) {</span><br><span class="line">            <span class="keyword">if</span> (nums[i] >= position - i) {</span><br><span class="line">                position = i; <span class="comment">//更新要找的位置</span></span><br><span class="line">                steps++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>我的思路相当于是从后向前，其实从头向后的贪心算法也可以，每次在可跳范围内选择可以使得跳的更远的位置</p><p>如下图，开始的位置是 2，可跳的范围是橙色的。然后因为 3 可以跳的更远，所以跳到 3 的位置。</p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200504223325019.png" data-fancybox="group" data-caption="image-20200504223325019" class="fancybox"><img alt="image-20200504223325019" style="zoom:50%;" title="image-20200504223325019" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200504223325019.png" class="lazyload"></a><p>如下图，然后现在的位置就是 3 了，能跳的范围是橙色的，然后因为 4 可以跳的更远，所以下次跳到 4 的位置。</p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200504223416908.png" data-fancybox="group" data-caption="image-20200504223416908" class="fancybox"><img alt="image-20200504223416908" style="zoom:50%;" title="image-20200504223416908" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200504223416908.png" class="lazyload"></a><p>写代码的话，用 end 表示当前能跳的边界，对于上边第一个图的橙色 1，第二个图中就是橙色的 4，遍历数组的时候，到了边界，我们就重新更新新的边界</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxPosition = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < nums.length - <span class="number">1</span>; i++){</span><br><span class="line">         <span class="comment">//找能跳的最远的</span></span><br><span class="line">            maxPosition = Math.max(maxPosition, nums[i] + i); </span><br><span class="line">            <span class="keyword">if</span>( i == end){ <span class="comment">//遇到边界，就更新边界，并且步数加一</span></span><br><span class="line">                end = maxPosition;</span><br><span class="line">                steps++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>对这个思路一开始有点疑问，如果还不清楚的话，就用 [2,3,1,10,4,2,1] 这个例子跟着走一遍流程</p></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>18-树的子结构</title>
      <link href="/2020/05/04/18-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
      <url>/2020/05/04/18-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><p>思路：先序遍历树 A 中的每个节点 ，并判断以这个结点为根节点的子树是否包含树 B 。（此处包含特指根节点相同）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="comment">//这个函数不要求root1和root2的根结点相同（判断子结构）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>{</span><br><span class="line">        <span class="comment">//遍历root1，如果某个节点的val和root2根结点的val相同，再判断是否root1中包含root2的结构。如果包含，则是子结构，如果不包含，则继续遍历</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1.val == root2.val && hasSame(root1, root2))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);</span><br><span class="line">    }</span><br><span class="line">                    </span><br><span class="line">    <span class="comment">//这个函数要求root1和root2的根结点相同。但要比的并不是完全相同，而是root1中是否包含root2的结构</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasSame</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span>(root1.val != root2.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> hasSame(root1.left, root2.left) && hasSame(root1.right, root2.right);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>更简洁的写法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (A != <span class="keyword">null</span> && B != <span class="keyword">null</span>) && (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(TreeNode A, TreeNode B)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(B == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(A.left, B.left) && recur(A.right, B.right);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3-无重复字符的最长子串</title>
      <link href="/2020/05/03/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2020/05/03/3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><p>示例 1:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: "abcabcbb"</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: "bbbbb"</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。</span><br></pre></td></tr></tbody></table></figure></div><p>示例 3:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: "pwwkew"</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。</span><br></pre></td></tr></tbody></table></figure></div><p>思路：滑动窗口</p><p>什么是滑动窗口？其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列。如何移动？<strong>我们只要把队列的左边的元素移出就行了，直到满足题目要求，一直维持这样的队列，找出队列出现最长的长度时候</strong>，就求出了解</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//如果用set，在下面移动窗口的时候，没法一下找到准确位置</span></span><br><span class="line">        HashMap<character, integer> map = <span class="keyword">new</span> HashMap<character, integer>();</character,></character,></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//标记滑动窗口起始位置</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < s.length(); i ++){</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i))){</span><br><span class="line">              <span class="comment">//窗口起始位置变为，已存在的那个字符位置的下一位。</span></span><br><span class="line">              <span class="comment">//举个例子。"qrsvbspk"，第二次遇到’s‘的时候，left直接跳到’v‘</span></span><br><span class="line">              <span class="comment">//这就体现了map的作用</span></span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">          <span class="comment">//更新一下最大值</span></span><br><span class="line">            max = Math.max(max,i-left+<span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>17-二叉树的镜像</title>
      <link href="/2020/05/02/17-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"/>
      <url>/2020/05/02/17-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><p>思路：前序遍历，交换左右子树，递归。如果不用递归，用循环怎么写？</p><p>递归写法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">//交换左右子树</span></span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">      <span class="comment">//递归交换左右子树</span></span><br><span class="line">        mirrorTree(root.left);</span><br><span class="line">        mirrorTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>202-快乐数</title>
      <link href="/2020/04/30/202-%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
      <url>/2020/04/30/202-%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>编写一个算法来判断一个数 n 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为  1，那么这个数就是快乐数。</p><p>如果 n 是快乐数就返回 True ；不是，则返回 False 。</p><p>示例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 = 82</span><br><span class="line">82 + 22 = 68</span><br><span class="line">62 + 82 = 100</span><br><span class="line">12 + 02 + 02 = 1</span><br></pre></td></tr></tbody></table></figure></div><p>思路：首先推测会有以下三种可能</p><ol><li>最终会得到 1</li><li>最终会进入循环</li><li>值会越来越大，最后接近无穷大</li></ol><p>第三个情况比较难以检测和处理。我们怎么知道它会继续变大，而不是最终得到 11 呢？我们可以仔细想一想，每一位数的最大数字的下一位数是多少。</p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200430103425118.png" data-fancybox="group" data-caption="image-20200430103425118" class="fancybox"><img alt="image-20200430103425118" style="zoom:50%;" title="image-20200430103425118" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200430103425118.png" class="lazyload"></a><p>对于 3 位数的数字，它不可能大于 243。这意味着它要么被困在 243 以下的循环内，要么跌到 1。4 位或 4 位以上的数字在每一步都会丢失一位，直到降到 3 位为止。所以我们知道，最坏的情况下，算法可能会在 243 以下的所有数字上循环，然后回到它已经到过的一个循环或者回到 11。但它不会无限期地进行下去，所以我们排除第三种选择。</p><p>即使在代码中你不需要处理第三种情况，你仍然需要理解为什么它永远不会发生，这样你就可以证明为什么你不处理它。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n > <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">int</span> d = n % <span class="number">10</span>;</span><br><span class="line">            n = n / <span class="number">10</span>;</span><br><span class="line">            totalSum += d * d;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        Set<integer> seen = <span class="keyword">new</span> HashSet<>();</integer></span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> && !seen.contains(n)) {</span><br><span class="line">            seen.add(n);</span><br><span class="line">            n = getNext(n);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>16-合并两个排序的链表</title>
      <link href="/2020/04/30/16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/04/30/16-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><p>思路：使用双指针遍历两链表，根据  l1.val 和  l2.val 的大小关系确定节点添加顺序，两节点指针交替前进，直至遍历完毕。</p><p><strong>引入伪头节点</strong>： 由于初始状态合并链表中无节点，因此循环第一轮时无法将节点添加到合并链表中。</p><p>解决方案：初始化一个辅助节点 dum 作为合并链表的伪头节点，将各节点添加至 dum 之后</p><p>我的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        ListNode p = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode res = p;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> && l2 != <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">if</span>(l1.val > l2.val){</span><br><span class="line">                p.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                p.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            }</span><br><span class="line">            p = p.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>)</span><br><span class="line">            p.next = l2;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.next = l1;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>相同思路更简洁的写法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>{</span><br><span class="line">        ListNode dum = <span class="keyword">new</span> ListNode(<span class="number">0</span>), cur = dum;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> && l2 != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">if</span>(l1.val < l2.val) {</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            }</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">        cur.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>递归写法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>{</span><br><span class="line">        <span class="comment">//空链表的情况</span></span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">            </span><br><span class="line">        ListNode phead = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(list1.val < list2.val){</span><br><span class="line">            phead = list1;</span><br><span class="line">            phead.next = Merge(list1.next, list2);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            phead = list2;</span><br><span class="line">            phead.next = Merge(list2.next, list1);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> phead;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1095-山脉数组中查找目标值</title>
      <link href="/2020/04/29/1095-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%AE%E6%A0%87%E5%80%BC/"/>
      <url>/2020/04/29/1095-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E7%9B%AE%E6%A0%87%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。</p><p>如果不存在这样的下标 index，就请返回 -1。</p><p>何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件：</p><p>首先，A.length >= 3</p><p>其次，在 0 < i < A.length - 1 条件下，存在 i 使得：</p><p>A[0] < A[1] < … A[i-1] < A[i]<br>A[i] > A[i+1] > … > A[A.length - 1]</p><p>你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据：</p><p>MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）<br>MountainArray.length() - 会返回该数组的长度</p><p>注意：</p><p>对 MountainArray.get 发起超过 100 次调用的提交将被视为错误答案。此外，任何试图规避判题系统的解决方案都将会导致比赛资格被取消。</p><p>示例 1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：array = [1,2,3,4,5,3,1], target = 3</span><br><span class="line">输出：2</span><br><span class="line">解释：3 在数组中出现了两次，下标分别为 2 和 5，我们返回最小的下标 2。</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：array = [0,1,2,4,2,1], target = 3</span><br><span class="line">输出：-1</span><br><span class="line">解释：3 在数组中没有出现，返回 -1。</span><br></pre></td></tr></tbody></table></figure></div><p>提示：</p><p>3 <= mountain_arr.length() <= 10000<br>0 <= target <= 10^9<br>0 <= mountain_arr.get(index) <= 10^9</p><p>思路：显然，如果山脉数组是一个单调递增或者单调递减的序列，那么我们可以通过二分法迅速找到目标值。而现在题目中有一个单调递增序列（峰值左边）和一个单调递减序列（峰值右边），我们只是不知道两个序列的分割点，即峰值在哪里。所以我们第一步应该首先找到峰值。而峰值也可以使用二分法寻找。找到峰值后，再对峰值左右两部分用二分查找。对我来说这道题的<strong>难点是二分法边界的处理</strong>，很麻烦，每次都要调试。应该学习下二分查找的模板。</p><p>步骤如下：</p><ol><li>先使用二分法找到数组的峰值</li><li>在峰值左边使用二分法寻找目标值</li><li>如果峰值左边没有目标值，那么使用二分法在峰值右边寻找目标值</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is MountainArray's API interface.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * interface MountainArray {</span></span><br><span class="line"><span class="comment"> *     public int get(int index) {}</span></span><br><span class="line"><span class="comment"> *     public int length() {}</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findInMountainArray</span><span class="params">(<span class="keyword">int</span> target, MountainArray mountainArr)</span> </span>{</span><br><span class="line">        len = mountainArr.length();</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//找到峰值位置</span></span><br><span class="line">        <span class="keyword">int</span> max_index = findMaxIndex(mountainArr);</span><br><span class="line">      <span class="comment">//现去左边找</span></span><br><span class="line">        <span class="keyword">int</span> res = findInMountainArray_Left(target, mountainArr, <span class="number">0</span>, max_index);</span><br><span class="line">      <span class="comment">//找不到去右边找</span></span><br><span class="line">        <span class="keyword">if</span>(res == -<span class="number">1</span>)</span><br><span class="line">            res = findInMountainArray_Right(target, mountainArr, max_index+<span class="number">1</span>, len-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找峰值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxIndex</span><span class="params">(MountainArray mountainArr)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left <= right){</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> m = mountainArr.get(mid);</span><br><span class="line">            <span class="keyword">if</span>( m > mountainArr.get(mid-<span class="number">1</span>)){</span><br><span class="line">                <span class="keyword">if</span>(m > mountainArr.get(mid+<span class="number">1</span>))</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span></span><br><span class="line">                right = mid;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">  <span class="comment">//左边（递增）用二分法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findInMountainArray_Left</span><span class="params">(<span class="keyword">int</span> target,MountainArray mountainArr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(l <= r){</span><br><span class="line">            mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> m = mountainArr.get(mid);</span><br><span class="line">            <span class="keyword">if</span>(target == m){</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(target > m){</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line"><span class="comment">//右边（递减）用二分法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findInMountainArray_Right</span><span class="params">(<span class="keyword">int</span> target,MountainArray mountainArr,<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>(l <= r){</span><br><span class="line">            mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> m = mountainArr.get(mid);</span><br><span class="line">            <span class="keyword">if</span>(target == m){</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(target > m){</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            }  </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>15-数值的整数次方</title>
      <link href="/2020/04/29/15-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
      <url>/2020/04/29/15-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>注意：base和exponent不同时为0</p><p>思路一：二分法快速幂。递归实现</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="comment">//虽然题目中告诉我们不需要考虑大数问题，但是给出的 n 可以取到−2147483648</span></span><br><span class="line">        <span class="comment">//因此，在编码的时候，需要将 n 转换成 long 类型。</span></span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">        <span class="keyword">if</span> (N < <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / myPow(x, -N);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> myPow(x, N);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">long</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据指数是奇数还是偶数进行分类讨论</span></span><br><span class="line">        <span class="comment">// 使用位运算的 与 运算符代替了求余数运算</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((n % <span class="number">2</span>) == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 分治思想：分</span></span><br><span class="line">            <span class="keyword">double</span> square = myPow(x, n / <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// 分治思想：合，下面同理</span></span><br><span class="line">            <span class="keyword">return</span> square * square;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 是奇数的时候</span></span><br><span class="line">            <span class="keyword">double</span> square = myPow(x, (n - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> square * square * x;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路二：非递归写法（将指数看成二进制数）</p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200429113120910.png" data-fancybox="group" data-caption="image-20200429113120910" class="fancybox"><img alt="image-20200429113120910" style="zoom:50%;" title="image-20200429113120910" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200429113120910.png" class="lazyload"></a><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">long</span> N = n;</span><br><span class="line">      <span class="comment">//负指数的情况</span></span><br><span class="line">        <span class="keyword">if</span> (N < <span class="number">0</span>) {</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            N *= -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (N > <span class="number">0</span>) {</span><br><span class="line">          <span class="comment">//判断N的二进制最后一位是否是1(也就是判断这部分是否保留)</span></span><br><span class="line">            <span class="keyword">if</span> ((N % <span class="number">2</span>) == <span class="number">1</span>) {</span><br><span class="line">                res *= x;</span><br><span class="line">            }</span><br><span class="line"><span class="comment">//x的2^0次方，到x的2^1次方，x的2^2次方，x的2^3次方</span></span><br><span class="line">            x *= x;</span><br><span class="line">          <span class="comment">//N右移</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>36-数组中只出现一次的数</title>
      <link href="/2020/04/28/36-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0/"/>
      <url>/2020/04/28/36-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><p>思路：</p><p>首先：位运算中异或的性质：<strong>两个相同数字异或=0</strong>，<strong>一个数和0异或还是它本身</strong>。</p><p>当<strong>只有一个数出现一次</strong>时，我们把数组中所有的数，依次异或运算，最后剩下的就是落单的数，因为成对儿出现的都抵消了。</p><p>依照这个思路，我们来看两个数（我们假设是AB）出现一次的数组。我们首先还是先异或，剩下的数字肯定是A、B异或的结果，<strong>这个结果的二进制中的1，表现的是A和B的不同的位</strong>。我们就取第一个1所在的位数，假设是第3位，接着把原数组分成<strong>两组</strong>，分组标准是第3位是否为1。如此，<strong>相同的数肯定在一个组</strong>，因为相同数字所有位都相同，而不同的数，<strong>肯定不在一组</strong>。然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字。</p><p>代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">2</span>){</span><br><span class="line">            num1[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">            num2[<span class="number">0</span>] = array[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//先把全部数依次异或，得到那两个出现一次数的异或结果</span></span><br><span class="line">        <span class="keyword">int</span> bitres = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < length; i++)</span><br><span class="line">            bitres ^= array[i];</span><br><span class="line">        </span><br><span class="line">        num1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        num2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//分组进行异或</span></span><br><span class="line">        <span class="keyword">int</span> index = findFirst1(bitres);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j < length; j++){</span><br><span class="line">            <span class="keyword">if</span>(isBit1(array[j], index))</span><br><span class="line">                num1[<span class="number">0</span>] ^= array[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num2[<span class="number">0</span>] ^= array[j];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//找到二进制bitres从右往左数第一个1的位置。如果末位是1 ，index记为0，依次增加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findFirst1</span><span class="params">(<span class="keyword">int</span> bitres)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(((bitres & <span class="number">1</span>) == <span class="number">0</span>) && index < <span class="number">32</span>){</span><br><span class="line">            bitres >>= <span class="number">1</span>;</span><br><span class="line">            index++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断target二进制下的第index位是否是0</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBit1</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> index)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> ((target >> index) & <span class="number">1</span>) == <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>还有一种比较简洁的写法，思路是一样的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) {</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums){</span><br><span class="line">            sum ^= num;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//这里的写法非常妙</span></span><br><span class="line">      <span class="comment">//-sum = sum取反码+1 所以sum&(-sum)得到sum最后一位的1</span></span><br><span class="line">        <span class="keyword">int</span> lowbit = sum & (-sum);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums){</span><br><span class="line">            <span class="keyword">if</span>((num & lowbit) == <span class="number">0</span>){</span><br><span class="line">                res[<span class="number">0</span>] ^= num;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                res[<span class="number">1</span>] ^= num;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>14-调整数组顺序使奇数位于偶数前面</title>
      <link href="/2020/04/28/14-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"/>
      <url>/2020/04/28/14-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><p>思路：</p><ol><li>从头到尾扫描，每遇到一个奇数，就把这个奇数前面的所有数字（除去已经放到前面的奇数）向后移动一格，这样前面会多出一个空格，把这个奇数放过去。复杂度O(n平方)</li><li>维护两个指针，开始时第一个指针p指向第一个数字，第二个指针q指向最后一个数字，当p指向偶数时停止，当q指向奇数时停止，交换，再继续靠近，直到相遇。（这种方法失去了稳定性）</li></ol><p>第一种思路的实现</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums) {</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < nums.length; i++){</span><br><span class="line">            <span class="keyword">if</span>(nums[i]%<span class="number">2</span> != <span class="number">0</span> ){</span><br><span class="line">                <span class="comment">//nums[count]到nums[i-1]后移一格</span></span><br><span class="line">                <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">                move(nums, count, i-<span class="number">1</span>);</span><br><span class="line">                nums[count++] = tmp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> count, <span class="keyword">int</span> k)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(k < <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i >= count; i--)</span><br><span class="line">            nums[i+<span class="number">1</span>] = nums[i];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>13-矩形覆盖</title>
      <link href="/2020/04/25/13-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/"/>
      <url>/2020/04/25/13-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>我们可以用2✖️1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2✖️1的小矩形无重叠地覆盖一个2✖️n的大矩形，总共有多少种方法？</p><p>思路：这个问题的本质，是动态规划。</p><p>target = 1时大矩形为2*1，只有一种摆放方法，return1；</p><p>target = 2 时大矩形为2*2，有两种摆放方法，return2；</p><p>target = n 时分为两步考虑：</p><ol><li>第一次摆放一块 2*1 的小矩阵，则摆放方法总共为f(target - 1)</li><li>第二次摆放一块1*2的小矩阵，则摆放方法总共为f(target-2)</li></ol><p><strong>如果看不到这个本质，就会把问题想的很复杂</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(target  <= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(target == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> RectCover((target-<span class="number">1</span>))+RectCover(target-<span class="number">2</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>12-反转链表</title>
      <link href="/2020/04/25/12-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/04/25/12-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>输入一个链表，反转链表后，输出新链表的表头。</p><p>思路：头插法。遍历链表，逐个插到新链表的头部</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">      <span class="comment">//新链表</span></span><br><span class="line">        ListNode cur = <span class="keyword">null</span>;</span><br><span class="line">        ListNode tmp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>){</span><br><span class="line">            tmp = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">          <span class="comment">//头插</span></span><br><span class="line">            tmp.next = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>还可以用递归，非常巧妙</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">      <span class="comment">//反转头结点后的链表</span></span><br><span class="line">        ListNode p =reverseList(head.next);</span><br><span class="line">      <span class="comment">//这一步很巧妙。head.next指向的是后面反转完的链表的末尾结点</span></span><br><span class="line">        head.next.next = head;</span><br><span class="line">      <span class="comment">//断开head和原来head.next的连接</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8-变态跳台阶</title>
      <link href="/2020/04/23/8-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2020/04/23/8-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法</p><p>思路：</p><p>f(n) = f(n-1)+f(n-2)+…+f(n-(n-1)) + f(n-n) </p><p>即 f(n) =  f(0) + f(1) + f(2) + f(3) + … + f(n-1)</p><p>可以得出： f(n) = 2*f(n-1)</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target >= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*JumpFloorII(target - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>每周新闻汇总：第3期</title>
      <link href="/2020/04/20/%E6%AF%8F%E5%91%A8%E6%96%B0%E9%97%BB%E6%B1%87%E6%80%BB%EF%BC%9A%E7%AC%AC3%E6%9C%9F/"/>
      <url>/2020/04/20/%E6%AF%8F%E5%91%A8%E6%96%B0%E9%97%BB%E6%B1%87%E6%80%BB%EF%BC%9A%E7%AC%AC3%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>#在疫情影响下，一场危机正在美国经济之中酝酿。很多人认为，这会是中国推进人民币国际化、破解美元霸权的好机会。但问题是，要怎么做？陈老师给出的具体方法是：<strong><font color="#0099ff">以人民币国债取代美元国债。与世界上那些手持美债、焦虑于危机到来后还不起钱的国家，进行谈判合作，进行债务置换，用人民币债取代美元债。就是我把钱借给你们，你们把美债去还了，变成欠我们的。</font></strong>因为我这个经济体最稳定，同时又是你们主要做生意的对象，这样对你们更安全，将来受到经济危机冲击就小了。如果这个策略走通了，那么人民币国际化就走出了第一步。这样也要比我们给美国输血、或者替代美国去给全球金融提供流动性要更好</p><p>#Instagram2019年的销售收入是200亿美元。相比之下，Youtube 的销售收入是150亿美元，并且其中很大一部分还必须分给视频创作者</p><p>#天基动能武器是一种处于概念阶段的大规模毁灭性武器，所有技术都已经实现了。最早的构想来自<strong><font color="#0099ff">将核导弹布署于太空卫星上，战时直接落在敌人国土上方，这样将极大缩减对方反应时间</font></strong>。然而，不久后就有人提出任何有质量的物体从卫星高度坠落，其杀伤力与陨石撞地球无异，不需要核武也能达成核武类似效果。这种概念日渐流行，因为核武器的辐射污染和政治敏感性，使得首先用核武器的正当性在国际社会很难立足，核弹头在太空的维持费用也高得惊人。而<strong><font color="#0099ff">这种新型天基武器反应速度快、命中精度高，且没有辐射，也不违反任何目前国际核武条约，威力大小透过弹体质量容易调整</font></strong></p><p>理论上，一块宽30厘米、长6.1米、重量达数吨的钨、钛或铀金属棒状弹体可穿过大气层燃烧阶段，从距离地面1000千米的太空落下的时速可达15000千米以上，相当于11.5吨 TNT 炸药，产生的动能撞击可以比拟小型战术核武器</p><p>#上海浦东张江科学城，上海集成电路设计产业园、张江总部园双双宣布开园，预计吸引的总投资额将不少于500亿元。现在，上海浦东集聚高新技术企业2900多家，拥有各类人才140多万。从芯片到药片，从国产大飞机到豪华邮轮，从基础研究到成果转化，浦东“火力全开”，形成了<strong><font color="#0099ff">生物医药、集成电路、人工智能等六大主导产业</font></strong>。浦东计划到2025年，这六大主导产业将达到千亿级规模</p><p>#「总」、「老板」、「经理」、「CEO」、「CTO」 … 这些只是企业内部的头衔，说明你是一个管理者，但<strong><font color="#0099ff">你「管理」的那些人是否真的认同和信任你，愿意追随你，100 % 的贡献自己的才华</font></strong>，才是更重要的事</p><p>#信任并不意味着总是要认同别人，事实上，<strong><font color="#0099ff">信任能让人更容易地不认同某人的观点</font></strong>。当大家不再担心「他是不是在针对我？」，「老板究竟喜欢哪个提案？」，「我说这个会不会让她觉得我在找茬？」，大家就可以更「心理安全」的把各自的好点子贡献出来，辩论平息之后，很可能得到最好的主意</p><p>#很多人反应淘宝或者拼多多买个东西，怎么微信上就看到推荐相关广告了？淘宝共享微信数据想想也不可能。一方面原因是上游广告平台，比如<strong><font color="#0099ff">有些广告平台，它可能代理京东也代理淘宝的广告，那么他们会做一些数据打通，然后这个广告代理公司可能也会在微信上投放相关的广告</font></strong>。平台与平台之间可能是孤立的，但是总有一些上游是可以打通的，另外，不管啥平台总得用手机号吧？<strong><font color="#0099ff">其实三大运营商才是最大的最上游的数据整合营销平台</font></strong></p></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>7-旋转数组的最小数字</title>
      <link href="/2020/04/19/7-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
      <url>/2020/04/19/7-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p>输入一个非递减排序（例如：1，2，3，3，4，5，8，8）的数组的一个旋转，输出旋转数组的最小元素。</p><p>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。</p><p>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p>思路一：暴力解法，依次往后遍历，找到第一个转折点，如果没找到转折点就返回第一个元素</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < numbers.length; i++){</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] < numbers[i-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> numbers[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路二：二分法。需要注意{1,0,1,1,1}，{1,1,1,0,1}这种情况下，mid无法判断是属于上半部分还是下半部分</p><p>设置 i, j 指针分别指向 numbers 数组左右两端，m = (i + j) // 2 为每次二分的中点（ “//“ 代表向下取整除法，因此恒有 i ≤ m < j ），可分为以下三种情况：<br>当 numbers[m] > numbers[j]时： m 一定在 左排序数组 中，即旋转点 x 一定在 [m + 1, j] 闭区间内，因此执行 i = m + 1<br>当 numbers[m] < numbers[j] 时： m 一定在 右排序数组 中，即旋转点 x 一定在[i, m] 闭区间内，因此执行 j = m<br>当 numbers[m] == numbers[j] 时： 无法判断 m 在哪个排序数组中，即无法判断旋转点 x 在 i, m 还是 m + 1, j 区间中。解决方案： 执行 j = j - 1 缩小判断范围 </p><p> 当 i = j 时跳出二分循环，并返回 numbers[i] 即可</p><p>是否可以用 numbers[m] 和 numbers[i] 比较做代替？<br>不可以。因为做比较的目的是判断 m 在哪个排序数组中。但在 numbers[m] > numbers[i]情况下，无法判断 mm 在哪个排序数组中。本质是因为 j 初始值肯定在右排序数组中； i 初始值无法确定在哪个排序数组中。<br>示例： 当 i = 0, j = 4, m = 2i=0,j=4,m=2 时，有 numbers[m] > numbers[i] ，以下两示例得出不同结果。<br>numbers = [1, 2, 3, 4 ,5] 旋转点 x=0 ： m 在右排序数组（此示例只有右排序数组）；<br>numbers = [3, 4, 5, 1 ,2] 旋转点 x=3 ： m 在左排序数组</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i < j) {</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[m] > numbers[j]) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[m] < numbers[j]) j = m;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> numbers[i];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-跳台阶</title>
      <link href="/2020/04/19/5-%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2020/04/19/5-%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><p>思路：第一种是递归。第二种是像斐波那契数列一样，迭代</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> JumpFloor(target - <span class="number">1</span>) + JumpFloor(target - <span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4-斐波那契数列</title>
      <link href="/2020/04/19/4-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
      <url>/2020/04/19/4-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p><p>n<=39</p><p>思路：第一种递归，第二种动态规划</p><p>递归：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n-<span class="number">1</span>) + Fibonacci(n-<span class="number">2</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>动态规划：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> g = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//往后走的步数</span></span><br><span class="line">        <span class="keyword">while</span>(n-- > <span class="number">0</span>){</span><br><span class="line">            <span class="comment">//int tem = g;</span></span><br><span class="line">            <span class="comment">//g = f + g;</span></span><br><span class="line">            <span class="comment">//f = tem;</span></span><br><span class="line">            g += f;</span><br><span class="line">           f = g - f;            </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>11-链表中倒数第K个结点</title>
      <link href="/2020/04/16/11-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
      <url>/2020/04/16/11-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACK%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>输入一个链表，输出该链表中倒数第k个结点</p><p>考研有这道题，如果C语言实现，用双指针，先让一个指针temp向后走k步，再让头指针head和它一起向后走，直到temp走到末尾，此时head指向的就是倒数第k个结点。用堆栈也可以，使用Stack，将结点压入栈中，再取出第k个，就是空间复杂度有点高。</p><p>我的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        ListNode pre=head, p=head;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">if</span>(i == k-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            p = p.next;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">//处理k-链表长度刚好等于1的情况</span></span><br><span class="line">            <span class="keyword">if</span>(p == <span class="keyword">null</span> && i== k-<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//处理k大于链表长度的其他情况</span></span><br><span class="line">        <span class="keyword">if</span>(i != k-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//pre和p同时向后走</span></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>){</span><br><span class="line">            p = p.next;</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pre = pre.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>别人的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        ListNode pre=<span class="keyword">null</span>,p=<span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//两个指针都指向头结点</span></span><br><span class="line">        p=head;</span><br><span class="line">        pre=head;</span><br><span class="line">        <span class="comment">//记录k值</span></span><br><span class="line">        <span class="keyword">int</span> a=k;</span><br><span class="line">        <span class="comment">//记录节点的个数</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//p指针先跑，并且记录节点数，当p指针跑了k-1个节点后，pre指针开始跑，</span></span><br><span class="line">        <span class="comment">//当p指针跑到最后时，pre所指指针就是倒数第k个节点</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>){</span><br><span class="line">            p=p.next;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span>(k<<span class="number">1</span>){</span><br><span class="line">                pre=pre.next;</span><br><span class="line">            }</span><br><span class="line">            k--;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//如果节点个数小于所求的倒数第k个节点，则返回空</span></span><br><span class="line">        <span class="keyword">if</span>(count<a) <span class="keyword">return</a)></span> <span class="keyword">null</span>;<br><span class="line">        <span class="keyword">return</span> pre;           </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>如果不考虑k 大于链表长度的情况：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>{</span><br><span class="line">        ListNode former = head, latter = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < k; i++)</span><br><span class="line">            former = former.next;</span><br><span class="line">        <span class="keyword">while</span>(former != <span class="keyword">null</span>) {</span><br><span class="line">            former = former.next;</span><br><span class="line">            latter = latter.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> latter;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10-重建二叉树</title>
      <link href="/2020/04/15/10-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2020/04/15/10-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p><strong>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树</strong>。</p><p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p>思路：</p><p>​    因为是树的结构，一般都是用递归来实现。用数学归纳法的思想就是，<strong>假设最后一步，就是root的左右子树都已经重建好了，那么我只要考虑将root的左右子树安上去即可。</strong></p><p>​    根据前序遍历的性质，第一个元素必然就是root，那么下面的工作就是如何确定root的左右子树的范围。</p><p>​    <strong>根据中序遍历的性质，root元素前面都是root的左子树，后面都是root的右子树</strong>。那么我们只要找到中序遍历中root的位置，就可以确定好左右子树的范围。正如上面所说，只需要将确定的左右子树安到root上即可。递归要注意出口，假设最后只有一个元素了，那么就要返回。</p><p>根据上面的思想，可以写出：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>{</span><br><span class="line">        <span class="comment">//数组长度为0的时候要处理</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> rootVal = pre[<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//数组长度仅为1的时候就要处理</span></span><br><span class="line">        <span class="keyword">if</span>(pre.length == <span class="number">1</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//我们先找到root所在的位置，确定好前序和中序中左子树和右子树序列的范围</span></span><br><span class="line">      <span class="comment">//（改进）这里可以用哈希表提高搜索效率</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(rootVal);</span><br><span class="line">        <span class="keyword">int</span> rootIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<in.length;i++){< span><br><span class="line">            <span class="keyword">if</span>(rootVal == in[i]){</span><br><span class="line">                rootIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//递归，假设root的左右子树都已经构建完毕，那么只要将左右子树安到root左右即可</span></span><br><span class="line">        <span class="comment">//这里注意Arrays.copyOfRange(int[],start,end)是[)的区间</span></span><br><span class="line">        root.left = reConstructBinaryTree(Arrays.copyOfRange(pre,<span class="number">1</span>,rootIndex+<span class="number">1</span>),Arrays.copyOfRange(in,<span class="number">0</span>,rootIndex));</span><br><span class="line">        root.right = reConstructBinaryTree(Arrays.copyOfRange(pre,rootIndex+<span class="number">1</span>,pre.length),Arrays.copyOfRange(in,rootIndex+<span class="number">1</span>,in.length));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></in.length;i++){<></span></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6-两个栈实现队列</title>
      <link href="/2020/04/13/6-%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2020/04/13/6-%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p>思路：</p><ol><li><p><strong>栈无法实现队列功能</strong>： 栈底元素（对应队首元素）无法直接删除，需要将上方所有元素出栈。</p></li><li><p><strong>双栈可实现列表倒序（这个性质很巧妙）</strong>： 设有含三个元素的栈 A = [1,2,3] 和空栈 B = []。若循环执行 A 元素出栈并添加入栈 B ，直到栈 A 为空，则 A=[] , B = [3,2,1] ，即 栈 B 元素实现栈 A 元素倒序 。</p></li><li><p><strong>利用栈 B 删除队首元素</strong>： 倒序后，B 执行出栈则相当于删除了 A 的栈底元素，即对应队首元素。</p></li></ol><p>也就是：入队时，直接进栈1。<strong>出队时，如果栈2为空，先把栈1全部pop再push到栈2，然后从栈2pop。出队时，如果栈2不为空，就直接从栈2中pop。</strong></p><p>相当于用一个栈来模拟入队，另一个栈作为辅助栈，颠倒顺序，模拟出队</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>{</span><br><span class="line">    Stack<integer> A,B;</integer></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        A = <span class="keyword">new</span> Stack<>();</span><br><span class="line">        B = <span class="keyword">new</span> Stack<>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        A.push(value);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(!B.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> B.pop();</span><br><span class="line">      <span class="comment">//这里不能忘，不然会报错。如果B，A都为空，返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(A.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span>(!A.isEmpty())</span><br><span class="line">            B.push(A.pop());</span><br><span class="line">        <span class="keyword">return</span> B.pop();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-从尾到头打印链表</title>
      <link href="/2020/04/12/3-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/04/12/3-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p>思路：有两种思路，第一是利用栈先入后出的特性完成，第二是利用递归。</p><p>堆栈实现：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList<integer> <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </integer></span>{</span><br><span class="line">        Stack<integer> stack = <span class="keyword">new</span> Stack<>();</integer></span><br><span class="line">        <span class="comment">//入栈</span></span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>){</span><br><span class="line">            stack.push(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        }</span><br><span class="line">        ArrayList<integer> arr = <span class="keyword">new</span> ArrayList<integer>();</integer></integer></span><br><span class="line">        <span class="comment">//出栈</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">            arr.add(stack.pop());</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>递归实现：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    ArrayList<integer> arr = <span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList<integer> <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </integer></span>{</span><br><span class="line">        <span class="keyword">if</span>(listNode != <span class="keyword">null</span>){</span><br><span class="line">            <span class="comment">//需要好好理解这个逻辑</span></span><br><span class="line">            printListFromTailToHead(listNode.next);</span><br><span class="line">            arr.add(listNode.val);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习方法</title>
      <link href="/2020/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
      <url>/2020/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>学习应该是理论和项目交叉来的。抓重点。</p><ul><li>数仓：学完Hadoop和Hive就可以看项目，看第一遍之后至少里面的hql能看懂，但涉及到的建模，脚本这些看不懂。接着就可以去看关于数仓建模以及数据仓库的一些知识点，另外可以学习下shell。数仓项目里面可能还有Sqoop，Kettle什么的，这种属于小框架和工具，遇到的时候去搜下它是什么就可以了。</li><li>实时：学完Spark或Flink，就可以开搞，如果涉及到Kafka和Flume也可以仅做了解。然后就开始看项目，第一遍看不懂很正常，看第二遍，第二遍你就知道你哪里看不懂了，把项目按阶段切开，去网上搜相关的Demo，网上的Demo大都通俗易懂，然后自己整理一下拼凑在项目里。</li><li>学完之后写简历，开始雕刻，业务场景怎么写，负责的内容怎么写，项目的流程怎么描述，开发过程是什么，数据量机器多少合适，有没有难点，框架怎么配置等等…前面学习的内容可能不会很多，但后面雕刻这部分是比较难的。可以借助外力，去网上找面经往自己的项目上套，去网上看技术难点往自己项目上套。搞完项目就剩项目框架的一些底层原理了，这个资料就更多了。</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>dubbo学习记录</title>
      <link href="/2020/04/11/dubbo%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/04/11/dubbo%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>为什么要用Dubbo？无dubbo情况下，RPC普遍存在的问题：</p><ol><li>rpc调用需要定制开发，很多额外的工作量</li><li><strong>分布式服务中，服务达到几百上千时，相互之间的调用错综复杂，相互依赖严重</strong></li><li>对集群性的服务，需要负载策略</li><li>对集群性的服务，需要能动态扩展节点</li></ol><p>dubbo介绍：<br>1，一个分布式、高性能、透明化的RPC服务框架。<br>2，提供服务自动注册、自动发现等高效服务治理方案。<br>3，其功能主要包括：高性能NIO通讯及多协议集成，服务动态寻址与路由，软负载均衡与容错，依赖分析与降级等。</p><p>dubbo架构流程：</p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200411164957620.png" data-fancybox="group" data-caption="image-20200411164957620" class="fancybox"><img alt="image-20200411164957620" style="zoom:50%;" title="image-20200411164957620" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200411164957620.png" class="lazyload"></a><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200411175008866.png" data-fancybox="group" data-caption="image-20200411175008866" class="fancybox"><img alt="image-20200411175008866" title="image-20200411175008866" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200411175008866.png" class="lazyload"></a></p><ol><li>container负责启动、加载、运行provider</li><li>provider启动时，向registry注册自己的服务<strong>(生产者注册服务)</strong></li><li>cousumer启动时，向registry订阅自己的服务<strong>（消费者订阅服务）</strong></li><li>registry提供provider列表给consumer，实时推送变动情况<strong>（注册中心提供能提供对应服务的服务器列表，并实时更新）</strong></li><li>consumer根据provider列表，按负载算法选一台provider调用（<strong>消费者选择调用哪台机器的服务，软负载均衡）</strong></li><li>monitor统计rpc的调用频次</li></ol></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2-顺时针打印矩阵</title>
      <link href="/2020/04/11/2-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
      <url>/2020/04/11/2-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10</p><p>思路：</p><ol><li><p>常规思路。用标记数组记录是否被访问，按右下左上右…的循环前进，遇到拐角处（下个位置已被访问或者越界）转换方向。边界处理有些麻烦。</p></li><li><p>比常规思路清晰一些。用一个剥圈函数，这个函数的核心就是 <strong>左上点和右下点</strong> 每次走完剥圈函数之后 左上角坐标++，右下角– 往圈内移。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    ArrayList  a=<span class="keyword">new</span> ArrayList(); <span class="comment">//  new一个数组 以便下面函数能调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tX=<span class="number">0</span>;<span class="comment">//左上x坐标</span></span><br><span class="line">        <span class="keyword">int</span> tY=<span class="number">0</span>;<span class="comment">//左上y坐标</span></span><br><span class="line">        <span class="keyword">int</span> dX=matrix.length-<span class="number">1</span>;<span class="comment">//右下x坐标</span></span><br><span class="line">        <span class="keyword">int</span> dY=matrix[<span class="number">0</span>].length-<span class="number">1</span>;<span class="comment">//右下y坐标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(tX<=dX&&tY<=dY){ <span class="comment">//左上边界最多到达右下边界 用于判断是否还是剥圈打印</span></span><br><span class="line">            printEdge(matrix,tX,tY,dX,dY);</span><br><span class="line">            tX++;</span><br><span class="line">            tY++;</span><br><span class="line">            dX--;</span><br><span class="line">            dY--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(<span class="keyword">int</span> [][] m,<span class="keyword">int</span> tX,<span class="keyword">int</span> tY,<span class="keyword">int</span> dX,<span class="keyword">int</span> dY)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(tX==dX){    <span class="comment">//先判断是否只是一横行 如果是 打印该横行的列（通常用于内圈）</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=tY;i<=dY;i++){</span><br><span class="line">                a.add(m[tX][i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tY==dY){  <span class="comment">//再判断是否只是一竖列 如果是 打印该横行的列（通常用于内圈</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=tX;i<=dX;i++){</span><br><span class="line">                a.add(m[i][tY]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">int</span> curY=tY;<span class="comment">//用2个变量储存 用于判断当前位置</span></span><br><span class="line">            <span class="keyword">int</span> curX=tX;</span><br><span class="line">            <span class="keyword">while</span>(curY!=dY){      <span class="comment">//当前位置未到达当前行的最右列 --》往右去</span></span><br><span class="line">                a.add(m[tX][curY]);</span><br><span class="line">                curY++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(curX!=dX){      <span class="comment">//当前位置未到达当前列的最底行 --》往下去</span></span><br><span class="line">                a.add(m[curX][dY]);</span><br><span class="line">                curX++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(curY!=tY){      <span class="comment">//当前位置未到达当前行的最左列 --》往左去</span></span><br><span class="line">                a.add(m[dX][curY]);</span><br><span class="line">                curY--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(curX!=tX){      <span class="comment">//当前位置未到达当前列的最顶行 --》往上去</span></span><br><span class="line">                a.add(m[curX][tY]);</span><br><span class="line">                curX--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li></ol><ol start="3"><li><p>最清晰的思路。模拟设定边界。<a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200411112605399.png" data-fancybox="group" data-caption="image-20200411112605399" class="fancybox"><img alt="image-20200411112605399" title="image-20200411112605399" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200411112605399.png" class="lazyload"></a>)<a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200411112652380.png" data-fancybox="group" data-caption="image-20200411112652380" class="fancybox"><img alt="image-20200411112652380" title="image-20200411112652380" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200411112652380.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) {</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[(r + <span class="number">1</span>) * (b + <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) {</span><br><span class="line">          <span class="comment">// 从左到右，依靠上边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i <= r; i++) res[x++] = matrix[t][i]; </span><br><span class="line">            <span class="keyword">if</span>(++t > b) <span class="keyword">break</span>;<span class="comment">//每次走完一个方向，向内收缩边界，并判断是否打印完毕</span></span><br><span class="line">          <span class="comment">// 从上到下，依靠右边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i <= b; i++) res[x++] = matrix[i][r];</span><br><span class="line">            <span class="keyword">if</span>(l > --r) <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 从右到左，依靠下边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i >= l; i--) res[x++] = matrix[b][i];</span><br><span class="line">            <span class="keyword">if</span>(t > --b) <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 从下到上，依靠左边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = b; i >= t; i--) res[x++] = matrix[i][l];</span><br><span class="line">            <span class="keyword">if</span>(++l > r) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li></ol></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1-包含min函数的栈</title>
      <link href="/2020/04/10/1-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
      <url>/2020/04/10/1-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p><strong>题目描述</strong></p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><p><strong>思路：</strong>普通栈的 push() 和 pop() 函数的复杂度为 O(1) ，而获取栈最小值min() 函数需要遍历整个栈，复杂度为 O(N)。这道题的难点是将 min() 函数复杂度降为 O(1)，可通过建立辅助栈实现。</p><p>数据栈 A ： 用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。<br>辅助栈 B ： 用于存储栈 A 中所有<strong>非严格降序</strong>的元素，则栈 A 中的最小元素始终对应栈 BB的栈顶元素，即 min() 函数只需返回栈 B 的栈顶元素即可。</p><p>因此，只需设法维护好 栈 B<em>B</em> 的元素，使其保持非严格降序，即可实现 min() 函数的O(1)复杂度。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200410112503218.png" data-fancybox="group" data-caption="image-20200410112503218" class="fancybox"><img alt="image-20200410112503218" title="image-20200410112503218" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200410112503218.png" class="lazyload"></a></p><p>函数设计：<br><strong>push(x) 函数</strong>： 重点是保持栈 B 的元素是 <strong>非严格降序</strong> 的。</p><p>将 x 压入栈 A （即 A.add(x) ）；<br>若 ① 栈 B 为空 或 ② x 小于等于 栈 B 的栈顶元素，则将 x 压入栈 B<br><strong>pop() 函数</strong>： 重点是保持栈 A, B的元素一致性 。</p><p>执行栈 A 出栈，将出栈元素记为 y ；<br>若 y 等于栈 B 的栈顶元素，则执行栈 B 出栈<br><strong>top() 函数</strong>： 直接返回栈 A 的栈顶元素即可</p><p><strong>min() 函数</strong>： 直接返回栈 BB 的栈顶元素即可</p><p>代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>{</span><br><span class="line">    Stack<integer> A, B;</integer></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>{</span><br><span class="line">        A = <span class="keyword">new</span> Stack<>();</span><br><span class="line">        B = <span class="keyword">new</span> Stack<>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        A.add(x);</span><br><span class="line">        <span class="keyword">if</span>(B.empty() || x <= B.peek()){</span><br><span class="line">            B.add(x);</span><br><span class="line">        }   </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> a = A.peek();</span><br><span class="line">        <span class="keyword">int</span> b = B.peek();</span><br><span class="line">        <span class="keyword">if</span>(a == b)</span><br><span class="line">            B.pop();</span><br><span class="line">        A.pop();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> A.peek();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python批量修改文件内容</title>
      <link href="/2020/04/09/python%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/"/>
      <url>/2020/04/09/python%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>今天想把文章的分类改一下，把“算法”改成“LeetCode”。手动改的话，需要一个个打开文件替换单词，用Python很快就搞定了。以后再想修改分类的时候，可以继续用。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line">mds = glob.glob(<span class="string">'文件目录/*.md'</span>)</span><br><span class="line"><span class="keyword">for</span> one_md <span class="keyword">in</span> mds:</span><br><span class="line">    print(one_md)</span><br><span class="line">    f = open(one_md, <span class="string">'r+'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    all_the_lines = f.readlines()</span><br><span class="line">    f.seek(<span class="number">0</span>)</span><br><span class="line">    f.truncate()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> all_the_lines:</span><br><span class="line">        line = line.replace(<span class="string">'- 算法'</span>, <span class="string">'- LeetCode'</span>)</span><br><span class="line">        f.write(line)</span><br><span class="line">    f.close()</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>129-求根到叶子节点数字之和</title>
      <link href="/2020/04/09/129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
      <url>/2020/04/09/129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p><p>例如，从根到叶子节点路径 1->2->3 代表数字 123。</p><p>计算从根到叶子节点生成的所有数字之和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例 1:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">输出: 25</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 1->2 代表数字 12.</span><br><span class="line">从根到叶子节点路径 1->3 代表数字 13.</span><br><span class="line">因此，数字总和 = 12 + 13 = 25.</span><br></pre></td></tr></tbody></table></figure></div><p>思路：先序遍历的思想+数字求和(每一层都比上层和*10+当前根节点的值)。递归的艺术。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">return</span> preorderSumNumbers(root, sum);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//求root下所有路径的数字和，并附带上层的数字和用于累加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">preorderSumNumbers</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//sum表示到当前这个节点，路径代表的数字</span></span><br><span class="line">        sum = sum * <span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> && root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">return</span> preorderSumNumbers(root.left, sum) + preorderSumNumbers(root.right, sum);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>575-分糖果</title>
      <link href="/2020/04/09/575-%E5%88%86%E7%B3%96%E6%9E%9C/"/>
      <url>/2020/04/09/575-%E5%88%86%E7%B3%96%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>有N个小朋友站在一排，每个小朋友都有一个评分</p><p>你现在要按以下的规则给孩子们分糖果：</p><ul><li>每个小朋友至少要分得一颗糖果</li><li>分数高的小朋友要他比旁边得分低的小朋友分得的糖果多</li></ul><p>你最少要分发多少颗糖果？</p><p>思路：不太容易想出来。</p><p>先从左到右遍历一遍，找出并处理所有右边分值大于左边分值的情况，再从右到左遍历一遍，找出并处理所有左边分值大于右边分值的情况，</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = ratings.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">      <span class="comment">//所有人的糖果初始都发一个</span></span><br><span class="line">        Arrays.fill(count, <span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//从左向右扫描，保证一个方向上分数更大的糖果更多</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < len; i++){</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] > ratings[i-<span class="number">1</span>])</span><br><span class="line">                count[i] = count[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//从右向左扫描，保证另一个方向上分数更大的糖果更多</span></span><br><span class="line">      <span class="comment">//注意 count[i] <= count[i+1] 这个条件</span></span><br><span class="line">        <span class="comment">//如果已经满足 count[i] > count[i+1]，就不用调整了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i >= <span class="number">0</span>; i--){</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] > ratings[i+<span class="number">1</span>] && count[i] <= count[i+<span class="number">1</span>])</span><br><span class="line">                count[i] = count[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//求和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < len; i++){</span><br><span class="line">            res += count[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL常用操作</title>
      <link href="/2020/04/06/MySQL%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/04/06/MySQL%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>学会MySQL的关键是理解其语句的执行顺序。</p><h4 id="语法顺序"><a href="#语法顺序" class="headerlink" title="语法顺序"></a>语法顺序</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select[distinct]  </span><br><span class="line">from  </span><br><span class="line">join </span><br><span class="line">on  </span><br><span class="line">where  </span><br><span class="line">group by  </span><br><span class="line">having  </span><br><span class="line">union  </span><br><span class="line">order by  </span><br><span class="line">limit</span><br></pre></td></tr></tbody></table></figure></div><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from  </span><br><span class="line">on  </span><br><span class="line">join  </span><br><span class="line">where  </span><br><span class="line">group by  </span><br><span class="line">having  </span><br><span class="line">select  </span><br><span class="line">distinct  </span><br><span class="line">union  </span><br><span class="line">order by</span><br></pre></td></tr></tbody></table></figure></div><h4 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h4><p>用法：WHERE 条件1 AND/OR 条件2</p><p>常用的操作符都可以用，注意<>和！= 一样表示不等于</p><h4 id="Like子句（模糊查询）"><a href="#Like子句（模糊查询）" class="headerlink" title="Like子句（模糊查询）"></a>Like子句（模糊查询）</h4><p>用法：<strong>用在where子句中</strong>。WHERE 字段1 LIKE 条件1</p><p>MySQL提供了四种匹配方式</p><ol><li><p><strong>%</strong>：表示任意 0 个或多个字符。</p></li><li><p><strong>_</strong>：表示任意单个字符。</p></li><li><p><strong>[]</strong>：表示括号内所列字符中的一个（类似正则表达式）。</p></li><li><p><strong>[^]</strong> ：表示不在括号所列之内的单个字符。</p><p>例如：</p></li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">'%a'     //以a结尾的数据</span><br><span class="line">'a%'     //以a开头的数据</span><br><span class="line">'%a%'    //含有a的数据</span><br><span class="line">'_a_'    //三位且中间字母是a的</span><br><span class="line">'_a'     //两位且结尾字母是a的</span><br><span class="line">'a_'     //两位且开头字母是a的</span><br></pre></td></tr></tbody></table></figure></div><h4 id="ORDER-BY（排序）"><a href="#ORDER-BY（排序）" class="headerlink" title="ORDER BY（排序）"></a>ORDER BY（排序）</h4><p>用法：指定字段作为排序的条件。用ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，是按升序排列。</p><h4 id="GROUP-BY（分组）"><a href="#GROUP-BY（分组）" class="headerlink" title="GROUP BY（分组）"></a>GROUP BY（分组）</h4><p>用法：根据某个字段对结果集进行分组。在分组的列上可以使用 COUNT, SUM, AVG等函数。</p><p>Having和where类似，但必须和group by同时使用，用来根据指定条件过滤分组</p><p>大概是下图的意思：如果按照name进行GROUP BY</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200526105059021.png" data-fancybox="group" data-caption="image-20200526105059021" class="fancybox"><img alt="image-20200526105059021" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200526105059021.png" class="lazyload" title="image-20200526105059021"></a></p><h4 id="join（连接）"><a href="#join（连接）" class="headerlink" title="join（连接）"></a>join（连接）</h4><p>用法：多表根据主外键进行连接。默认情况下join指的是inner join</p><ul><li><strong>INNER JOIN（内连接）</strong>：获取两个表中字段匹配关系的记录。</li><li><strong>LEFT JOIN（左连接）：</strong>获取左表所有记录，即使右表没有对应匹配的记录。</li><li><strong>RIGHT JOIN（右连接）：</strong> 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</li></ul><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200406114320943.png" data-fancybox="group" data-caption="image-20200406114320943" class="fancybox"><img alt="image-20200406114320943" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200406114320943.png" class="lazyload" title="image-20200406114320943"></a></p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200406114340472.png" data-fancybox="group" data-caption="image-20200406114340472" class="fancybox"><img alt="image-20200406114340472" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200406114340472.png" class="lazyload" title="image-20200406114340472"></a></p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200406114355213.png" data-fancybox="group" data-caption="image-20200406114355213" class="fancybox"><img alt="image-20200406114355213" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200406114355213.png" class="lazyload" title="image-20200406114355213"></a></p><p>SQL的函数分两种：</p><ol><li>Aggregate（聚合） 函数计算从列中取得的值，返回一个单一的值。</li></ol><p>有用的 Aggregate 函数：</p><ul><li>AVG() - 返回平均值</li><li>COUNT() - 返回行数</li><li>FIRST() - 返回第一个记录的值</li><li>LAST() - 返回最后一个记录的值</li><li>MAX() - 返回最大值</li><li>MIN() - 返回最小值</li><li>SUM() - 返回总和</li></ul><ol start="2"><li>SQL Scalar 函数基于输入值，返回一个单一的值。</li></ol><p>有用的 Scalar 函数：</p><ul><li>UCASE() - 将某个字段转换为大写</li><li>LCASE() - 将某个字段转换为小写</li><li>MID() - 从某个文本字段提取字符，MySql 中使用</li><li>SubString(字段，1，end) - 从某个文本字段提取字符</li><li>LEN() - 返回某个文本字段的长度</li><li>ROUND() - 对某个数值字段进行指定小数位数的四舍五入</li><li>NOW() - 返回当前的系统日期和时间</li><li>FORMAT() - 格式化某个字段的显示方式</li></ul><p>没有完全理解的概念：</p><p>UNION</p><p>INSERT INTO</p><p>CREAT INDEX</p><p>视图</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>139-单词拆分</title>
      <link href="/2020/04/05/139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
      <url>/2020/04/05/139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个字符串s和一组单词dict，判断s是否可以用空格分割成一个单词序列，使得单词序列中所有的单词都是dict中的单词（序列可以包含一个或多个单词）。</p><p>例如:<br>给定s=“leetcode”；<br>dict=[“leet”, “code”].<br>返回true，因为”leetcode”可以被分割成”leet code”.</p><p>注意：dict中可以有很多单词，而且s中重复的单词在dict中有一个就可以。</p><p>思路：动态规划。</p><p>状态转移方程：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(i) 表示s[0,i]是否可以分词</span><br><span class="line">f(i) = f(j) && f(j+1,i); 0 <= j < i</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, Set<string> dict)</string></span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">      <span class="comment">//注意这个细节，申请的长度为len+1。arr[i]表示字符串前i个是否可以划分单词</span></span><br><span class="line">        <span class="keyword">boolean</span>[] arr = <span class="keyword">new</span> <span class="keyword">boolean</span>[len+<span class="number">1</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//把握整体思想，细节实际使用时再注意</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i <= len; i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j < i; j++){</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&&dict.contains(s.substring(j,i))){</span><br><span class="line">                    arr[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> arr[len];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划解题思路</title>
      <link href="/2020/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/"/>
      <url>/2020/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p><strong>动态规划问题的⼀般形式就是求最值</strong></p><p><strong>求解动态规划的核⼼问题是穷举</strong></p><p>动态规划的穷举有点特别，因为这类问题<strong>存在「重叠⼦问题」</strong>，如果暴⼒穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优 化穷举过程，避免不必要的计算。 ⽽且，动态规划问题⼀定会<strong>具备「最优⼦结构」</strong>，才能通过⼦问题的最值，得到原问题的最值。 </p><p>只有列出<strong>正确的「状态转移⽅程」</strong>才能正确地穷举。 </p><p>动态规划三要素：</p><ul><li><p>重叠⼦问题</p></li><li><p>最优⼦结构</p></li><li><p><strong>状态转移⽅程</strong>（最关键的）</p><ul><li>明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base </li></ul><p>case </p></li></ul></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>143-重排链表</title>
      <link href="/2020/04/03/143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/04/03/143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>将给定的单链表L： <strong>L 0→L 1→…→L n-1→L n</strong>,</p><p>重新排序为： <strong>L 0→L n →L 1→L n-1→L 2→L n-2→…</strong></p><p>要求使用原地算法，并且不改变节点的值</p><p>例如：对于给定的单链表</p><p>{1,2,3,4,5,6}，将其重新排序为{1,6,2,5,3,4}.</p><p>{1,2,3,4,5,6,7}，将其重新排序为{1,7,2,6,3,5,4}.</p><p>思路：</p><ol><li>先用快慢指针找到中间节点（<strong>注意链表长度为偶数时，中间节点为前半段的末尾节点</strong>）</li><li>拆分链表，将中间节点之后的链表反转</li><li>合并前半段和后半段（反转过的）链表</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 快满指针找到中间节点</span></span><br><span class="line">      <span class="comment">//注意这里的写法，可以记下来，经常用到，不用单独考虑长度为偶数的情况</span></span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> && fast.next.next != <span class="keyword">null</span>){</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拆分链表，并反转中间节点之后的链表</span></span><br><span class="line">      <span class="comment">//这里反转链表用的是头插法，如果不理解画下图就明白了</span></span><br><span class="line">        ListNode after = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(after != <span class="keyword">null</span>){</span><br><span class="line">            ListNode temp = after.next;</span><br><span class="line">            after.next = pre;</span><br><span class="line">            pre = after;</span><br><span class="line">            after = temp;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 合并两个链表（这两个链表长度相等或相差1）</span></span><br><span class="line">      <span class="comment">//配合画图理解思路</span></span><br><span class="line">        ListNode first = head;</span><br><span class="line">        after = pre;</span><br><span class="line">        <span class="keyword">while</span>(first != <span class="keyword">null</span> && after != <span class="keyword">null</span>){</span><br><span class="line">            ListNode ftemp = first.next;</span><br><span class="line">            ListNode aftemp = after.next;</span><br><span class="line">            first.next = after;</span><br><span class="line">            first = ftemp;</span><br><span class="line">            after.next = first;        </span><br><span class="line">            after = aftemp;        </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>141-环形链表</title>
      <link href="/2020/04/03/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/04/03/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>判断给定的链表中是否有环</p><p>思路一：</p><p>用快慢指针。如果没有环，快指针就会先到达尾部，如果有环，那么快慢指针一定会相遇。为什么一定会相遇？考虑下面这种情况（记作情况 A）- 假如快跑者只落后慢跑者一步，在下一次迭代中，它们就会分别跑了一步或两步并相遇。其他情况又会怎样呢？例如，我们没有考虑快跑者在慢跑者之后两步或三步的情况。但其实不难想到，因为在下一次或者下下次迭代后，又会变成上面提到的情况 A。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next.next;</span><br><span class="line">      <span class="comment">//快指针去追慢指针</span></span><br><span class="line">        <span class="keyword">while</span>(slow != fast){</span><br><span class="line">          <span class="comment">//如果快指针到了尾部，说明没有环</span></span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路二：</p><p>用哈希表。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    Set<listnode> nodesSeen = <span class="keyword">new</span> HashSet<>();</listnode></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (nodesSeen.contains(head)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            nodesSeen.add(head);</span><br><span class="line">        }</span><br><span class="line">        head = head.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>289-生命游戏</title>
      <link href="/2020/04/02/289-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/"/>
      <url>/2020/04/02/289-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p><ol><li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li><li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li><li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li><li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li></ol><p>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p><p>注意，面板上所有格子需要<strong>同时被更新</strong>：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。</p><p>示例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入： </span><br><span class="line">[</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,1],</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,1,1],</span><br><span class="line">  [0,1,0]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p>思路一：</p><p><strong>复制一个数组保存之前的状态，然后修改原数组。</strong>原理很简单，但是要注意细胞状态的同时更新，因为每个细胞状态改变后，会影响这轮更新中其他细胞的判断。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] neighbors = {<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>};</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = board.length;</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建复制数组 copyBoard</span></span><br><span class="line">        <span class="keyword">int</span>[][] copyBoard = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从原数组复制一份到 copyBoard 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row < rows; row++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col < cols; col++) {</span><br><span class="line">                copyBoard[row][col] = board[row][col];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历面板每一个格子里的细胞</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row < rows; row++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col < cols; col++) {</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对于每一个细胞统计其八个相邻位置里的活细胞数量</span></span><br><span class="line">                <span class="keyword">int</span> liveNeighbors = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//用这种方式向周围扩展，可以学习借鉴</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">3</span>; i++) {</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < <span class="number">3</span>; j++) {</span><br><span class="line"><span class="comment">//如果是自身就跳过，那么就还剩8个“邻居”</span></span><br><span class="line">                        <span class="keyword">if</span> (!(neighbors[i] == <span class="number">0</span> && neighbors[j] == <span class="number">0</span>)) {</span><br><span class="line">                            <span class="keyword">int</span> r = (row + neighbors[i]);</span><br><span class="line">                            <span class="keyword">int</span> c = (col + neighbors[j]);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 查看相邻的细胞是否是活细胞</span></span><br><span class="line">                            <span class="keyword">if</span> ((r < rows && r >= <span class="number">0</span>) && (c < cols && c >= <span class="number">0</span>) && (copyBoard[r][c] == <span class="number">1</span>)) {</span><br><span class="line">                                liveNeighbors += <span class="number">1</span>;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 规则 1 或规则 3      </span></span><br><span class="line">                <span class="keyword">if</span> ((copyBoard[row][col] == <span class="number">1</span>) && (liveNeighbors < <span class="number">2</span> || liveNeighbors > <span class="number">3</span>)) {</span><br><span class="line">                    board[row][col] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 规则 4</span></span><br><span class="line">                <span class="keyword">if</span> (copyBoard[row][col] == <span class="number">0</span> && liveNeighbors == <span class="number">3</span>) {</span><br><span class="line">                    board[row][col] = <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路二：<strong>使用额外的状态。</strong>上一种方法空间开销比较大，其实可以用一种新的状态既保存之前的状态，又能表示现在的状态。举个例子，如果细胞之前的状态是 0，但是在更新之后变成了 1，我们就可以给它定义一个复合状态 2。这样我们看到 2，既能知道目前这个细胞是活的，还能知道它之前是死的。</p><p>具体的计算规则如下所示：</p><ol><li><p>规则 1：如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡。这时候，<strong>将细胞值改为 -1，代表这个细胞过去是活的现在死了；</strong></p></li><li><p>规则 2：如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活。这时候<strong>不改变细胞的值，仍为 1；</strong></p></li><li><p>规则 3：如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡。这时候，<strong>将细胞的值改为 -1，代表这个细胞过去是活的现在死了</strong>。可以看到，因为规则 1 和规则 3 下细胞的起始终止状态是一致的，因此它们的复合状态也一致；</p></li><li><p>规则 4：如果死细胞周围正好有三个活细胞，则该位置死细胞复活。这时候，<strong>将细胞的值改为 2，代表这个细胞过去是死的现在活了。</strong></p></li></ol><p>这样思路就很简单了，第一遍遍历的时候，用复合状态更新数组，然后根据复合状态的规则恢复成正常的表示方式。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] neighbors = {<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>};</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = board.length;</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历面板每一个格子里的细胞</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row < rows; row++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col < cols; col++) {</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对于每一个细胞统计其八个相邻位置里的活细胞数量</span></span><br><span class="line">                <span class="keyword">int</span> liveNeighbors = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">3</span>; i++) {</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < <span class="number">3</span>; j++) {</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!(neighbors[i] == <span class="number">0</span> && neighbors[j] == <span class="number">0</span>)) {</span><br><span class="line">                            <span class="comment">// 相邻位置的坐标</span></span><br><span class="line">                            <span class="keyword">int</span> r = (row + neighbors[i]);</span><br><span class="line">                            <span class="keyword">int</span> c = (col + neighbors[j]);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 查看相邻的细胞是否是活细胞</span></span><br><span class="line">                            <span class="keyword">if</span> ((r < rows && r >= <span class="number">0</span>) && (c < cols && c >= <span class="number">0</span>) && (Math.abs(board[r][c]) == <span class="number">1</span>)) {</span><br><span class="line">                                liveNeighbors += <span class="number">1</span>;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 规则 1 或规则 3 </span></span><br><span class="line">                <span class="keyword">if</span> ((board[row][col] == <span class="number">1</span>) && (liveNeighbors < <span class="number">2</span> || liveNeighbors > <span class="number">3</span>)) {</span><br><span class="line">                    <span class="comment">// -1 代表这个细胞过去是活的现在死了</span></span><br><span class="line">                    board[row][col] = -<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 规则 4</span></span><br><span class="line">                <span class="keyword">if</span> (board[row][col] == <span class="number">0</span> && liveNeighbors == <span class="number">3</span>) {</span><br><span class="line">                    <span class="comment">// 2 代表这个细胞过去是死的现在活了</span></span><br><span class="line">                    board[row][col] = <span class="number">2</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 board 得到一次更新后的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row < rows; row++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col < cols; col++) {</span><br><span class="line">                <span class="keyword">if</span> (board[row][col] > <span class="number">0</span>) {</span><br><span class="line">                    board[row][col] = <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    board[row][col] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>147-对链表进行插入排序</title>
      <link href="/2020/04/02/147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/04/02/147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>使用插入排序对链表进行排序。</p><p>思路：</p><ol><li><p>新建一个虚拟节点。因为有的节点可能会直接插到head之前</p></li><li><p>cur指向的节点及其后面所有节点都是未排序的，前面的都是排好序的</p></li><li><p>每次插入一个节点时，pre都从dummy开始往后寻找插入点（dummy后一个节点到cur前一个节点都是排好序的）</p></li><li><p>找到插入点后移动指针进行插入</p></li></ol><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200402103532859.png" data-fancybox="group" data-caption="image-20200402103532859" class="fancybox"><img alt="image-20200402103532859" title="image-20200402103532859" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200402103532859.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) {</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        <span class="comment">//判断一下</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//新建一个虚拟节点。因为有的节点可能会直接插到head之前</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//curr指向的节点及其后面所有节点都是未排序的，前面的都是排好序的</span></span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>){</span><br><span class="line">            <span class="comment">//每次循环，pre都重新指向dummy，dummy后一个节点到curr前一个节点都是排好序的</span></span><br><span class="line">            ListNode pre = dummy;</span><br><span class="line">            <span class="comment">//保存一下当前节点后面一个节点的引用</span></span><br><span class="line">            ListNode next = curr.next;</span><br><span class="line">            <span class="comment">//每次都从dummy节点下一个开始找，前面都是排好序的，如果小于当前节点则指针后移，一直找到pre.next为空</span></span><br><span class="line">            <span class="comment">//或者比当前节点大的时候，停止，表明pre的下一个节点就是当前节点应该放的位置</span></span><br><span class="line">            <span class="keyword">while</span>(pre.next != <span class="keyword">null</span> && pre.next.val < curr.val){</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//找到当前节点应该放的位置之后，下面的工作就是移动指针，让curr插到pre和pre.next中间</span></span><br><span class="line">            <span class="comment">//然后让curr后移一位，前面都是排好序的</span></span><br><span class="line">            curr.next = pre.next;</span><br><span class="line">            pre.next = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//dummy后面就是我们所需要的用插入排序排好序的链表</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis总结</title>
      <link href="/2020/04/01/Mybatis%E6%80%BB%E7%BB%93/"/>
      <url>/2020/04/01/Mybatis%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="Mybatis作用"><a href="#Mybatis作用" class="headerlink" title="Mybatis作用"></a>Mybatis作用</h4><p>用JDBC操作数据库比较繁琐，Mybatis可以简化对数据库的操作</p><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><ul><li>SqlMapConfig.xml。全局的配置文件，配置mybatis的运行环境等信息</li><li>mapper.xml。对应一张表，配置了操作数据库的SQL语句，需要在SqlMapConfig.xml中加载</li><li>构造SQLSessionFactory（会话工厂）</li><li>通过会话工厂创建Sqlsession（会话），用它操作数据库</li></ul><h4 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h4><p>增删改查有一对多，多对一，多对多等，一般会准备好pojo对象，并且对象的属性和数据库表中的字段一一对应。</p><p>以最简单的增加操作为例：</p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200401225818536.png" data-fancybox="group" data-caption="image-20200401225818536" class="fancybox"><img alt="image-20200401225818536" style="zoom:50%;" title="image-20200401225818536" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200401225818536.png" class="lazyload"></a><p>在mapper文件里，通过select，insert等标签写SQL语句。标签上的id是为了上面调用时找到这条语句， parameterType指定了传入的参数类型，resultType表指定了返回结果的类型。其中 <strong>#{ }用来表示占位符</strong>，<strong>${ }用来表示字符串拼接</strong></p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200401230028536.png" data-fancybox="group" data-caption="image-20200401230028536" class="fancybox"><img alt="image-20200401230028536" style="zoom:50%;" title="image-20200401230028536" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200401230028536.png" class="lazyload"></a><h4 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h4><p>在mapper.xml文件里可以用<strong><if> <where></where></if></strong>等标签，根据参数动态调整SQL语句。</p><p>例如：如果没有传参数name,那么就查询所有，如果有name参数，那么就进行模糊查询</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listProduct"</span> <span class="attr">resultType</span>=<span class="string">"Product"</span>></span></span><br><span class="line">select * from product_</span><br><span class="line"><span class="tag"><<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name!=null"</span>></span></span><br><span class="line">where name like concat('%',#{name},'%')</span><br><span class="line"><span class="tag"><!--<span class="name"-->if</span>></span> <br><span class="line"><span class="tag"><!--<span class="name"-->select</span>></span><br></pre></td></tr></tbody></table></figure></div><h4 id="修改为注解的方式"><a href="#修改为注解的方式" class="headerlink" title="修改为注解的方式"></a>修改为注解的方式</h4><p>例如：</p><p>原本有Category.xml</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><!--?xml version="1.0" encoding="UTF-8"?--></span></span><br><span class="line"><span class="meta">mapper</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.how2java.pojo"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addCategory"</span> <span class="attr">parameterType</span>=<span class="string">"Category"</span> ></span></span><br><span class="line">        insert into category_ ( name ) values (#{name})    </span><br><span class="line">    <span class="tag"><!--<span class="name"-->insert</span>></span><br><span class="line">    </span><br><span class="line">    <span class="tag"><<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteCategory"</span> <span class="attr">parameterType</span>=<span class="string">"Category"</span> ></span></span><br><span class="line">        delete from category_ where id= #{id}   </span><br><span class="line">    <span class="tag"><!--<span class="name"-->delete</span>></span><br><span class="line">    </span><br><span class="line">    <span class="tag"><<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getCategory"</span> <span class="attr">parameterType</span>=<span class="string">"_int"</span> <span class="attr">resultType</span>=<span class="string">"Category"</span>></span></span><br><span class="line">        select * from   category_  where id= #{id}    </span><br><span class="line">    <span class="tag"><!--<span class="name"-->select</span>></span><br><span class="line"></span><br><span class="line">    <span class="tag"><<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateCategory"</span> <span class="attr">parameterType</span>=<span class="string">"Category"</span> ></span></span><br><span class="line">        update category_ set name=#{name} where id=#{id}    </span><br><span class="line">    <span class="tag"><!--<span class="name"-->update</span>></span><br><span class="line">    <span class="tag"><<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listCategory"</span> <span class="attr">resultType</span>=<span class="string">"Category"</span>></span></span><br><span class="line">        select * from   category_      </span><br><span class="line">    <span class="tag"><!--<span class="name"-->select</span>></span>    <br><span class="line"><span class="tag"><!--<span class="name"-->mapper</span>></span><br></pre></td></tr></tbody></table></figure></div><p>修改为注解的方式就要新增加接口CategoryMapper ，并在接口中声明的方法上，加上注解，其实就是把SQL语句从XML挪到了注解上来</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Delete;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Update;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xxx.pojo.Category;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CategoryMapper</span> </span>{</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">" insert into category_ ( name ) values (#{name}) "</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Category category)</span></span>;  </span><br><span class="line">       </span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">" delete from category_ where id= #{id} "</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>;  </span><br><span class="line">       </span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from category_ where id= #{id} "</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Category <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span></span>;  </span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"update category_ set name=#{name} where id=#{id} "</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Category category)</span></span>;   </span><br><span class="line">       </span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">" select * from category_ "</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List<category> <span class="title">list</span><span class="params">()</span></category></span>;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>然后在mybatis的配置文件中，增加对CategoryMapper的映射</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">mappers</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.xxx.mapper.CategoryMapper"</span>/></span> </span><br><span class="line"><span class="tag"><!--<span class="name"-->mappers</span>></span><br></pre></td></tr></tbody></table></figure></div><p>简单的测试一下。要注意CategoryMapper接口是不能凭空实例化的，必然是某个类实现了这个接口，这个类去进行实例化。下面并没有出现这个实现类，那么这个实现类是如何存在的呢？ 这个是由mybatis采用动态代理技术临时创建的实现类。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.mapper.CategoryMapper;</span><br><span class="line"><span class="keyword">import</span> com.how2java.pojo.Category;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> </span>{</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">        CategoryMapper mapper = session.getMapper(CategoryMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//        add(mapper);</span></span><br><span class="line"><span class="comment">//        delete(mapper);</span></span><br><span class="line"><span class="comment">//        get(mapper);</span></span><br><span class="line"><span class="comment">//        update(mapper);</span></span><br><span class="line">        listAll(mapper);</span><br><span class="line">             </span><br><span class="line">        session.commit();</span><br><span class="line">        session.close();</span><br><span class="line">  </span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(CategoryMapper mapper)</span> </span>{</span><br><span class="line">        Category c= mapper.get(<span class="number">8</span>);</span><br><span class="line">        c.setName(<span class="string">"修改了的Category名称"</span>);</span><br><span class="line">        mapper.update(c);</span><br><span class="line">        listAll(mapper);</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(CategoryMapper mapper)</span> </span>{</span><br><span class="line">        Category c= mapper.get(<span class="number">8</span>);</span><br><span class="line">        System.out.println(c.getName());</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(CategoryMapper mapper)</span> </span>{</span><br><span class="line">        mapper.delete(<span class="number">2</span>);</span><br><span class="line">        listAll(mapper);</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(CategoryMapper mapper)</span> </span>{</span><br><span class="line">        Category c = <span class="keyword">new</span> Category();</span><br><span class="line">        c.setName(<span class="string">"新增加的Category"</span>);</span><br><span class="line">        mapper.add(c);</span><br><span class="line">        listAll(mapper);</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAll</span><span class="params">(CategoryMapper mapper)</span> </span>{</span><br><span class="line">        List<category> cs = mapper.list();</category></span><br><span class="line">        <span class="keyword">for</span> (Category c : cs) {</span><br><span class="line">            System.out.println(c.getName());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>日志</li><li>事务管理</li><li>延迟加载</li><li>分页</li><li>一/二级缓存</li><li>c3p0连接池</li><li>逆向工程</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>144-二叉树的前序遍历</title>
      <link href="/2020/04/01/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2020/04/01/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>二叉树的前序遍历（非递归）</p><p>思路：</p><p>1.根节点入栈</p><p>2.如果栈不为空，取出栈顶元素并访问。栈顶元素的右子节点，左子节点（如果结点为null则跳过）依次入栈。<strong>（注意顺序是先入右子结点，再入左子节点）</strong></p><p>3.重复第二步</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) { val = x; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList<integer> <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </integer></span>{</span><br><span class="line">        ArrayList<integer> res = <span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Stack<treenode> stack = <span class="keyword">new</span> Stack<>();</treenode></span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()){</span><br><span class="line">          <span class="comment">//访问节点</span></span><br><span class="line">            TreeNode p = stack.pop();</span><br><span class="line">            res.add(p.val);</span><br><span class="line">          <span class="comment">//右子节点入栈</span></span><br><span class="line">            <span class="keyword">if</span>(p.right != <span class="keyword">null</span>)</span><br><span class="line">                stack.push(p.right);</span><br><span class="line">          <span class="comment">//左子节点入栈</span></span><br><span class="line">            <span class="keyword">if</span>(p.left != <span class="keyword">null</span>)</span><br><span class="line">                stack.push(p.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>149-直线上最多的点数</title>
      <link href="/2020/03/30/149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/"/>
      <url>/2020/03/30/149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>对于给定的n个位于同一二维平面上的点，求最多能有多少个点位于同一直线上。</p><p>思路：穷举法，判断多点是否在同一直线时，要注意特殊情况，水平或垂直。其他的方法有点复杂，比如计算斜率，用double可能还不够精确。</p><p>1) 选择第一个点A1 </p><p>2) 选择第二个点A2, 和第一个点构成一条直线, </p><p>3) 遍历剩下的n-2个点Ai, 判断Ai与A1构成的直线是否与A2与A1构成的直线保持一致,若是,则A1A2直线上的点数就+1</p><p>4)每次求完A1A2直线上的最大点数, 和结果取最大值. 遍历结束就是结果 </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(Point[] points)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == points) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (points.length < <span class="number">3</span>) {</span><br><span class="line">            <span class="keyword">return</span> points.length;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> maxPoints = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < points.length; i++) {</span><br><span class="line">        <span class="comment">//第一个点</span></span><br><span class="line">            <span class="keyword">int</span> x1 = points[i].x;</span><br><span class="line">            <span class="keyword">int</span> y1 = points[i].y;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j < points.length; j++) {</span><br><span class="line">              <span class="comment">//第二个点</span></span><br><span class="line">                <span class="keyword">int</span> x2 = points[j].x;</span><br><span class="line">                <span class="keyword">int</span> y2 = points[j].y;</span><br><span class="line">                <span class="keyword">int</span> max = <span class="number">2</span>;</span><br><span class="line">              <span class="comment">//遍历剩下的点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k < points.length; k++) {</span><br><span class="line">                    <span class="keyword">if</span> (k == i || k == j) {</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    }</span><br><span class="line"><span class="keyword">int</span> x3 = points[k].x;</span><br><span class="line">                    <span class="keyword">int</span> y3 = points[k].y;</span><br><span class="line">                    <span class="keyword">boolean</span> flag;</span><br><span class="line">                  <span class="comment">//如果是水平线</span></span><br><span class="line">                    <span class="keyword">if</span> (x1 == x2) {</span><br><span class="line">                        flag = x3 == x1;</span><br><span class="line">                    } </span><br><span class="line">                  <span class="comment">//如果是垂直线</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (y1 == y2) {</span><br><span class="line">                        flag = y3 == y1;</span><br><span class="line">                    }</span><br><span class="line">                  <span class="comment">//这里用乘法别用除法</span></span><br><span class="line">                  <span class="keyword">else</span> {</span><br><span class="line">                        flag = (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 -x1);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span> (flag) {</span><br><span class="line">                        max++;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                maxPoints = Math.max(maxPoints, max);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> maxPoints;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1162-地图分析</title>
      <link href="/2020/03/30/1162-%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/"/>
      <url>/2020/03/30/1162-%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。</p><p>我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。</p><p>如果我们的地图上只有陆地或者海洋，请返回 -1。</p><p>示例 1：</p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200330002822357.png" data-fancybox="group" data-caption="image-20200330002822357" class="fancybox"><img alt="image-20200330002822357" style="zoom:50%;" title="image-20200330002822357" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200330002822357.png" class="lazyload"></a><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,0,1],[0,0,0],[1,0,1]]</span><br><span class="line">输出：2</span><br><span class="line">解释： 海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。</span><br></pre></td></tr></tbody></table></figure></div><p>思路：一开始的思路是，遍历地图找到海洋，然后写个函数求海洋坐标(x,y)距离陆地最近的距离，理论上也能写出来。但是思路不太优雅。</p><p>其他解法：<strong>只要先把所有的陆地都入队，然后从各个陆地同时开始一层一层的向海洋扩散，那么最后扩散到的海洋就是最远的海洋。</strong></p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/367df5172fd16d2637e591f6586d146772758438c66660c86719ffb2d36eb14d-image.png" data-fancybox="group" data-caption="image.png" class="fancybox"><img alt="image.png" title="image.png" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/367df5172fd16d2637e591f6586d146772758438c66660c86719ffb2d36eb14d-image.png" class="lazyload"></a></p><p>很巧妙的是，直接将距离保存到了原矩阵中，同时也避免了再次访问，一举多用。比如上面的数字2，就能说明这个地方距离陆地最近的距离是1（2减一）。体会一下上面的思想。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] dx = {<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>};</span><br><span class="line">        <span class="keyword">int</span>[] dy = {<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">        Queue<<span class="keyword">int</span>[]> queue = <span class="keyword">new</span> ArrayDeque<>();</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 先把所有的陆地都入队。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) {</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] {i, j});</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从各个陆地开始，一圈一圈的遍历海洋，最后遍历到的海洋就是离陆地最远的海洋。</span></span><br><span class="line">        <span class="keyword">boolean</span> hasOcean = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] point = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            point = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 取出队列的元素，将其四周的海洋入队。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">4</span>; i++) {</span><br><span class="line">                <span class="keyword">int</span> newX = x + dx[i];</span><br><span class="line">                <span class="keyword">int</span> newY = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (newX < <span class="number">0</span> || newX >= m || newY < <span class="number">0</span> || newY >= n || grid[newX][newY] != <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">              <span class="comment">//直接将距离保存到了原矩阵中，同时也避免了再次访问</span></span><br><span class="line">                grid[newX][newY] = grid[x][y] + <span class="number">1</span>; </span><br><span class="line">                hasOcean = <span class="keyword">true</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] {newX, newY});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有陆地或者没有海洋，返回-1。</span></span><br><span class="line">        <span class="keyword">if</span> (point == <span class="keyword">null</span> || !hasOcean) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最后一次遍历到的海洋的距离。</span></span><br><span class="line">        <span class="keyword">return</span> grid[point[<span class="number">0</span>]][point[<span class="number">1</span>]] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>145-二叉树的后序遍历</title>
      <link href="/2020/03/29/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2020/03/29/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>二叉树的后序遍历，一直理解的不太透彻。</p><p>方法一：递归</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) { val = x; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    ArrayList<integer> res = <span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList<integer> <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </integer></span>{</span><br><span class="line">        hx(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hx</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        bl(root.left);</span><br><span class="line">        bl(root.right);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>方法二：</p><p>要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。</p><ul><li>如果P不存在左孩子和右孩子，则可以直接访问它</li><li>或者P存在孩子，但是其孩子都已被访问过了，则同样可以直接访问该结点</li><li>若非上述两种情况，则将P的<strong>右孩子和左孩子依次入栈</strong>，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList<integer> <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </integer></span>{</span><br><span class="line">        ArrayList<integer> list = <span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">         </span><br><span class="line">        Stack<treenode> stack = <span class="keyword">new</span> Stack<>();</treenode></span><br><span class="line">  <span class="comment">//保存上一次被访问（也就是被添加到list）结点</span></span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()){</span><br><span class="line">            <span class="comment">// 只看栈顶元素，不弹出</span></span><br><span class="line">            TreeNode cur = stack.peek();</span><br><span class="line">          <span class="comment">//这里的判断很巧妙。正常情况下，入栈顺序是根-右-左。如果遇到特殊情况，就可以直接访问了</span></span><br><span class="line">          <span class="comment">//1.栈顶元素没有孩子结点</span></span><br><span class="line">          <span class="comment">//2.上一次被访问的如果是栈顶的左子结点，说明栈顶元素没有右子结点</span></span><br><span class="line">          <span class="comment">//上一次被访问的如果是栈顶的右子结点，说明找栈顶元素的孩子结点都被访问过了</span></span><br><span class="line">            <span class="keyword">if</span>((cur.left == <span class="keyword">null</span> && cur.right == <span class="keyword">null</span>)</span><br><span class="line">                || (pre != <span class="keyword">null</span> && (pre == cur.left || pre == cur.right))){</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">              <span class="comment">//被访问之后就被出栈了</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                pre = cur;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">              <span class="comment">//注意这里的入栈顺序，先右再左</span></span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)</span><br><span class="line">                    stack.push(cur.right);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)</span><br><span class="line">                    stack.push(cur.left);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>方法三：</p><p>把前序遍历 根 - 左 - 右 改成 根 - 右 - 左，然后reverse。</p><p>方法四：经典解法</p><p>核心思想是用栈做辅助空间，先<strong>从根往左一直入栈，直到为空</strong>，然后判断栈顶元素的右孩子，<strong>如果不为空且未被访问过</strong>，则从它开始重复左孩子入栈的过程；否则说明此时栈顶为要访问的节点（因为左右孩子都是要么为空要么已访问过了）， 出栈然后访问即可，接下来再判断栈顶元素的右孩子…直到栈空。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList<integer> <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </integer></span>{</span><br><span class="line">        TreeNode p = root, r = <span class="keyword">null</span>;        <span class="comment">//P记录当前节点，r用来记录上一次访问的节点</span></span><br><span class="line">        Stack<treenode> s = <span class="keyword">new</span> Stack<treenode>();</treenode></treenode></span><br><span class="line">        ArrayList<integer> list = <span class="keyword">new</span> ArrayList<integer>();</integer></integer></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> || !s.isEmpty()) {</span><br><span class="line">            <span class="keyword">if</span>(p != <span class="keyword">null</span>) {     <span class="comment">//左孩子一直入栈，直到左孩子为空</span></span><br><span class="line">                s.push(p);</span><br><span class="line">                p = p.left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                p = s.peek();</span><br><span class="line">                p = p.right;</span><br><span class="line">                <span class="keyword">if</span>(p != <span class="keyword">null</span> && p != r) {   <span class="comment">//如果栈顶元素的右孩子不为空，且未被访问过</span></span><br><span class="line">                    s.push(p);              <span class="comment">//则右孩子进栈，然后重复左孩子一直进栈直到为空的过程</span></span><br><span class="line">                    p = p.left;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    p = s.pop();            <span class="comment">//否则出栈，访问，r记录刚刚访问的节点</span></span><br><span class="line">                    list.add(p.val);</span><br><span class="line">                    r = p;</span><br><span class="line">                    p = <span class="keyword">null</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>136-只出现一次的数字</title>
      <link href="/2020/03/28/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2020/03/28/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>现在有一个整数类型的数组，数组中素只有一个元素只出现一次，其余的元素都出现两次。</p><p><strong>注意：</strong></p><p>你需要给出一个线性时间复杂度的算法，你能在不使用额外内存空间的情况下解决这个问题么？</p><p>思路：要求线性复杂度就不能用排序了，不能用额外空间就用不了Map了。只能想办法一次遍历解决。想到<strong>异或</strong>，<strong>两个相同数字异或结果是0，一个数和0异或还是它本身</strong>。所以遍历一遍把每个元素异或一下就是答案了。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">int</span> res = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < len; i++)</span><br><span class="line">            res ^= A[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红黑树总结</title>
      <link href="/2020/03/27/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/27/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="什么是红黑树？"><a href="#什么是红黑树？" class="headerlink" title="什么是红黑树？"></a>什么是红黑树？</h4><p>红黑树是一种<strong>自平衡的二叉查找树</strong>，它相对二叉搜索树增加了一个存储位来标识结点颜色。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/1460000014262656.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/1460000014262656.png" class="lazyload"></a></p><h4 id="红黑树有什么用？"><a href="#红黑树有什么用？" class="headerlink" title="红黑树有什么用？"></a>红黑树有什么用？</h4><p>用二叉查找树一般来说可以很快地查找出对应的元素，但是也有特殊情况：</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/1460000014262653.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/1460000014262653.png" class="lazyload"></a></p><p>上面符合二叉树的特性，但是它是线性的，完全没树的用处。树是要<strong>“均衡”</strong>才能将它的优点展示出来。因此，就有了<strong>平衡树</strong>（左右两个子树的高度差的绝对值不超过1）这么一个概念。红黑树就是一种平衡树，它可以<strong>保证二叉树基本符合平衡的结构</strong>，防止极端情况下时间复杂度的退化。</p><p>一个二叉查找树在插入一些结点后，就不能保证树的平衡性了，也就无法保证查找效率。那红黑树又是如何做到的呢？</p><p>红黑树背后的原理是2-3树</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/23-tree-example.png" data-fancybox="group" data-caption="2-3-tree" class="fancybox"><img alt="2-3-tree" title="2-3-tree" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/23-tree-example.png" class="lazyload"></a></p><p>背后原理有些复杂，如果工作中遇到再来深究。</p><h4 id="红黑树的应用"><a href="#红黑树的应用" class="headerlink" title="红黑树的应用"></a>红黑树的应用</h4><ul><li><p>在Java的散列表中，如果桶数满的时候，JDK8会将<strong>链表转成红黑树</strong></p></li><li><p>TreeSet、TreeMap底层都是红黑树来实现的</p></li></ul></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>148-排序链表</title>
      <link href="/2020/03/27/148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/03/27/148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p>示例 1:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4->2->1->3</span><br><span class="line">输出: 1->2->3->4</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -1->5->3->4->0</span><br><span class="line">输出: -1->0->3->4->5</span><br></pre></td></tr></tbody></table></figure></div><p>思路：要求时间空间复杂度分别为O(nlogn)和O(1)，自然想到二分法，从而联想到归并排序。但是这里是对链表进行排序，找中间节点和和合并的时候，需要注意一下。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">       <span class="comment">// 1、递归结束条件</span></span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) {</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2、找到链表中间节点并断开链表 & 递归下探</span></span><br><span class="line">       ListNode midNode = middleNode(head);</span><br><span class="line">       ListNode rightHead = midNode.next;</span><br><span class="line">       midNode.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       ListNode left = sortList(head);</span><br><span class="line">       ListNode right = sortList(rightHead);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3、当前层业务操作（合并有序链表）</span></span><br><span class="line">       <span class="keyword">return</span> mergeTwoLists(left, right);</span><br><span class="line">   }</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//  找到链表中间节点</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) {</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       }</span><br><span class="line">       ListNode slow = head;</span><br><span class="line">       ListNode fast = head.next.next;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (fast != <span class="keyword">null</span> && fast.next != <span class="keyword">null</span>) {</span><br><span class="line">           slow = slow.next;</span><br><span class="line">           fast = fast.next.next;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> slow;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 合并两个有序链表</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>{</span><br><span class="line">       ListNode sentry = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">       ListNode curr = sentry;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(l1 != <span class="keyword">null</span> && l2 != <span class="keyword">null</span>) {</span><br><span class="line">           <span class="keyword">if</span>(l1.val < l2.val) {</span><br><span class="line">               curr.next = l1;</span><br><span class="line">               l1 = l1.next;</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">               curr.next = l2;</span><br><span class="line">               l2 = l2.next;</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">           curr = curr.next;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       curr.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">       <span class="keyword">return</span> sentry.next;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2020/03/27/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/03/27/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>基于分治思想，将待排序的序列分成两个长度相等的子序列，为每一个子序列排序，然后再将他们合并成一个序列。合并两个子序列的过程也就是两路归并。</p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>归并排序是一种<strong>稳定的</strong>排序算法，但是它需要一个与待排序数组一样大的辅助数组空间。由于归并排序每次划分时两个子序列的长度基本一样，所以归并排序最好、最差和平均时间复杂度都是O(nlog2n)。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/70.gif" data-fancybox="group" data-caption="过程" class="fancybox"><img alt="过程" title="过程" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/70.gif" class="lazyload"></a></p><p>将两个排好序的子序列合并为一个序列的方法是：每次都从这两个子序列的最小值中选出一个更小值。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/70-20200327122852779.gif" data-fancybox="group" data-caption="这里写图片描述" class="fancybox"><img alt="这里写图片描述" title="这里写图片描述" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/70-20200327122852779.gif" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span></span>{</span><br><span class="line">  <span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, inr end)</span></span>{</span><br><span class="line"><span class="comment">//当子序列中只有一个元素时结束递归</span></span><br><span class="line"><span class="keyword">if</span>(start < end){</span><br><span class="line"><span class="keyword">int</span> mid = (start + end)/<span class="number">2</span>;<span class="comment">//划分子序列</span></span><br><span class="line">mergeSort(a, start, mid);<span class="comment">//对左侧子序列进行排序</span></span><br><span class="line">mergeSort(a, mid+<span class="number">1</span>, end);<span class="comment">//对右侧子序列进行排序</span></span><br><span class="line">merge(a, start, mid, end);<span class="comment">//合并</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  <span class="comment">//合并</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line"><span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];<span class="comment">//辅助数组</span></span><br><span class="line"><span class="keyword">int</span> p1 = left, p2 = mid + <span class="number">1</span>, k = left;<span class="comment">//p1,p2是检测指针，k是存放指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(p1 <= mid && p2 <= right){</span><br><span class="line"><span class="keyword">if</span>(a[p1] <= a[p2])</span><br><span class="line">tmp[k++] = a[p1++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tmp[k++] = a[p2++];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果第一个序列未检测完，直接将后面所有元素加到合并的序列中</span></span><br><span class="line"><span class="keyword">while</span>(p1 <= mid)</span><br><span class="line">tmp[k++] = a[p1++];</span><br><span class="line"><span class="keyword">while</span>(p2 <= right)</span><br><span class="line">tmp[k++] = a[p2++];</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制回原数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = left; i <= right; i++)</span><br><span class="line">a[i] = tmp[i];</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客迁移记录</title>
      <link href="/2020/03/26/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/03/26/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="GitHubPages被中间人攻击了"><a href="#GitHubPages被中间人攻击了" class="headerlink" title="GitHubPages被中间人攻击了"></a>GitHubPages被中间人攻击了</h4><p>今天上传文章后打开博客，发现无法访问了</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200326181436663.png" data-fancybox="group" data-caption="image-20200326181436663" class="fancybox"><img alt="image-20200326181436663" title="image-20200326181436663" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200326181436663.png" class="lazyload"></a></p><p>不知道什么原因，上午还好好的，下午就这样了。</p><p>找了很多资料，怀疑是GitHubPages给自定义域名颁发的证书到期了，然后我在阿里云申请了一个免费的SSL证书，绑定审核之后还是无法访问。</p><p>然后我搜了一下别人有没有类似情况，才发现</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200326181826031.png" data-fancybox="group" data-caption="image-20200326181826031" class="fancybox"><img alt="image-20200326181826031" title="image-20200326181826031" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200326181826031.png" class="lazyload"></a></p><p>而且维基百科也已经更新了这次事件</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200326181943462.png" data-fancybox="group" data-caption="image-20200326181943462" class="fancybox"><img alt="image-20200326181943462" title="image-20200326181943462" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200326181943462.png" class="lazyload"></a></p><p>只能等官方结果了，不知道什么时候能恢复。</p><h4 id="七牛云图床迁移到阿里云OSS"><a href="#七牛云图床迁移到阿里云OSS" class="headerlink" title="七牛云图床迁移到阿里云OSS"></a>七牛云图床迁移到阿里云OSS</h4><p>今天才发现，七牛云的图床分配的是测试域名，只有30天有效期，马上就到期了。要么买个阿里云服务器备案，或者借别人一个二级域名，但是都很麻烦且不长久。然后发现阿里云OSS，很便宜，而且不存在域名失效的问题。一开始想用阿里云官方的在线迁移服务（公测中需要申请），等了半天也没审核通过。想到其实直接从七牛云上批量下载下来，再批量上传就行，也就四十多张图片，所以用qshell把七牛云的图片批量下载到了本地。</p><p>接下来就是替换原来博客中的图片外链。本来想写个Java程序处理一下，但是对IO流操作不熟悉，没搞出来，思路很简单。最后直接在sublime里全局替换，也挺快的。</p><h4 id="CodingPages和GitHubPages双托管"><a href="#CodingPages和GitHubPages双托管" class="headerlink" title="CodingPages和GitHubPages双托管"></a>CodingPages和GitHubPages双托管</h4><p>配置完之后，每次部署都会同时上传到GitHub和Coding。域名解析作了修改，国外访问转向Github，国内访问转向Coding，现在的博客访问速度比之前快了很多，ping在90ms左右，之前是200以上。Coding免费颁发SLL证书，但是每3个月就会到期，需要重新申请。为了到时候重新申请方便，就把GitHubPages的解析停了，因为也基本没有国外访问的。之后如果想访问GitHub上的Pages，就使用原生的yunlong0928.github.io</p></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列总结</title>
      <link href="/2020/03/26/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/26/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="什么是消息队列？"><a href="#什么是消息队列？" class="headerlink" title="什么是消息队列？"></a>什么是消息队列？</h4><p>可以简单的理解为<strong>把要传输的数据放在队列中</strong>。把数据放到消息队列叫做<strong>生产者</strong>，从消息队列里边取数据叫做<strong>消费者</strong>。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018845304.png" data-fancybox="group" data-caption="图片来源" class="fancybox"><img alt="图片来源" title="图片来源" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018845304.png" class="lazyload"></a></p><h4 id="为什么要用消息队列？有什么好处？"><a href="#为什么要用消息队列？有什么好处？" class="headerlink" title="为什么要用消息队列？有什么好处？"></a>为什么要用消息队列？有什么好处？</h4><p>先假设一个场景：系统A做的是<strong>主要的业务</strong>，而系统B、C、D是<strong>非主要</strong>的业务。比如系统A处理的是<strong>订单下单</strong>，而系统B是订单下单成功了，那发送一条短信告诉具体的用户此订单已成功，而系统C和系统D也是处理一些小事而已。</p><ul><li><p>解耦。生产者（系统A）只负责把数据写到队列中，谁想要或不想要这个数据(消息)，生产者一点也不用关心。这样生产者（系统A）就与其他消费者（系统BCD）解耦了。</p></li><li><p>异步。生产者把数据写到消息队列中，就可以直接返回了，其他操作异步处理，无需等待</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018845311.jpeg" data-fancybox="group" data-caption="此时才用了100ms" class="fancybox"><img alt="此时才用了100ms" title="此时才用了100ms" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018845311.jpeg" class="lazyload"></a></p></li><li><p>削峰/限流。如下图，系统B和系统C<strong>根据自己的能够处理的请求数去消息队列中拿数据</strong>，这样即便有每秒有8000个请求，那只是把请求放在消息队列中，去拿消息队列的消息<strong>由系统自己去控制</strong>，这样就不会把整个系统给搞崩。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018845313.jpeg" data-fancybox="group" data-caption="写到消息队列中，系统从消息队列中拿到请求" class="fancybox"><img alt="写到消息队列中，系统从消息队列中拿到请求" title="写到消息队列中，系统从消息队列中拿到请求" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018845313.jpeg" class="lazyload"></a></p></li></ul><h4 id="使用消息队列有什么问题？为什么不能用JDK实现的队列而要用消息队列中间件？"><a href="#使用消息队列有什么问题？为什么不能用JDK实现的队列而要用消息队列中间件？" class="headerlink" title="使用消息队列有什么问题？为什么不能用JDK实现的队列而要用消息队列中间件？"></a>使用消息队列有什么问题？为什么不能用JDK实现的队列而要用消息队列中间件？</h4><ul><li><p>高可用。消息队列<strong>肯定不能是单机</strong>的。如果是单机的消息队列，万一这台机器挂了，那整个系统几乎就是不可用了。所以，当我们项目中使用消息队列，都是得<strong>集群/分布式</strong>的。要做集群/分布式就必然希望该消息队列能够提供<strong>现成</strong>的支持，而不是自己写代码手动去实现。</p></li><li><p>数据丢失问题。我们将数据写到消息队列上，系统B和C还没来得及取消息队列的数据，就挂掉了。<strong>如果没有做任何的措施，我们的数据就丢了</strong>。</p></li></ul><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018845315.jpeg" data-fancybox="group" data-caption="数据丢失问题" class="fancybox"><img alt="数据丢失问题" title="数据丢失问题" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018845315.jpeg" class="lazyload"></a>我们都知道Redis可以将数据持久化磁盘上，万一Redis挂了，还能从磁盘从将数据恢复过来。同样地，消息队列中的数据也需要存在别的地方，这样才尽可能减少数据的丢失。那存在哪呢？磁盘？数据库？Redis？分布式文件系统？同步存储还是异步存储？</p><ul><li><p>消费者怎么得到消息队列的数据？有两种办法</p><ul><li>生产者将数据放到消息队列中，消息队列有数据了，<strong>主动叫</strong>消费者去拿(俗称push)。</li><li>消费者不断去<strong>轮训</strong>消息队列，看看有没有新的数据，如果有就消费(俗称pull)</li></ul></li><li><p>其他问题。消息重复消费了怎么办啊？想保证消息是<strong>绝对</strong>有顺序的怎么做？虽然消息队列给我们带来了那么多的好处，但同时我们发现引入消息队列也会<strong>提高系统的复杂性</strong>。市面上现在已经有不少消息队列轮子了，每种消息队列都有自己的特点，<strong>选取哪种MQ还得好好斟酌</strong>。</p></li></ul></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式与集群</title>
      <link href="/2020/03/26/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E9%9B%86%E7%BE%A4/"/>
      <url>/2020/03/26/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="什么是集群？"><a href="#什么是集群？" class="headerlink" title="什么是集群？"></a>什么是集群？</h4><ul><li>多台计算机完成<strong>同样的</strong>工作，对外可以被看作一台计算机。每个节点都提供相同的服务，那么这样系统的处理能力就相当于提升了好几倍（有几个节点就相当于提升了这么多倍）。</li><li>用户的请求究竟由哪个节点来处理呢？最好能够让此时负载较小的节点来处理，一般需要在所有节点之前增加一个“调度者”的角色，用户的所有请求都先交给它，然后它根据当前所有节点的负载情况，决定将这个请求交给哪个节点处理。这个“调度者”就是——负载均衡服务器</li><li>从单机结构到集群结构，你的代码基本无需要作任何修改，你要做的仅仅是多部署几台服务器，每台服务器部署相同的代码就可以</li></ul><h4 id="什么是分布式？"><a href="#什么是分布式？" class="headerlink" title="什么是分布式？"></a>什么是分布式？</h4><ul><li>一个业务分拆多个子业务，部署在不同的服务器上(不同的服务器运行不同的代码，为了同一个目的)</li><li>可以将每个模块抽取独立出来，访问量大的模块用好的服务器，访问少的模块用差的服务器。这样的好处是：一、资源合理利用了。二、耦合度降低了：每个模块独立出来，各干各的事，便于扩展</li><li>假设需要开发一个在线商城。按照微服务的思想，我们需要按照功能模块拆分成多个独立的服务，如：用户服务、产品服务、订单服务、后台管理服务、数据分析服务等等。这一个个服务都是一个个独立的项目，可以独立运行。如果服务之间有依赖关系，那么通过RPC方式调用。</li></ul><h5 id="分布式和集群的区别？"><a href="#分布式和集群的区别？" class="headerlink" title="分布式和集群的区别？"></a>分布式和集群的区别？</h5><ul><li><strong>分布式不一定就是不同的组件，同一个组件也可以</strong>，关键在于是否通过交换信息的方式进行协作。分布式是指通过网络连接的多个组件，通过交换信息协作而形成的系统。而集群，是指同一种组件的多个实例，形成的逻辑上的整体。</li><li><strong>分布式系统也可以是一个集群</strong>。例子就是zookeeper等，它的特征是服务之间会互相通信协作。</li><li><strong>分布式系统也可以不是集群</strong>。就是多个不同组件构成的系统</li><li><strong>集群也可以不是分布式系统</strong>。比如多个经过负载均衡的HTTP服务器，它们之间不会互相通信，如果不带上负载均衡的部分的话，一般不叫做分布式系统。</li></ul><h5 id="分布式-微服务-SOA，这三个概念其实差不多"><a href="#分布式-微服务-SOA，这三个概念其实差不多" class="headerlink" title="分布式/微服务/SOA，这三个概念其实差不多"></a>分布式/微服务/SOA，这三个概念其实差不多</h5><ul><li><p><strong>分布式</strong>：不同模块部署在不同服务器上<br>作用：分布式解决网站高并发带来问题</p></li><li><p><strong>SOA</strong>：业务系统分解为多个组件，让每个组件都独立提供离散，自治，可复用的服务能力，通过服务的组合和编排来实现上层的业务流程<br>作用：简化维护,降低整体风险,伸缩灵活</p></li><li><p><strong>微服务</strong>：架构设计概念,各服务间隔离（分布式也是隔离）,自治（分布式依赖整体组合）其它特性(单一职责,边界,异步通信,独立部署)是分布式概念的跟严格执行SOA到微服务架构的演进过程<br>作用：各服务可独立应用，组合服务也可系统应用</p></li></ul><h4 id="CAP理论："><a href="#CAP理论：" class="headerlink" title="CAP理论："></a>CAP理论：</h4><ul><li>数据一致性。<strong>所有</strong>节点拥有数据的最新版本</li><li>可用性。数据具备高可用性</li><li>分区容错性。<strong>容忍网络出现分区</strong>，分区之间网络不可达</li></ul><p>分布式系统节点之间的通信是通过网络来进行的。<strong>只要是分布式系统</strong>，那很有可能会出现一种情况：因为一些<strong>故障</strong>，使得有些<strong>节点之间不连通</strong>了，整个网络就分成了<strong>几块区域</strong>。所以<strong>CAP是无法完全兼顾的</strong>。</p><h4 id="为什么需要SpringCloud？"><a href="#为什么需要SpringCloud？" class="headerlink" title="为什么需要SpringCloud？"></a>为什么需要SpringCloud？</h4><p>一个大项目拆分出多个模块以后，会出现各种各样的问题，SpringCloud提供了一整套解决方案</p><p>SpringCloud的<strong>基础功能</strong>：</p><ul><li>服务治理： Spring Cloud Eureka</li><li>客户端负载均衡： Spring Cloud Ribbon</li><li>服务容错保护： Spring Cloud Hystrix</li><li>声明式服务调用： Spring Cloud Feign</li><li>API网关服务：Spring Cloud Zuul</li><li>分布式配置中心： Spring Cloud Config</li></ul><p>SpringCloud的高级功能：</p><ul><li>消息总线： Spring Cloud Bus</li><li>消息驱动的微服务： Spring Cloud Stream</li><li>分布式服务跟踪： Spring Cloud Sleuth</li></ul><h5 id="Eureka是做什么的？为什么需要Eureka？"><a href="#Eureka是做什么的？为什么需要Eureka？" class="headerlink" title="Eureka是做什么的？为什么需要Eureka？"></a>Eureka是做什么的？为什么需要Eureka？</h5><p>分布式的子系统之间不在同一个环境下，需要远程调用，比如A服务调用B服务，代码里要<strong>显式地通过IP地址调用</strong>：<code>http://123.123.123.123:8888/user/1</code></p><p>B服务又可能需要调用C服务。也就是各个服务之间有耦合。如果B服务的IP地址变了，其他服务就得手动更新。服务多的情况下，维护这些配置就变的很麻烦。</p><p>为了解决微服务架构中的<strong>服务实例维护问题(ip地址)</strong>，就需要Eureka了。</p><h5 id="Eureka是怎么解决这个问题的？"><a href="#Eureka是怎么解决这个问题的？" class="headerlink" title="Eureka是怎么解决这个问题的？"></a>Eureka是怎么解决这个问题的？</h5><p>我们现在的问题是：现在有A、B、C、D四个服务，它们之间会互相调用(而且IP地址很可能会发生变化)，一旦某个服务的IP地址变了，那服务中的代码要跟着变，手动维护这些静态配置(IP)非常麻烦。</p><p>Eureka会创建一个E服务，将A、B、C、D四个服务的信息都<strong>注册</strong>到E服务上，E服务维护这些已经注册进来的信息</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/view.png" data-fancybox="group" data-caption="preview" class="fancybox"><img alt="preview" title="preview" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/view.png" class="lazyload"></a></p><p>A、B、C、D四个服务都可以<strong>拿到</strong>Eureka(服务E)那份<strong>注册清单</strong>。A、B、C、D四个服务互相调用不再通过具体的IP地址，而是<strong>通过服务名来调用</strong>。</p><p>Eureka的细节：</p><p>Eureka专门用于给其他服务注册的称为Eureka Server(服务注册中心)，其余注册到Eureka Server的服务称为Eureka Client。Eureka Client<strong>分为服务提供者和服务消费者</strong>。但很可能，某服务<strong>既是服务提供者又是服务消费者</strong>。单纯的服务消费者可以不在Eureka-Server注册。</p><p>Eureka的治理机制：</p><ul><li><p>服务提供者</p><ul><li><strong>服务注册：</strong>启动的时候会通过发送REST请求的方式将<strong>自己注册到Eureka Server上</strong>，同时带上了自身服务的一些元数据信息。</li><li><strong>服务续约：</strong>在注册完服务之后，<strong>服务提供者会维护一个心跳</strong>用来持续告诉Eureka Server: “我还活着 ” 。</li><li><strong>服务下线：</strong>当服务实例进行正常的关闭操作时，它会<strong>触发一个服务下线的REST请求</strong>给Eureka Server, 告诉服务注册中心：“我要下线了 ”。</li></ul></li><li><p>服务消费者</p><ul><li><strong>获取服务：</strong>当我们<strong>启动服务消费者</strong>的时候，它会发送一个REST请求给服务注册中心，来获取上面注册的服务清单</li><li><strong>服务调用：</strong>服务消费者在获取服务清单后，通过<strong>服务名</strong>可以获得具体提供服务的实例名和该实例的元数据信息。在进行服务调用的时候，<strong>优先访问同处一个Zone中的服务提供方</strong>。</li></ul></li><li><p>Eureka Server(服务注册中心)</p><ul><li><strong>失效剔除：</strong>默认每隔一段时间（默认为60秒） 将当前清单中超时（默认为90秒）<strong>没有续约的服务剔除出去</strong>。</li><li><strong>自我保护：</strong>。EurekaServer 在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%(通常由于网络不稳定导致)。 Eureka Server会将当前的<strong>实例注册信息保护起来</strong>， 让这些实例不会过期，尽可能<strong>保护这些注册信息</strong>。</li></ul></li></ul><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000016157677.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000016157677.png" class="lazyload"></a></p><h5 id="Ribbon是做什么的？"><a href="#Ribbon是做什么的？" class="headerlink" title="Ribbon是做什么的？"></a>Ribbon是做什么的？</h5><p>为了实现服务的<strong>高可用</strong>，我们可以将<strong>服务提供者集群</strong>。集群就要用到负载均衡来合理分担用户的请求。</p><p>负载均衡又区分了两种类型：</p><ul><li>客户端负载均衡(Ribbon)<ul><li>服务实例的<strong>清单在客户端</strong>，客户端进行负载均衡算法分配。</li><li>(从上面的知识我们已经知道了：客户端可以从Eureka Server中得到一份服务清单，在发送请求时通过负载均衡算法，<strong>在多个服务器之间选择一个进行访问</strong>)</li></ul></li><li>服务端负载均衡(Nginx)<ul><li>服务实例的<strong>清单在服务端</strong>，服务器进行负载均衡算法分配</li></ul></li></ul><p>SpringCloud也支持负载均衡功能，只不过它是<strong>客户端的负载均衡</strong>，这个功能实现就是Ribbon！</p><h5 id="Hystrix是做什么的？"><a href="#Hystrix是做什么的？" class="headerlink" title="Hystrix是做什么的？"></a>Hystrix是做什么的？</h5><p>如果我们在<strong>调用多个远程服务时，某个服务出现延迟</strong>，在<strong>高并发</strong>的情况下，由于单个服务的延迟，可能导致<strong>所有的请求都处于延迟状态</strong>，甚至在几秒钟就使服务处于负载饱和的状态，资源耗尽，直到不可用，最终导致这个分布式系统都不可用，这就是“雪崩”。Spring Cloud Hystrix实现了<strong>断路器、线程隔离</strong>等一系列服务保护功能，提高容错。</p><h5 id="Feign是做什么的？"><a href="#Feign是做什么的？" class="headerlink" title="Feign是做什么的？"></a>Feign是做什么的？</h5><p>Feign整合了Ribbon和Hystrix，而且还提供了<strong>声明式的服务调用</strong>(不再通过RestTemplate)，达到使用HTTP请求远程服务时能与调用本地方法一样的编码体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求。</p><p>根据上面的内容，我们设计出来的架构可能是这样</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000016157688.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000016157688.png" class="lazyload"></a></p><p>SpringCloud的其他基础功能还有Zuul和Config，但是没有实践过，没有具体场景，不是很好理解，等到以后用到了再研究吧</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 集群 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis总结</title>
      <link href="/2020/03/26/Redis%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/26/Redis%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h4><p>Redis是一个开源的，<strong>基于内存的数据结构存储</strong>，可用作于数据库、<strong>缓存</strong>、消息中间件。从经验上来看，常用作缓存</p><h4 id="为什么要用Redis？"><a href="#为什么要用Redis？" class="headerlink" title="为什么要用Redis？"></a>为什么要用Redis？</h4><h5 id="为什么要用缓存？"><a href="#为什么要用缓存？" class="headerlink" title="为什么要用缓存？"></a>为什么要用缓存？</h5><p>如果网站出现了性能问题(访问时间慢)，一般是由于<strong>数据库撑不住了</strong>。因为一般数据库的读写都是要经过<strong>磁盘</strong>的，而磁盘的速度相对内存来说是很慢的。有了缓存就不用每次读取的时候都查一次数据库。就想CPU的一级缓存，二级缓存一样，思想是一样的。</p><h5 id="为什么不能用Map做缓存？"><a href="#为什么不能用Map做缓存？" class="headerlink" title="为什么不能用Map做缓存？"></a>为什么不能用Map做缓存？</h5><p>如果自己设计一个缓存，可能会这样设计</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get value from cache</span></span><br><span class="line">String value = map.get(<span class="string">"someKey"</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == value) {</span><br><span class="line">  <span class="comment">// get value from DataBase</span></span><br><span class="line">  value = queryValueFromDB(<span class="string">"someKey"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>但是Java自带的map或者guava是本地缓存，而且生命周期会随着JVM的销毁而结束。redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据。此外还有这些原因：</p><ul><li>Redis 可以用几十 G 内存来做缓存，Map 不行，一般 JVM 也就分几个 G 数据就够大。</li><li>Redis 的缓存可以持久化，Map 是内存对象，程序一重启数据就没了。</li><li>dis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象。</li><li>Redis 缓存有过期机制，Map 本身无此功能。</li><li>Redis 有丰富的 API，Map 就简单太多了</li></ul><h4 id="什么时候用Redis集群？"><a href="#什么时候用Redis集群？" class="headerlink" title="什么时候用Redis集群？"></a>什么时候用Redis集群？</h4><p>用一台Redis缓存服务器可能会出现两个问题：</p><ul><li><strong>Redis内存不足</strong>：随着使用Redis的客户端越来越多，Redis上的缓存数据也越来越大，而一台机器的内存毕竟是有限的，放不了那么多数据。</li><li><strong>Redis吞吐量低</strong>：客户端变多了，可Redis还是只有一台，而且Redis是单线程的。这就好比我开了一家饭店，一开始每天只有100位客人，我雇一位服务员就可以，后来生意好了，每天有1000位客人，可我还是只雇一位服务员。<strong>一台机器的带宽和处理器都是有限的</strong>，Redis自然会忙不过来，吞吐量已经不足以支撑越来越庞大的系统</li></ul><p>所以这时候，就可以使用Redis集群。客户端的请求会通过负载均衡算法（通常是一致性Hash），分散到各个Redis服务器上。</p><h4 id="Redis集群存在的问题"><a href="#Redis集群存在的问题" class="headerlink" title="Redis集群存在的问题"></a>Redis集群存在的问题</h4><ul><li><strong>数据可用性差</strong>：如果其中一台Redis挂了，那么上面全部的缓存数据都会丢失，导致原来可以从缓存中获取的请求，都去访问数据库了，数据库压力陡增。</li><li><strong>数据查询缓慢</strong>：监测发现，每天有一段时间，Redis 1的访问量非常高，而且大多数请求都是去查一个相同的缓存数据，导致Redis 1非常忙碌，吞吐量不足以支撑这个高的查询负载。</li></ul><p>其实就是主从复制问题。解决办法可以是数据库里头经常用到的<strong>Master-Slave模式</strong>，给每一台Redis都加上一台Slave。</p><h4 id="Redis还有哪些问题？"><a href="#Redis还有哪些问题？" class="headerlink" title="Redis还有哪些问题？"></a>Redis还有哪些问题？</h4><ul><li><strong>数据结构。</strong>Redis不仅仅是数据存储器，而是数据结构存储器。Redis支持客户端直接往里面塞各种类型的数据结构，比如String、List、Set、SortedSet、Map等等。</li><li><strong>剔除策略。</strong>缓存数据不能无限增长，总得剔除掉一些数据，好让新的缓存数据放进来，这就需要LRU算法了</li><li><strong>负载均衡</strong>。用到了集群，就免不了需要用到负载均衡，用什么负载均衡算法？在哪里使用负载均衡？</li><li><strong>Presharding。</strong>如果一开始只有三台Redis服务器，后来发现需要加多一台才能满足业务需要，要怎么办？</li><li><strong>数据持久化。</strong>如果机器突然全部断电了，缓存数据还能恢复吗？可以的</li><li><strong>数据同步。</strong></li></ul><p>如果不想安装环境，可以在这里<a href="http://try.redis.io/" target="_blank" rel="noopener">TryRedis</a>熟悉一下Redis的操作和指令</p></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper总结</title>
      <link href="/2020/03/26/ZooKeeper%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/26/ZooKeeper%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="什么是Zookeeper？可以用来做什么？"><a href="#什么是Zookeeper？可以用来做什么？" class="headerlink" title="什么是Zookeeper？可以用来做什么？"></a>什么是Zookeeper？可以用来做什么？</h4><p>使用分布式系统无法避免对节点管理的问题(需要<strong>实时感知节点的状态</strong>、对<strong>节点进行统一管理</strong>等等)，而由于这些问题处理起来可能相对麻烦和提高了系统的复杂性，ZooKeeper中间件就是用来解决分布式系统中的这些通用基础问题的。</p><p>ZooKeeper的主要功能有：统一配置管理、统一命名服务、分布式锁、集群管理。</p><h4 id="Zookeeper自身的结构和机制"><a href="#Zookeeper自身的结构和机制" class="headerlink" title="Zookeeper自身的结构和机制"></a>Zookeeper自身的结构和机制</h4><p>ZooKeeper的<strong>数据结构</strong>，可以看做是一颗<strong>树</strong>，每个节点叫做<strong>ZNode</strong>。每一个节点可以通过<strong>路径</strong>来标识。</p><p>Znode分为<strong>两种</strong>类型：</p><ul><li><strong>短暂/临时(Ephemeral)</strong>：当客户端和服务端断开连接后，所创建的Znode(节点)<strong>会自动删除</strong></li><li><strong>持久(Persistent)</strong>：当客户端和服务端断开连接后，所创建的Znode(节点)<strong>不会删除</strong></li></ul><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876288.jpeg" data-fancybox="group" data-caption="Znode和Znode的类型" class="fancybox"><img alt="Znode和Znode的类型" title="Znode和Znode的类型" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876288.jpeg" class="lazyload"></a></p><p>ZooKeeper和Redis一样，也是C/S结构(分成客户端和服务端)</p><p>另外一个是<strong>监听器</strong></p><p><strong>常见</strong>的监听场景有以下两项：</p><ul><li>监听Znode节点的<strong>数据变化</strong></li><li>监听子节点的<strong>增减变化</strong></li></ul><p>通过<strong>监听+Znode节点(持久/短暂[临时])</strong>，ZooKeeper就能实现上面那么多功能了。</p><h4 id="具体怎么做？"><a href="#具体怎么做？" class="headerlink" title="具体怎么做？"></a>具体怎么做？</h4><h5 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h5><p>我们可以将配置文件放在ZooKeeper的Znode节点中，其他系统监听着这个Znode节点有无变更，如果变更了，<strong>及时</strong>响应。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876292.jpeg" data-fancybox="group" data-caption="系统A、B、C监听着ZooKeeper的节点，一旦common.yml内容有变化，及时响应" class="fancybox"><img alt="系统A、B、C监听着ZooKeeper的节点，一旦common.yml内容有变化，及时响应" title="系统A、B、C监听着ZooKeeper的节点，一旦common.yml内容有变化，及时响应" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876292.jpeg" class="lazyload"></a></p><h5 id="统一命名管理"><a href="#统一命名管理" class="headerlink" title="统一命名管理"></a>统一命名管理</h5><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876293.jpeg" data-fancybox="group" data-caption="通过名称去访问旗下的IP" class="fancybox"><img alt="通过名称去访问旗下的IP" title="通过名称去访问旗下的IP" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876293.jpeg" class="lazyload"></a></p><h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><p>比如系统A，B，C都去访问/locks节点</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876294.jpeg" data-fancybox="group" data-caption="系统A、B、C都去访问locks节点" class="fancybox"><img alt="系统A、B、C都去访问locks节点" title="系统A、B、C都去访问locks节点" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876294.jpeg" class="lazyload"></a></p><p>访问的时候会创建<strong>带顺序号的临时/短暂</strong>(<code>EPHEMERAL_SEQUENTIAL</code>)节点，比如，系统A创建了<code>id_000000</code>节点，系统B创建了<code>id_000002</code>节点，系统C创建了<code>id_000001</code>节点。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876295.jpeg" data-fancybox="group" data-caption="创建出临时带顺序号的节点" class="fancybox"><img alt="创建出临时带顺序号的节点" title="创建出临时带顺序号的节点" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876295.jpeg" class="lazyload"></a></p><p>接着，拿到/locks节点下的所有子节点(id_000000,id_000001,id_000002)，<strong>判断自己创建的是不是最小的那个节点</strong></p><p>如果是，则拿到锁（执行完操作后，把创建的节点给删掉，也就是释放锁）</p><p>如果不是，则监听比自己要小1的节点变化</p><p>例如：</p><ul><li>系统A拿到/locks节点下的所有子节点，经过比较，发现自己(<code>id_000000</code>)，是所有子节点最小的。所以得到锁</li><li>系统B拿到/locks节点下的所有子节点，经过比较，发现自己(<code>id_000002</code>)，不是所有子节点最小的。所以监听比自己小1的节点<code>id_000001</code>的状态</li><li>系统C拿到<code>/locks</code>节点下的所有子节点，经过比较，发现自己(<code>id_000001</code>)，不是所有子节点最小的。所以监听比自己小1的节点<code>id_000000</code>的状态</li><li>……</li><li>等到系统A执行完操作以后，将自己创建的节点删除(<code>id_000000</code>)。通过监听，系统C发现<code>id_000000</code>节点已经删除了，发现自己已经是最小的节点了，于是顺利拿到锁</li><li>….系统B如上</li></ul><h5 id="集群状态"><a href="#集群状态" class="headerlink" title="集群状态"></a>集群状态</h5><p>还是以三个系统A、B、C为例，在ZooKeeper中创建<strong>临时节点</strong>即可</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876296.jpeg" data-fancybox="group" data-caption="各维护一个临时节点" class="fancybox"><img alt="各维护一个临时节点" title="各维护一个临时节点" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876296.jpeg" class="lazyload"></a></p><p>只要系统A挂了，那<code>/groupMember/A</code>这个节点就会删除，通过<strong>监听</strong><code>groupMember</code>下的子节点，系统B和C就能够感知到系统A已经挂了。(新增也是同理)</p></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架总结</title>
      <link href="/2020/03/26/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/26/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>集合框架分两类，继承Collection接口的，和继承Map接口的</p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/WX20200328-170608@2x.png" data-fancybox="group" data-caption="WX20200328-170608@2x" class="fancybox"><img alt="WX20200328-170608@2x" style="zoom:50%;" title="WX20200328-170608@2x" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/WX20200328-170608@2x.png" class="lazyload"></a><h2 id="Collection介绍"><a href="#Collection介绍" class="headerlink" title="Collection介绍"></a>Collection介绍</h2><h3 id="为什么需要Collection？"><a href="#为什么需要Collection？" class="headerlink" title="为什么需要Collection？"></a>为什么需要Collection？</h3><p>存储多个对象。常⽤的容器有StringBuffer,数组，虽然也有对象数组，但是数组的⻓度是不可变的。</p><h3 id="数组和集合的区别"><a href="#数组和集合的区别" class="headerlink" title="数组和集合的区别"></a>数组和集合的区别</h3><ul><li>⻓度的区别。数组的⻓度固定，集合的⻓度可变</li><li>内容不同。数组存储的是同⼀种类型的元素，集合可以存储不同类型的元素(但是⼀般我们不这样做)</li><li>元素的数据类型。数组可以存储基本数据类型,也可以存储引⽤类型。集合只能存储引⽤类型<strong>(</strong>如果是简单的<strong>int</strong>，它会⾃动装箱成<strong>Integer)</strong></li></ul><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200328165706553.png" data-fancybox="group" data-caption="image-20200328165706553" class="fancybox"><img alt="image-20200328165706553" style="zoom: 50%;" title="image-20200328165706553" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200328165706553.png" class="lazyload"></a><p>集合框架有一些基础的通用功能，比如增加删除等，Collection就是其他数据结构都需要继承的接口</p><h3 id="Collection的基础功能"><a href="#Collection的基础功能" class="headerlink" title="Collection的基础功能"></a>Collection的基础功能</h3><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200328170011206.png" data-fancybox="group" data-caption="image-20200328170011206" class="fancybox"><img alt="image-20200328170011206" style="zoom:50%;" title="image-20200328170011206" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200328170011206.png" class="lazyload"></a><h3 id="迭代器Iterator介绍"><a href="#迭代器Iterator介绍" class="headerlink" title="迭代器Iterator介绍"></a>迭代器Iterator介绍</h3><p>Collection的源码中继承了Iterable，有iterator()这个⽅法，作用是遍历元素。又因为不同的数据结构遍历的方式可能不同，所以Iterator接口一般在实现类中实现，比如ArrayList，LinkedList等</p><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><ul><li>ArrayList 底层数据结构是数组。线程不安全 </li><li>LinkedList 底层数据结构是链表。线程不安全</li><li>Vector 底层数据结构是数组。线程安全</li></ul><h3 id="ArrayList解析"><a href="#ArrayList解析" class="headerlink" title="ArrayList解析"></a>ArrayList解析</h3><p>ArrayList底层是一个数组，可以扩容，所以能实现动态增长。</p><ul><li>构造方法。如果指定了容量，数组就初始化成对应的容量</li><li><strong>add方法</strong><ul><li>add(E e) ：⾸先去检查⼀下数组的容量是否⾜够，如果足够就直接添加，如果不够就扩容到原来的1.5倍。第⼀次扩容后，如果容量还是⼩于minCapacity（数组所需要的最小容量），就将容量扩充为minCapacity。</li><li>add(int index, E element) ： 检查⻆标，然后检查空间，如果有需要进⾏扩容。最后插入元素</li></ul></li><li>get方法。检查角标是否在正常范围，返回元素</li><li>set方法。检查角标，替代元素，返回旧值</li><li><strong>remove方法：</strong> 检查⻆标，删除元素，计算出需要移动的元素个数并移动，设置为null，让Gc回收</li></ul><p>细节补充：</p><ul><li><p>ArrayList是基于动态数组实现的，在增（扩容时调用Arrays.copyof）删（调用System.arraycopy）的时候，需要对数组拷⻉复制。</p></li><li><p>ArrayList的默认初始化容量是<strong>10</strong>，每次扩容时候增加原先容量的⼀半，也就是变为原来的<strong>1.5</strong>倍</p></li><li><p>删除元素时不会减少容量，若希望减少容量则调⽤<strong>trimToSize()</strong></p></li><li><p>它不是线程安全的。它能存放null值。</p></li></ul><h3 id="Vector与ArrayList的区别"><a href="#Vector与ArrayList的区别" class="headerlink" title="Vector与ArrayList的区别"></a>Vector与ArrayList的区别</h3><ul><li>Vector是jdk1.2的类了，⽐较⽼旧的⼀个集合类。</li><li>Vector底层也是数组，与ArrayList最⼤的区别就是：<strong>同步(线程安全)</strong>。方法上加了synchronized</li><li>ArrayList在底层数组不够⽤时在原来的基础上扩展<strong>0.5</strong>倍，<strong>Vector</strong>是扩展<strong>1</strong>倍。</li></ul><h3 id="LinkedList解析"><a href="#LinkedList解析" class="headerlink" title="LinkedList解析"></a>LinkedList解析</h3><p>LinkedList底层是<strong>双向链表</strong>，实现了<strong>Deque</strong>接⼝，可以像操作队列和栈⼀样操作LinkedList</p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200402205602940.png" data-fancybox="group" data-caption="image-20200402205602940" class="fancybox"><img alt="image-20200402205602940" style="zoom:50%;" title="image-20200402205602940" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200402205602940.png" class="lazyload"></a><ul><li><p>构造方法。无参数或者传入一个Collection的集合</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200402205820745.png" data-fancybox="group" data-caption="image-20200402205820745" class="fancybox"><img alt="image-20200402205820745" title="image-20200402205820745" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200402205820745.png" class="lazyload"></a></p></li><li><p>add方法。实际上就是往链表最后添加元素</p></li><li><p>remove方法。参数是一个Objec，遍历时用equals方法找到这个元素，然后执行下面的操作</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200402210142936.png" data-fancybox="group" data-caption="image-20200402210142936" class="fancybox"><img alt="image-20200402210142936" title="image-20200402210142936" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200402210142936.png" class="lazyload"></a></p></li><li><p>get方法。传入一个坐标，如果坐标小于长度的一半，就从头遍历，否则从尾遍历</p></li><li><p>set方法。和get类似</p></li></ul><h3 id="List集合总结"><a href="#List集合总结" class="headerlink" title="List集合总结"></a>List集合总结</h3><ul><li><p><strong>ArrayList</strong>：</p><ul><li>底层实现是数组</li><li>ArrayList的默认初始化容量是10，每次扩容时候增加原先容量的⼀半，也就是变为原来的1.5倍 </li><li>在增删时候，需要数组的拷⻉复制<strong>(navite</strong> ⽅法由<strong>C/C++</strong>实现<strong>)</strong></li></ul></li><li><p><strong>LinkedList</strong>：</p><ul><li>底层实现是双向链表（⽅便实现往前遍历）</li></ul></li><li><p><strong>Vector</strong>：</p><ul><li>底层是数组，现在已少⽤，被ArrayList替代，原因有两个：<ol><li>Vector所有⽅法都是同步，有性能损失。</li><li>Vector初始length是10 超过length时 以100%⽐率增⻓，相⽐于<strong>ArrayList</strong>更多消耗内存。</li></ol></li></ul></li></ul><p>总的来说：查询多⽤<strong>ArrayList</strong>，增删多⽤<strong>LinkedList</strong>。</p><p><strong>但ArrayList</strong>增删慢不是绝对的：</p><ul><li><p>如果增加元素⼀直是使⽤ add (增加到末尾)的话，那是ArrayList要快</p></li><li><p>⼀直删除末尾的元素也是<strong>ArrayList</strong>要快（不⽤复制移动位置）</p></li></ul><h2 id="Map介绍"><a href="#Map介绍" class="headerlink" title="Map介绍"></a><strong>Map介绍</strong></h2><p>常用功能：</p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200404105527582.png" data-fancybox="group" data-caption="image-20200404105527582" class="fancybox"><img alt="image-20200404105527582" style="zoom:50%;" title="image-20200404105527582" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200404105527582.png" class="lazyload"></a><p>值得关注的四个实现类：HashMap，ConcurrentHashMap，LinkedHashMap，TreeMap</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200404105603024.png" data-fancybox="group" data-caption="image-20200404105603024" class="fancybox"><img alt="image-20200404105603024" title="image-20200404105603024" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200404105603024.png" class="lazyload"></a></p><p>如果散列表太满，是需要对散列表再散列，创建⼀个桶数更多的散列表，并将原有的元素插⼊到新表</p><p>中，丢弃原来的表~</p><p>装填因⼦(load factor)决定了何时对散列表再散列~</p><p>装填因⼦默认为0.75，如果表中超过了<strong>75%</strong>的位置已经填⼊了元素，那么这个表就会⽤双倍的桶数</p><p>⾃动进⾏再散列</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>150-逆波兰表达式求值</title>
      <link href="/2020/03/26/150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
      <url>/2020/03/26/150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>计算逆波兰式（后缀表达式）的值</p><p>运算符仅包含”+”,”-“,”*”和”/“，被操作数可能是整数或其他表达式</p><p>例如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9</span><br><span class="line">["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6</span><br></pre></td></tr></tbody></table></figure></div><p>思路：</p><blockquote><p>从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 op 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</p></blockquote><p>例如后缀表达式“3 4 + 5 × 6 -”：</p><ol><li>从左至右扫描，将3和4压入堆栈；</li><li>遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素，注意与前缀表达式做比较），计算出3+4的值，得7，再将7入栈；</li><li>将5入栈；</li><li>接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</li><li>将6入栈；</li><li>最后是-运算符，计算出35-6的值，即29，由此得出最终结果。</li></ol><p>这里用了Integer.parseInt的异常来判断是否是数字，用别的方式也可以</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>{</span><br><span class="line">        Stack<integer> stack = <span class="keyword">new</span> Stack<>();</integer></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < tokens.length; i++){</span><br><span class="line">            <span class="keyword">try</span>{</span><br><span class="line">              <span class="comment">//如果是数字，入栈</span></span><br><span class="line">                <span class="keyword">int</span> num = Integer.parseInt(tokens[i]);</span><br><span class="line">                stack.add(num);</span><br><span class="line">            }<span class="keyword">catch</span> (Exception e) {</span><br><span class="line">              <span class="comment">//如果是操作符，弹出栈顶两个元素，求值，再入栈</span></span><br><span class="line">                <span class="keyword">int</span> b = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> a = stack.pop();</span><br><span class="line">                stack.add(get(a, b, tokens[i]));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">      <span class="comment">//最后的结果在栈里</span></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//根据a,b和操作数计算值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, String operator)</span></span>{</span><br><span class="line">        <span class="keyword">switch</span> (operator) {</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">            <span class="keyword">return</span> a-b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">            <span class="keyword">return</span> a*b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">            <span class="keyword">return</span> a/b;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solr总结</title>
      <link href="/2020/03/25/Solr%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/25/Solr%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/Center.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/Center.png" class="lazyload"></a></p><p>在solr中如果要搜索 word1 那么就出 返回 doc1 和 doc2 如果 搜索 word1 和 word3 那么就会做一个交叉，返回doc2。</p></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>111-二叉树的最小深度</title>
      <link href="/2020/03/25/111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
      <url>/2020/03/25/111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>求给定二叉树的最小深度。最小深度是指树的根结点到最近叶子结点的最短路径上结点的数量。</p><p>思路：感觉层次遍历和广度优先搜索有点类似，没体会到区别在哪</p><p>BFS标准解法（非递归）：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) { val = x; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue<treenode> q = <span class="keyword">new</span> LinkedList<>();</treenode></span><br><span class="line">        <span class="comment">//当前层的个数</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//下一层的个数</span></span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前所在层</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        q.offer(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()){</span><br><span class="line">            TreeNode t = q.poll();</span><br><span class="line">          <span class="comment">//当前层结点个数减一</span></span><br><span class="line">            cur--;</span><br><span class="line">          <span class="comment">//如果找到一个叶子结点，提前退出</span></span><br><span class="line">            <span class="keyword">if</span>(t.left == <span class="keyword">null</span> && t.right == <span class="keyword">null</span>) <span class="keyword">return</span> index;</span><br><span class="line">          <span class="comment">//检查左子结点</span></span><br><span class="line">            <span class="keyword">if</span>(t.left != <span class="keyword">null</span>){</span><br><span class="line">              <span class="comment">//入队</span></span><br><span class="line">                q.offer(t.left);</span><br><span class="line">              <span class="comment">//下一层结点个数加一</span></span><br><span class="line">                next++;</span><br><span class="line">            }</span><br><span class="line">          <span class="comment">//检查右子结点</span></span><br><span class="line">            <span class="keyword">if</span>(t.right != <span class="keyword">null</span>){</span><br><span class="line">                q.offer(t.right);</span><br><span class="line">                next++;</span><br><span class="line">            }</span><br><span class="line">          <span class="comment">//如果当前层全部遍历了</span></span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="number">0</span>){</span><br><span class="line">                <span class="comment">//获取下一层个数</span></span><br><span class="line">                cur = next;</span><br><span class="line">                <span class="comment">//下一层从0开始</span></span><br><span class="line">                next = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//层数加一</span></span><br><span class="line">                index++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>普通递归：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//if(root.left == null && root.right == null)</span></span><br><span class="line">        <span class="comment">//    return 1;</span></span><br><span class="line">        <span class="keyword">int</span> left = run(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = run(root.right);</span><br><span class="line">      <span class="comment">//注意这里，很巧妙</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> || right == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> left + right + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.min(left, right) + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>非递归层序遍历解法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> && root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        Queue<treenode> queue = <span class="keyword">new</span> LinkedList<>();</treenode></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            depth++;</span><br><span class="line">          <span class="comment">//一次取一层</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < len; i++){</span><br><span class="line">                TreeNode cur = queue.poll();           </span><br><span class="line">                <span class="keyword">if</span>(cur.left == <span class="keyword">null</span> && cur.right == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">            }              </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> 层序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-按摩师</title>
      <link href="/2020/03/24/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%89%E6%91%A9%E5%B8%88/"/>
      <url>/2020/03/24/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%89%E6%91%A9%E5%B8%88/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p><p>注意：本题相对原题稍作改动 </p><p>示例 1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [1,2,3,1]</span><br><span class="line">输出： 4</span><br><span class="line">解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [2,7,9,3,1]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。</span><br></pre></td></tr></tbody></table></figure></div><p>示例 3：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [2,1,4,5,3,1,1,3]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。</span><br></pre></td></tr></tbody></table></figure></div><p>思路：</p><p>递推方程：dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])</p><p>空间O(n)的写法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i < n; i++){</span><br><span class="line">            dp[i] = Math.max(nums[i] + dp[i-<span class="number">2</span>], dp[i-<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>空间优化到O(1)的写法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < nums.length; i++) {</span><br><span class="line">            <span class="keyword">int</span> c = Math.max(b, a + nums[i]);</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>我最开始的写法，超出时间限制了。对动态规划理解的不够深，想用一种回溯法来选择。我写的和动态规划，路径树都是一样的，但我这种要遍历整个树，动态规划用DP做了剪枝。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> serve(nums, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">serve</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(i >= nums.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = nums[i] + serve(nums, i+<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> n = serve(nums, i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> m > n ? m : n;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lucene总结</title>
      <link href="/2020/03/23/Lucene%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/23/Lucene%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>作用：站内全文检索。</p><p>如何使用：</p><p>创建索引库，创建查询</p><p>根据搜索关键字出现的频率进行排序 </p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lucene </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>876-链表的中间结点</title>
      <link href="/2020/03/23/876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/"/>
      <url>/2020/03/23/876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br><span class="line">由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p><strong>提示：</strong></p><ul><li>给定链表的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li></ul></blockquote><p>思路：这道题比较简单，我用的快慢指针，但是在边界处理的地方不够简洁。这道题有三种解法，发散下思路。</p><p>方法一：用数组。</p><p>链表的缺点在于不能通过下标访问对应的元素。因此我们可以考虑对链表进行遍历，同时将遍历到的元素依次放入数组 A 中。如果我们遍历到了 N 个元素，那么链表以及数组的长度也为 N，对应的中间节点即为 A[N/2]。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        ListNode[] A = <span class="keyword">new</span> ListNode[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) {</span><br><span class="line">            A[t++] = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> A[t / <span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>方法二：单指针法</p><p>我们可以对方法一进行空间优化，省去数组 A。</p><p>我们可以对链表进行两次遍历。第一次遍历时，我们统计链表中的元素个数 N；第二次遍历时，我们遍历到第 N/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">            ++n;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (k < n / <span class="number">2</span>) {</span><br><span class="line">            ++k;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>方法三：快慢指针法</p><p>用两个指针 <code>slow</code> 与 <code>fast</code> 一起遍历链表。<code>slow</code> 一次走一步，<code>fast</code> 一次走两步。那么当 <code>fast</code> 到达链表的末尾时，<code>slow</code> 必然位于中间。</p><p>下面是我自己写的，处理的不好</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) { val = x; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        ListNode low = head;</span><br><span class="line">        ListNode high = head;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(head.next.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        <span class="keyword">while</span>(high != <span class="keyword">null</span>){</span><br><span class="line">            low = low.next;</span><br><span class="line">            high = high.next.next;</span><br><span class="line">            <span class="keyword">if</span>(high.next == <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">return</span> low;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(high.next.next == <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">return</span> low.next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>更简洁的做法是这样</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> && fast.next != <span class="keyword">null</span>) {</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>945-使数组唯一的最小增量</title>
      <link href="/2020/03/22/945-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F/"/>
      <url>/2020/03/22/945-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。</p><p>返回使 A 中的每个值都是唯一的最少操作次数。</p><p>示例 1:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：经过一次 move 操作，数组将变为 [1, 2, 3]。</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,2,1,2,1,7]</span><br><span class="line">输出：6</span><br><span class="line">解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。</span><br><span class="line">可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。提示：</span><br></pre></td></tr></tbody></table></figure></div><p>0 <= A.length <= 40000<br>0 <= A[i] < 40000</p><p>思路一：</p><p>由于 A[i] 的范围为 [0, 40000)，我们可以用数组统计出每个数出现的次数，然后对于每个重复出现的数，我们暴力地将它递增，直到它增加到一个没有重复出现的数为止。但这样的方法的时间复杂度较大，可以达到 O(N^2)，例如数组 A 中所有元素都是 1 的情况。</p><p>因此，我们不能对重复出现的数暴力的进行递增，而是用以下的做法：当我们找到一个没有出现过的数的时候，将之前某个重复出现的数增加成这个没有出现过的数。注意，这里 「之前某个重复出现的数」 是可以任意选择的，它并不会影响最终的答案，因为将 P 增加到 X 并且将 Q 增加到 Y，与将 P 增加到 Y 并且将 Q 增加到 X 都需要进行 (X + Y) - (P + Q) 次操作。</p><p>例如当数组 A 为 [1, 1, 1, 1, 3, 5] 时，我们发现有 3 个重复的 1，且没有出现过 2，4 和 6，因此一共需要进行 (2 + 4 + 6) - (1 + 1 + 1) = 9 次操作。</p><p>算法步骤：</p><p>首先统计出每个数出现的次数，然后从小到大遍历每个数 x：</p><p>如果 x 出现了两次以上，就将额外出现的数记录下来（例如保存到一个列表中）；</p><p>如果 x 没有出现过，那么在记录下来的数中选取一个 v，将它增加到 x，需要进行的操作次数为 x - v。</p><p>我们还可以对该算法进行优化，使得我们不需要将额外出现的数记录下来。<strong>还是以 [1, 1, 1, 1, 3, 5] 为例，当我们发现有 3 个重复的 1 时，我们先将操作次数减去 1 + 1 + 1。接下来，当我们发现 2，4 和 6 都没有出现过时，我们依次将操作次数增加 2，4 和 6。</strong></p><p>有一点可优化：<strong>初始化数组大小实际上 A.length() + max(A) 即可。</strong> </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">      <span class="comment">//实际上大小为 A.length() + max(A) 即可</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : A) count[x]++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//记录结果</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//记录重复的数字个数</span></span><br><span class="line">        <span class="keyword">int</span> rep = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">80000</span>; i++){</span><br><span class="line">          <span class="comment">//如果i是重复的</span></span><br><span class="line">            <span class="keyword">if</span>(count[i] >= <span class="number">2</span>){</span><br><span class="line">                rep += count[i] - <span class="number">1</span>;</span><br><span class="line">                ans -= i*(count[i] - <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">          <span class="comment">//如果i的位置为空，且前面有重复的未放置的数字</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rep > <span class="number">0</span> && count[i] == <span class="number">0</span>){</span><br><span class="line">                rep--;</span><br><span class="line">                ans += i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路二：</p><p>先排序。遍历的时候把后面的数变成比前一个数大1即可，在这个过程中记录增加的步数。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < A.length; i++){</span><br><span class="line">        <span class="keyword">if</span>(A[i] <= A[i-<span class="number">1</span>]){</span><br><span class="line">        res += A[i-<span class="number">1</span>]-A[i]+<span class="number">1</span>;</span><br><span class="line">            A[i] = A[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速排序模板</title>
      <link href="/2020/03/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/"/>
      <url>/2020/03/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>基本思想：</p><ul><li><p>1．先从数列中取出一个数作为基准数。</p></li><li><p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p></li><li><p>3．再对左右区间重复第二步，直到各区间只有一个数。  </p></li></ul><p>虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。因此我的对快速排序作了进一步的说明：挖坑填数+分治法：</p><p>以一个数组作为示例，取区间第一个数为基准数。</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>72</td><td>6</td><td>57</td><td>88</td><td>60</td><td>42</td><td>83</td><td>73</td><td>48</td><td>85</td></tr></tbody></table><p>初始时，i = 0; j = 9;  X = a[i] = 72</p><p>由于已经将 a[0] 中的数保存到 X 中，<strong>可以理解成在数组 a[0] 上挖了个坑</strong>，可以将其它数据填充到这来。</p><p>从j开始向前找一个比X小或等于X的数。当j=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]=a[8]; i++; 这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]; j–;</p><p>数组变为：</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3 i</th><th>4</th><th>5</th><th>6</th><th>7 j</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>48</td><td>6</td><td>57</td><td>88</td><td>60</td><td>42</td><td>83</td><td>73</td><td>88</td><td>85</td></tr></tbody></table><p>i = 3;  j = 7;  X=72</p><p>再重复上面的步骤，先从后向前找，再从前向后找。</p><p>从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，a[3] = a[5]; i++;</p><p>从i开始向后找，当i=5时，由于i==j退出。</p><p>此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将X填入a[5]。</p><p>数组变为：</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5 i j</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>48</td><td>6</td><td>57</td><td>42</td><td>60</td><td>72</td><td>83</td><td>73</td><td>88</td><td>85</td></tr></tbody></table><p>可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对a[0…4]和a[6…9]这二个子区间重复上述步骤就可以了。 </p><p>对挖坑填数进行总结:</p><ol><li>i =L; j = R; 将基准数挖出形成第一个坑a[i]。</li><li>j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</li><li>i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</li><li>再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</li></ol><p>照着这个总结很容易实现挖坑填数的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AdjustArray</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="comment">//返回调整后基准数的位置</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">    <span class="keyword">int</span> x = s[l]; <span class="comment">//s[l]即s[i]就是第一个坑</span></span><br><span class="line">    <span class="keyword">while</span> (i < j)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 从右向左找小于x的数来填s[i]</span></span><br><span class="line">        <span class="keyword">while</span>(i < j && s[j] >= x) </span><br><span class="line">            j--;  </span><br><span class="line">        <span class="keyword">if</span>(i < j) </span><br><span class="line">        {</span><br><span class="line">            s[i] = s[j]; <span class="comment">//将s[j]填到s[i]中，s[j]就形成了一个新的坑</span></span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 从左向右找大于或等于x的数来填s[j]</span></span><br><span class="line">        <span class="keyword">while</span>(i < j && s[i] < x)</span><br><span class="line">            i++;  </span><br><span class="line">        <span class="keyword">if</span>(i < j) </span><br><span class="line">        {</span><br><span class="line">            s[j] = s[i]; <span class="comment">//将s[i]填到s[j]中，s[i]就形成了一个新的坑</span></span><br><span class="line">            j--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//退出时，i等于j。将x填到这个坑中。</span></span><br><span class="line">    s[i] = x;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>再写分治的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort1</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (l < r)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> i = AdjustArray(s, l, r);<span class="comment">//先成挖坑填数法调整s[]</span></span><br><span class="line">        quick_sort1(s, l, i - <span class="number">1</span>); <span class="comment">// 递归调用 </span></span><br><span class="line">        quick_sort1(s, i + <span class="number">1</span>, r);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>挖坑+分治组合整理下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (l < r)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = r, x = s[l];</span><br><span class="line">        <span class="keyword">while</span> (i < j)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span>(i < j && s[j] >= x) <span class="comment">// 从右向左找第一个小于x的数</span></span><br><span class="line">                j--;  </span><br><span class="line">            <span class="keyword">if</span>(i < j) </span><br><span class="line">                s[i++] = s[j];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(i < j && s[i] < x) <span class="comment">// 从左向右找第一个大于等于x的数</span></span><br><span class="line">                i++;  </span><br><span class="line">            <span class="keyword">if</span>(i < j) </span><br><span class="line">                s[j--] = s[i];</span><br><span class="line">        }</span><br><span class="line">        s[i] = x;</span><br><span class="line">        quick_sort(s, l, i - <span class="number">1</span>); <span class="comment">// 递归调用 </span></span><br><span class="line">        quick_sort(s, i + <span class="number">1</span>, r);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>根据情况灵活选择分开写还是整合到一起。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25-最小的K个数</title>
      <link href="/2020/03/20/25-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/"/>
      <url>/2020/03/20/25-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></tbody></table></figure></div><p>思路一：</p><p>直接排序，取前k个数。这道题用快速排序最高效，因为注意到找前K大/前K小问题不需要对整个数组进行O(NlogN)的排序！直接通过快排切分排好第K小的数（下标为K-1），那么它左边的数就是比它小的另外K-1个数。快排模版要记牢。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 最后一个参数表示我们要找的是下标为k-1的数</span></span><br><span class="line">        <span class="keyword">return</span> quickSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] quickSearch(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (j == k) {</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(nums, j + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span></span><br><span class="line">        <span class="keyword">return</span> j > k? quickSearch(nums, lo, j - <span class="number">1</span>, k): quickSearch(nums, j + <span class="number">1</span>, hi, k);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> v = nums[lo];</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i < j) {</span><br><span class="line">            <span class="keyword">while</span>(i < j && nums[j] >= v) </span><br><span class="line">                 j--;  </span><br><span class="line">        <span class="keyword">if</span>(i < j){</span><br><span class="line">                nums[i] = nums[j]; </span><br><span class="line">                i++;</span><br><span class="line">            } </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span>(i < j && nums[i] <= v)</span><br><span class="line">            i++;  </span><br><span class="line">        <span class="keyword">if</span>(i < j) {</span><br><span class="line">            nums[j] = nums[i]; </span><br><span class="line">            j--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">        nums[i] = v;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路二：</p><p>用PriorityQueue实现大顶堆。保持堆的大小为K，然后遍历数组中的数字，遍历的时候做如下判断：</p><ol><li>若目前堆的大小小于K，将当前数字放入堆中。</li><li>否则判断当前数字与大根堆堆顶元素的大小关系，如果当前数字比大根堆堆顶还大，这个数就直接跳过；反之如果当前数字比大根堆堆顶小，先poll掉堆顶，再将该数字放入堆中。</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 默认是小根堆，实现大根堆需要重写一下比较器。</span></span><br><span class="line">        Queue<integer> pq = <span class="keyword">new</span> PriorityQueue<>((v1, v2) -> v2 - v1);</integer></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: arr) {</span><br><span class="line">            <span class="keyword">if</span> (pq.size() < k) {</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (num < pq.peek()) {</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回堆中的元素</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[pq.size()];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: pq) {</span><br><span class="line">            res[idx++] = num;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识盲区</title>
      <link href="/2020/03/19/%E7%9F%A5%E8%AF%86%E7%9B%B2%E5%8C%BA/"/>
      <url>/2020/03/19/%E7%9F%A5%E8%AF%86%E7%9B%B2%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>峰哥项目一的知识盲区：</p><p>hibernate，ssh整合，Solr ，Memcached ，Lucene ，elasticseacrch ，Redis</p></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java面经总结</title>
      <link href="/2020/03/19/java%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/19/java%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h4><ul><li>重载发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序，返回值，修饰访问符不同</li><li>重写发正在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。</li></ul><h4 id="🌟String，StringBuffer，StringBuilder的区别？为什么String不可变？"><a href="#🌟String，StringBuffer，StringBuilder的区别？为什么String不可变？" class="headerlink" title="🌟String，StringBuffer，StringBuilder的区别？为什么String不可变？"></a>🌟String，StringBuffer，StringBuilder的区别？为什么String不可变？</h4><ul><li>String类使用final关键字字符数组保存字符串。可理解为常量，线程安全</li><li>StringBuffer<strong>是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类</strong>，对方法加了同步锁，线程安全。Stringbuilder非线程安全</li></ul><p>####自动装箱与自动拆箱</p><ul><li>基本类型与引用类型的转换</li></ul><h4 id="与equals的区别"><a href="#与equals的区别" class="headerlink" title="==与equals的区别"></a>==与equals的区别</h4><ul><li>== 基本数据类型直接比较值，引用类型比较对象的内存地址</li><li>equals默认等价于==。一般会重写比较规则来比较两个对象。String的equals是被重写过的，按值比较。</li></ul><h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><ul><li>用于变量（不可修改/不可指向其它对象）</li><li>用于方法（防止继承类修改）</li><li>用于类（不可继承）</li></ul><p>####Object类的常见方法总结（注意native和final）</p><ul><li>getclass 返回当前运行时的Class对象</li><li>hashcode 返回对象的哈希码。主要用在哈希表中</li><li>equals</li><li>clone 需要实现Cloneable接口，并重写clone方法才能用</li><li>toString 默认返回实例哈希码16进制字符串</li><li>notify 唤醒一个在此对象监视器上等待的线程。多个线程在等待只会任意唤醒一个</li><li>notifyAll 同上，但是唤醒所有线程</li><li>wait 暂停线程的执行。sleep方法没有释放锁，wait会释放锁</li><li>finalize 实例被垃圾回收器回收时触发的操作</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Listener总结</title>
      <link href="/2020/03/19/Listener%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/19/Listener%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>Listener 的作用是用于监听 web应用的创建和销毁，以及在其上attribute发生的变化。web应用即ServletContext对象。除了对web应用的监听外，还能监听session和request的生命周期，以及他们的attribute发生的变化。</p><h4 id="Listener-监听-Context"><a href="#Listener-监听-Context" class="headerlink" title="Listener 监听 Context"></a>Listener 监听 Context</h4><p>对Context的监听分<strong>生命周期的监听</strong>，和<strong>Context上Attribute变化的监听</strong>两种。</p><p>下面分别完成简单的示例</p><ul><li><p>编写 ContextListener：</p><p>实现接口ServletContextListener，这个接口有两个方法</p><p><code>public void contextDestroyed(ServletContextEvent arg0)</code> 对应当前web应用的销毁</p><p><code>public void contextInitialized(ServletContextEvent arg0)</code>对应当前web应用的初始化</p></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent arg0)</span> </span>{</span><br><span class="line">System.out.println(<span class="string">"web 应用销毁  "</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent arg0)</span> </span>{</span><br><span class="line">System.out.println(<span class="string">"web 应用初始化 "</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><ul><li><p>配置web.xml</p><p>配置监听器</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">listener</span>></span></span><br><span class="line"><span class="tag"><<span class="name">listener-class</span>></span>listener.ContextListener<span class="tag"><!--<span class="name"-->listener-class</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->listener</span>></span><br></pre></td></tr></tbody></table></figure></div></li></ul><ul><li><p>编写 ContextAttributeListener</p><p>实现接口ServletContextAttributeListener</p><p><code>public void attributeAdded(ServletContextAttributeEvent e)</code>监听属性的增加</p><p><code>public void attributeRemoved(ServletContextAttributeEvent e)</code>监听属性的移除</p><p><code>public void attributeReplaced(ServletContextAttributeEvent e)</code>监听属性的替换</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextAttributeEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextAttributeListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextAttributeListener</span> <span class="keyword">implements</span> <span class="title">ServletContextAttributeListener</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletContextAttributeEvent e)</span> </span>{</span><br><span class="line">System.out.println(<span class="string">"增加属性 "</span>);</span><br><span class="line">System.out.println(<span class="string">"属性是"</span> + e.getName());</span><br><span class="line">System.out.println(<span class="string">"值是"</span> + e.getValue());</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletContextAttributeEvent e)</span> </span>{</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"移除属性 "</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletContextAttributeEvent e)</span> </span>{</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"替换属性"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li></ul><ul><li><p>配置web.xml</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">listener</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">listener-class</span>></span>listener.ContextAttributeListener<span class="tag"><!--<span class="name"-->listener-class</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->listener</span>></span><br></pre></td></tr></tbody></table></figure></div></li></ul><p>类似的Listener也可以监听Session和Request的生命周期与Attribute变化。</p><p>####Listener的应用</p><p>统计在线人数：</p><p>HTTP协议是短链接的，所以无法在服务端根据建立了多少连接来统计当前有多少人在线。 不过可以通过统计session有多少来估计在线人数。一旦一个用户访问服务器，就会创建一个session. 如果该用户持续访问，那么该session会持续有效。如果经历了30分钟，该用户也没有做任何操作，就表示该用户“下线” 了，其对应的session也会被销毁。所以可以通过统计有多少session被保留来估计当前在线人数。</p><ul><li><p>编写 OnlineNumberListener</p><p>OnlineNumberListener 实现接口HttpSessionListener</p><p>当创建一个session的时候，就把数字+1，并且放在application里。</p><p><code>ServletContext application = e.getSession().getServletContext();</code><br>这就是jsp里的application</p><p><strong>注:</strong> 第一次从application里取数据的时候，是空的，要设置为0。</p><p>当销毁一个session的时候，把这个数字-1</p></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlineNumberListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent e)</span> </span>{</span><br><span class="line"></span><br><span class="line">ServletContext application = e.getSession().getServletContext();</span><br><span class="line"></span><br><span class="line">Integer online_number = (Integer) application.getAttribute(<span class="string">"online_number"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == online_number)</span><br><span class="line">online_number = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">online_number++;</span><br><span class="line">application.setAttribute(<span class="string">"online_number"</span>, online_number);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"新增一位在线用户"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent e)</span> </span>{</span><br><span class="line"></span><br><span class="line">ServletContext application = e.getSession().getServletContext();</span><br><span class="line"></span><br><span class="line">Integer online_number = (Integer) application.getAttribute(<span class="string">"online_number"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span>==online_number){</span><br><span class="line">online_number = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">online_number--;</span><br><span class="line">application.setAttribute(<span class="string">"online_number"</span>, online_number);</span><br><span class="line">System.out.println(<span class="string">"一位用户离线"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><ul><li><p>配置web.xml</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">listener</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">listener-class</span>></span>listener.OnlineNumberListener<span class="tag"><!--<span class="name"-->listener-class</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->listener</span>></span><br></pre></td></tr></tbody></table></figure></div></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Filter总结</title>
      <link href="/2020/03/19/Filter%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/19/Filter%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>Filter就像一个一个哨卡，用户的请求需要经过Filter，并且可以有多个过滤器。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200319091345587.png" data-fancybox="group" data-caption="image-20200319091345587" class="fancybox"><img alt="image-20200319091345587" title="image-20200319091345587" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200319091345587.png" class="lazyload"></a></p><p>一个简单的Filter，用来打印用户访问ip地址和访问的页面：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//doFilter()方法中的req参数的类型是ServletRequest，需要转换为HttpServletRequest类型方便调用某些方法</span></span><br><span class="line">HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取来路用户的ip地址</span></span><br><span class="line">String ip = request.getRemoteAddr();</span><br><span class="line">    <span class="comment">//获取用户访问的页面地址</span></span><br><span class="line">String url = request.getRequestURL().toString();</span><br><span class="line">    </span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">String date = sdf.format(d);</span><br><span class="line"><span class="comment">//在控制台打印出来</span></span><br><span class="line">System.out.printf(<span class="string">"%s %s 访问了 %s%n"</span>, date, ip, url);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//过滤器放行，表示继续运行下一个过滤器，或者最终访问的某个servlet,jsp,html等等</span></span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>写完还需要在web.xml中进行filter的配置，和servlet的配置很类似.</p><p>其中<code><url-pattern>/*</url-pattern></code>表示所有的访问都会过滤</p><p>如果配置成<code><url-pattern>*.jsp</url-pattern></code>就表示只过滤jsp</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">filter</span>></span></span><br><span class="line"><span class="tag"><<span class="name">filter-name</span>></span>FirstFilter<span class="tag"><!--<span class="name"-->filter-name</span>></span><br><span class="line"><span class="tag"><<span class="name">filter-class</span>></span>filter.FirstFilter<span class="tag"><!--<span class="name"-->filter-class</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->filter</span>></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">filter-mapping</span>></span></span><br><span class="line"><span class="tag"><<span class="name">filter-name</span>></span>FirstFilter<span class="tag"><!--<span class="name"-->filter-name</span>></span><br><span class="line"><span class="tag"><<span class="name">url-pattern</span>></span>/*<span class="tag"><!--<span class="name"-->url-pattern</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->filter-mapping</span>></span><br></pre></td></tr></tbody></table></figure></div><p>另外要注意：</p><ul><li>与Servlet需要配置自启动才会随着tomcat的启动而执行init()方法不一样，Filter<strong>一定</strong>会随着tomcat的启动自启动。</li><li>如果Filter启动失败，或者本身有编译错误，<strong>不仅这个Filter不能使用</strong>，<strong>整个web应用会启动失败</strong>，导致用户无法访问页面</li></ul><p>Filter的应用：</p><ul><li>中文处理</li><li>登陆验证</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ssm项目导入IDEA运行报错</title>
      <link href="/2020/03/18/ssm%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5IDEA%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99/"/>
      <url>/2020/03/18/ssm%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5IDEA%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>解决bug的思路：</p><p>出现报错时，先找到日志查看报错信息。报错信息里面大部分都是没用的话，而且一般是一连串的错误。最关键的就是要找到报错的root reason根本原因，往往是有一个地方出错才导致后面的出错，解决了根本原因，其他的也都迎刃而解。root reason一般在报错信息的最上方或最下方。</p><p>之前导入ssm商城项目的时候，报错一直没有解决</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error creating bean with name 'sqlSession' defined in class path resource [applicationContext.xml]: Cannot resolve reference to bean 'dataSource' while setting bean property 'dataSource'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dataSource' defined in class path resource [applicationContext.xml]: Invocation of init method failed; nested exception is java.sql.SQLException: Unknown system variable 'tx_isolation'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'sqlSession' defined in class path resource [applicationContext.xml]: Cannot resolve reference to bean 'dataSource' while setting bean property 'dataSource'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dataSource' defined in class path resource [applicationContext.xml]: Invocation of init method failed; nested exception is java.sql.SQLException: Unknown system variable 'tx_isolation'</span><br></pre></td></tr></tbody></table></figure></div><p>今天终于解决了这个问题，大致原因是dataSource在配置里找不到。想起了昨天也是用cp30配置dataSource的时候报类似的错，然后换成下面的就可以了。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span>></span> </span><br><span class="line">            <span class="tag"><<span class="name">value</span>></span>com.mysql.jdbc.Driver<span class="tag"><!--<span class="name"-->value</span>></span> <br><span class="line">        <span class="tag"><!--<span class="name"-->property</span>></span> <br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span>></span> </span><br><span class="line">            <span class="tag"><<span class="name">value</span>></span>jdbc:mysql://localhost:3306/xxx?characterEncoding=UTF-8<span class="tag"><!--<span class="name"-->value</span>></span> <br><span class="line">     </span><br><span class="line">        <span class="tag"><!--<span class="name"-->property</span>></span> <br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span>></span> </span><br><span class="line">            <span class="tag"><<span class="name">value</span>></span>root<span class="tag"><!--<span class="name"-->value</span>></span> <br><span class="line">        <span class="tag"><!--<span class="name"-->property</span>></span> <br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>></span> </span><br><span class="line">            <span class="tag"><<span class="name">value</span>></span>admin<span class="tag"><!--<span class="name"-->value</span>></span> <br><span class="line">        <span class="tag"><!--<span class="name"-->property</span>></span>  <br><span class="line">   <span class="tag"><!--<span class="name"-->bean</span>></span><br></pre></td></tr></tbody></table></figure></div><p>同样的方法试了一下，成功！</p><p>虽然还不理解具体的问题原因，但是至少迈出了一步。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git总结</title>
      <link href="/2020/03/18/git%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/18/git%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><ul><li><p>git commit。提交</p></li><li><p>git branch。创建分支</p></li><li><p>git checkout。切换当前分支，也可以用于分离HEAD</p></li><li><p>git merge。合并分支，把两个分支的修改合到一起，但是头结点的父亲结点会有两个。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200318105156046.png" data-fancybox="group" data-caption="image-20200318105156046" class="fancybox"><img alt="image-20200318105156046" title="image-20200318105156046" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200318105156046.png" class="lazyload"></a>     </p></li><li><p>git rebase。合并后的分支在一条线上。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200318105419248.png" data-fancybox="group" data-caption="image-20200318105419248" class="fancybox"><img alt="image-20200318105419248" title="image-20200318105419248" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200318105419248.png" class="lazyload"></a></p></li><li><p>git reset HEAD^1。本地分支回退</p></li><li><p>git revert HEAD。用新的结点记录表示回退，便于远程分支的更新</p></li><li><p>git clone。克隆远程分支</p></li><li><p>git fetch。本地的o/master从远程分支拉取最新提交，</p></li><li><p>git pull。相当于fetch+merge，把从远程分支拉取的合并到本地分支</p></li><li><p>git push。把本地分支推送到远程分支，同时本地的o/master也会同步</p></li></ul><p>​    实际的团队工作中，分支看起来像这样：</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200318110621410.png" data-fancybox="group" data-caption="image-20200318110621410" class="fancybox"><img alt="image-20200318110621410" title="image-20200318110621410" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200318110621410.png" class="lazyload"></a></p><p>​    master分支应该是非常稳定的，仅用来发布新版本，平时不能在上面干活。干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本。团队中每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以。</p><p>​    还需要理解<strong>暂存区和工作区</strong>的概念。平时正在修改的文件处于工作区，git add命令实际上就是把要提交的所有修改从工作区放到暂存区，然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。</p><p>想学好git还是得多实践，可以在<a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">这里</a>多模拟练习，当然在GitHub中加入一个开源项目和别人协作，是最好的练习方式。</p></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>836-矩形重叠</title>
      <link href="/2020/03/18/836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/"/>
      <url>/2020/03/18/836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。</p><p>如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p><p>给出两个矩形，判断它们是否重叠并返回结果。</p><p>示例 1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rec1 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>], rec2 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p>示例 2：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rec1 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>], rec2 = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="keyword">false</span></span><br></pre></td></tr></tbody></table></figure></div><p>思路：这道题乍一看很简单，第一直觉是，判断矩形的四个顶点是否在另一个矩形内，但是后来发现，矩形重叠有好多种情况。比如下面这种：</p><p> <a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/IMG_0032.JPG" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/IMG_0032.JPG" class="lazyload"></a></p><p>顶点都不在矩形内，或者顶点在边上（1或2个顶点在边上都有可能重叠）。这样看来，重叠的情况就有点多了。考虑反向思维，不重叠的情况有哪些呢？哇，突然发现，不重叠的情况只有4种，上/下/左/右，这就很清晰了。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> !(rec1[<span class="number">2</span>] <= rec2[<span class="number">0</span>] ||   <span class="comment">// left</span></span><br><span class="line">                 rec1[<span class="number">3</span>] <= rec2[<span class="number">1</span>] ||   <span class="comment">// bottom</span></span><br><span class="line">                 rec1[<span class="number">0</span>] >= rec2[<span class="number">2</span>] ||   <span class="comment">// right</span></span><br><span class="line">                 rec1[<span class="number">1</span>] >= rec2[<span class="number">3</span>]);    <span class="comment">// top</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路二：</p><p>如果两个矩形重叠，那么它们重叠的区域一定也是一个矩形，那么这代表了两个矩形与 x轴平行的边（水平边）投影到 x 轴上时会有交集，与 y 轴平行的边（竖直边）投影到 y 轴上时也会有交集。因此，我们可以将问题看作一维线段是否有交集的问题。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (Math.min(rec1[<span class="number">2</span>], rec2[<span class="number">2</span>]) > Math.max(rec1[<span class="number">0</span>], rec2[<span class="number">0</span>]) &&</span><br><span class="line">                Math.min(rec1[<span class="number">3</span>], rec2[<span class="number">3</span>]) > Math.max(rec1[<span class="number">1</span>], rec2[<span class="number">1</span>]));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>尤克里里</title>
      <link href="/2020/03/17/%E5%B0%A4%E5%85%8B%E9%87%8C%E9%87%8C/"/>
      <url>/2020/03/17/%E5%B0%A4%E5%85%8B%E9%87%8C%E9%87%8C/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="目标：熟练演奏白熊音乐-《离开地球表面》"><a href="#目标：熟练演奏白熊音乐-《离开地球表面》" class="headerlink" title="目标：熟练演奏白熊音乐 -《离开地球表面》"></a>目标：熟练演奏白熊音乐 -《离开地球表面》</h4><ul><li><p>已学会：</p><p>《情非得已》，《好像爱这个世界》，《你的答案》，《平凡之路》</p></li><li><p>需要加强的技巧：</p><p>轮扫，轮指，切音，滑音，爬格子，和弦转换，指弹</p></li><li><p>待学：</p><p>看复杂谱，乐理</p></li></ul><h4 id="学习方法："><a href="#学习方法：" class="headerlink" title="学习方法："></a>学习方法：</h4><ul><li>爬格子</li><li>目标导向，练歌</li><li>每周都要练，一定不能停下来</li></ul><p>一年之后，我能把那首歌弹下来吗？坚持！我可以做到！</p></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ssm整合简单示例</title>
      <link href="/2020/03/17/ssm%E6%95%B4%E5%90%88%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2020/03/17/ssm%E6%95%B4%E5%90%88%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="整体步骤如下："><a href="#整体步骤如下：" class="headerlink" title="整体步骤如下："></a>整体步骤如下：</h4><ol><li>创建Maven项目</li><li>pom.xml添加依赖</li><li>配置tomcat服务器</li><li>搭建和测试Spring。<ul><li>applicationContext.xml中配置扫描器，spring管理的是service和dao层的注解，controller注解交给springmvc管理。</li><li>给service层对象添加@Service(“xxx”)注解，用扫描注解的方式得到对象，调用测试方法</li></ul></li><li>搭建和测试SpringMVC。<ul><li>配置过滤器，解决中文乱码问题</li><li>配置DispatcherServlet前端控制器</li><li>springmvc.xml中配置注解扫描器，只扫描 controller</li><li>springmvc.xml中配置视图解析器，控制 controller 跳转到 “/WEB-INF/pages/” 目录下，以 “xxx.jsp” 结尾的文件</li><li>开启对 springMVC 注解的支持</li><li>给控制器添加@Controller和@RequestMapping(“/xxx”)</li></ul></li><li>Spring整合SpringMVC<ul><li><strong>目的是在 controller 中能成功调用 service 对象中的方法</strong></li><li>修改web.xml。配置 ContextLoaderListener 监听器，使项目在启动时就去加载applicationContext.xml的配置文件。需要注意web.xml 中的文件配置有先后顺序</li><li>在controller中用@Autowired注入service层对象，并调用测试方法</li></ul></li><li>搭建和测试Mybatis<ul><li>SqlMapConfig.xml中添加数据源配置信息和引入映射文件</li><li>给DAO层的对象添加@Select(“select * from user”)和 @Insert(‘’xxx”)等注解</li><li>在测试类中，加载配置文件，创建工厂，创建 sqlSession 对象，获取代理对象，然后调用dao的方法。<font color="red"><strong>这一步不太理解</strong></font></li></ul></li><li>Spring整合Mybatis<ul><li><strong>目的是把 MyBatis 的数据源，SqlSession 和 dao 都交给 spring 管理</strong></li><li>把 SqlMapConfig.xml 配置文件中的内容配置到 applicationContext.xml 中</li><li>删除 SqlMapConfig.xml</li><li>给DAO对象添加 @Repository 注解</li><li>在service层中用@Autowired注入dao对象</li></ul></li></ol><p>至此，Spring，SpringMVC，Mybatis已整合完成。</p><p>详细步骤：</p><p><a href="https://blog.csdn.net/liyuanyue2017/article/details/96507642" target="_blank" rel="noopener">https://blog.csdn.net/liyuanyue2017/article/details/96507642</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1160-拼写单词</title>
      <link href="/2020/03/17/1160-%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/"/>
      <url>/2020/03/17/1160-%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</p><p>假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p><p>注意：每次拼写时，chars 中的每个字母都只能用一次。</p><p>返回词汇表 words 中你掌握的所有单词的 长度之和。</p><p>示例 1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [<span class="string">"cat"</span>,<span class="string">"bt"</span>,<span class="string">"hat"</span>,<span class="string">"tree"</span>], chars = <span class="string">"atach"</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释： </span><br><span class="line">可以形成字符串 <span class="string">"cat"</span> 和 <span class="string">"hat"</span>，所以答案是 <span class="number">3</span> + <span class="number">3</span> = <span class="number">6</span>。</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [<span class="string">"hello"</span>,<span class="string">"world"</span>,<span class="string">"leetcode"</span>], chars = <span class="string">"welldonehoneyr"</span></span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：</span><br><span class="line">可以形成字符串 <span class="string">"hello"</span> 和 <span class="string">"world"</span>，所以答案是 <span class="number">5</span> + <span class="number">5</span> = <span class="number">10</span>。</span><br></pre></td></tr></tbody></table></figure></div><p>思路：建立字母表的哈希表，再建立每个单词的哈希表，记录次数进行比较。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(String[] words, String chars)</span> </span>{</span><br><span class="line">        HashMap<character, integer> map = <span class="keyword">new</span> HashMap<>();</character,></span><br><span class="line">        <span class="comment">//字母表建立哈希表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < chars.length(); i++){</span><br><span class="line">            <span class="keyword">char</span> c = chars.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map.get(c) != <span class="keyword">null</span>)</span><br><span class="line">                map.put(c, map.get(c) + <span class="number">1</span>);           </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.put(c, <span class="number">1</span>); </span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//记录符合条件的单词位置</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[words.length];</span><br><span class="line">        <span class="comment">//遍历每个单词</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j < words.length; j++){</span><br><span class="line">            HashMap<character, integer> word_map = <span class="keyword">new</span> HashMap<>();</character,></span><br><span class="line">            <span class="comment">//每个单词建立哈希表。flag标记是否满足条件</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k < words[j].length(); k++){</span><br><span class="line">                <span class="keyword">char</span> w = words[j].charAt(k);</span><br><span class="line">                <span class="keyword">if</span>(word_map.get(w) != <span class="keyword">null</span>)</span><br><span class="line">                    word_map.put(w, word_map.get(w) + <span class="number">1</span>);           </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    word_map.put(w, <span class="number">1</span>); </span><br><span class="line">              <span class="comment">//判断是否不满足条件（没有这个字母或者超出数量）</span></span><br><span class="line">                <span class="keyword">if</span>(map.get(w) == <span class="keyword">null</span> || map.get(w) < word_map.get(w)){</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">          <span class="comment">//如果这个单词满足条件，置1</span></span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">                res[j] = <span class="number">1</span>;    </span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//计算符合条件单词的长度之和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m < res.length; m++)</span><br><span class="line">            <span class="keyword">if</span>(res[m] == <span class="number">1</span>)</span><br><span class="line">                sum += words[m].length();</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>还有一种用int[26]模拟哈希的方法。遇到有提示字符串仅包含小写（或者大写）英文字母的题，都可以试着考虑能不能构造长度为26的每个元素分别代表一个字母的数组，来简化计算。对于这道题，用数组c来保存字母表里每个字母出现的次数，如法炮制，再对词汇表中的每个词汇都做一数组w，比较数组w与数组c的对应位置。如果w中的都不大于c，就说明该词可以被拼写出，长度计入结果。如果w其中有一个超过了c，则说明不可以被拼写，直接跳至下一个（这里用到了<strong>带label的continue</strong>语法）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(String[] words, String chars)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">      <span class="comment">//字母表的“哈希”</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> cc : chars.toCharArray()) {</span><br><span class="line">            c[(<span class="keyword">int</span>)(cc - <span class="string">'a'</span>)] += <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        a: <span class="keyword">for</span>(String word : words) {</span><br><span class="line">            <span class="keyword">int</span>[] w = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="comment">//每个单词的“哈希”</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ww : word.toCharArray()) {</span><br><span class="line">                w[(<span class="keyword">int</span>)(ww - <span class="string">'a'</span>)] += <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//检查每个单词</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i<<span class="number">26</span>; i++) {</span><br><span class="line">                <span class="keyword">if</span>(w[i] > c[i]) {</span><br><span class="line">                    <span class="keyword">continue</span> a;<span class="comment">//这里会跳到a处直接进行下一次循环</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            res += word.length();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题-字符串压缩</title>
      <link href="/2020/03/16/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/"/>
      <url>/2020/03/16/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p><p>示例1:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="string">"aabcccccaaa"</span></span><br><span class="line">输出：<span class="string">"a2b1c5a3"</span></span><br></pre></td></tr></tbody></table></figure></div><p>示例2:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="string">"abbccd"</span></span><br><span class="line">输出：<span class="string">"abbccd"</span></span><br><span class="line">解释：<span class="string">"abbccd"</span>压缩后为<span class="string">"a1b2c2d1"</span>，比原字符串长度更长。</span><br></pre></td></tr></tbody></table></figure></div><p>思路：按照要求直接写，注意细节。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(S.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> S;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(S.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < S.length(); i++){</span><br><span class="line">          <span class="comment">//如果和上个字符相同，计数加一</span></span><br><span class="line">            <span class="keyword">if</span>(S.charAt(i) == sb.charAt(sb.length() - <span class="number">1</span>)){</span><br><span class="line">                count++;         </span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//如果和上个字符不相同</span></span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="comment">//上个字符的数量</span></span><br><span class="line">                sb.append(count);</span><br><span class="line">              <span class="comment">//当前字符</span></span><br><span class="line">                sb.append(S.charAt(i));</span><br><span class="line">              <span class="comment">//计数重置</span></span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">      <span class="comment">//最后一个字符记得也把计数加上</span></span><br><span class="line">      sb.append(count);</span><br><span class="line">        <span class="keyword">return</span> sb.length() >= S.length() ? S : sb.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>双指针解法：</p><p>使用一前一后两个指针，统计相同字符连续出现的个数，构建新字符串返回</p><p>具体来说，两指针在0位初始，后指针b每次一直移动到所指字符与前指针a所指字符不同的地方，<br>则a所指的字符出现次数为b-a，将字符及其次数插入新字符串中，<br>最后a跳转到b的位置，进入下一个循环</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>{</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a < S.length()) {</span><br><span class="line">            <span class="keyword">while</span>(b < S.length() && S.charAt(a) == S.charAt(b)) {</span><br><span class="line">                b++;</span><br><span class="line">            }</span><br><span class="line">            sb.append(S.charAt(a)).append(String.valueOf(b - a));</span><br><span class="line">            a = b;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sb.length() >= S.length() ? S : sb.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>695-岛屿的最大面积</title>
      <link href="/2020/03/15/695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/"/>
      <url>/2020/03/15/695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)</p><p>示例 1:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br></pre></td></tr></tbody></table></figure></div><p>类似围棋。</p><p>思路：遍历二维数组，如果遇到1，就在此进行广度优先遍历，访问过的直接置0(沉岛思想)，这样这个岛屿访问完就全为0了，下次不用再进行dfs。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < row; i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j < col; j++){</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>){</span><br><span class="line">                  <span class="comment">//更新岛屿面积最大值</span></span><br><span class="line">                    res = Math.max(res, dfs(i, j, grid));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] grid)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果不在矩阵内，或者为0，就返回0</span></span><br><span class="line">        <span class="keyword">if</span>(i >= row || j >= col || i < <span class="number">0</span> || j < <span class="number">0</span> || grid[i][j] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//因为当前坐标下是1，代表一个面积，别忘了</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//标记已访问</span></span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//上下左右哪个在矩阵内且值为1，就继续dfs</span></span><br><span class="line">        <span class="keyword">if</span>(i - <span class="number">1</span> < row || j < col || i - <span class="number">1</span> >= <span class="number">0</span> || j >= <span class="number">0</span> || grid[i][j] == <span class="number">1</span>)</span><br><span class="line">            res += dfs(i - <span class="number">1</span>, j, grid);</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> < row || j < col || i + <span class="number">1</span> >= <span class="number">0</span> || j >= <span class="number">0</span> || grid[i][j] == <span class="number">1</span>)</span><br><span class="line">            res += dfs(i + <span class="number">1</span>, j, grid);</span><br><span class="line">        <span class="keyword">if</span>(i < row || j - <span class="number">1</span> < col || i >= <span class="number">0</span> || j - <span class="number">1</span> >= <span class="number">0</span> || grid[i][j] == <span class="number">1</span>)</span><br><span class="line">            res += dfs(i, j - <span class="number">1</span>, grid);</span><br><span class="line">        <span class="keyword">if</span>(i < row || j + <span class="number">1</span> < col || i >= <span class="number">0</span> || j + <span class="number">1</span> >= <span class="number">0</span> || grid[i][j] == <span class="number">1</span>)</span><br><span class="line">            res += dfs(i, j + <span class="number">1</span>, grid);</span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>300-最长上升子序列</title>
      <link href="/2020/03/14/300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2020/03/14/300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">18</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure></div><p>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。<br>说明:</p><p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。<br>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><p>思路一：</p><p>动态规划。</p><p>使用<strong>数组dp</strong>保存每步子问题的最优解。<br>dp[i] 代表以第 i 个元素结尾的最长上升子序列的长度。<br>求解 dp[i] 时，向前遍历找出比 i 元素小的元素 j，令 dp[i] 为 max（dp[i],dp[j]+1)。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < nums.length; i++){</span><br><span class="line">          <span class="comment">//记录i之前的，且nums[j]<nums[i]的，最大的dp[j]。< span></nums[i]的，最大的dp[j]。<></span><br><span class="line">            <span class="keyword">int</span> maxval = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j < i; j++){</span><br><span class="line">                <span class="keyword">if</span>(nums[j] < nums[i]){</span><br><span class="line">                    maxval = Math.max(dp[j], maxval);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">          <span class="comment">//如果没有符合条件的j，dp[i]应该为1</span></span><br><span class="line">            dp[i] = maxval + <span class="number">1</span>;</span><br><span class="line">            max = Math.max(dp[i], max);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line">}</span><br></span></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//这种写法更清晰</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < nums.length; i++) {</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j < i; j++) {</span><br><span class="line">                <span class="keyword">if</span>(nums[j] < nums[i]) dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路二：（太巧妙了，至今还不是完全理解）</p><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/</a></p><p>贪心+二分查找。新建一个数组，第一个数先放进去，然后第二个数和第一个数比较，如果说大于第一个数，那么就接在他后面，如果小于第一个数，那么就替换，一般的，如果有i个数，那么每进来一个新的数，都要用二分查找法来得知要替换在哪个位置的数。因为有个for循环，所以是O(N),在加上循环里有个二分查找，所以最后是O(NlogN)的时间复杂度。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] tails = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) {</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, j = res;</span><br><span class="line">            <span class="keyword">while</span>(i < j) {</span><br><span class="line">                <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(tails[m] < num) i = m + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> j = m;</span><br><span class="line">            }</span><br><span class="line">            tails[i] = num;</span><br><span class="line">            <span class="keyword">if</span>(res == j) res++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>169-多数元素</title>
      <link href="/2020/03/13/169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
      <url>/2020/03/13/169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>思路一：</p><p>遍历数组，用哈希表记录每个数字出现的次数，遇到超过n/2的就返回</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>){</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        Map<integer, integer> map = <span class="keyword">new</span> HashMap<>();</integer,></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums){</span><br><span class="line">        <span class="keyword">if</span>(map.get(num) != <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">int</span> tmp = map.get(num) + <span class="number">1</span>;</span><br><span class="line">            map.put(num, tmp);</span><br><span class="line">            <span class="keyword">if</span>(tmp > nums.length/<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">        }  </span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            map.put(num, <span class="number">1</span>);</span><br><span class="line">        }      </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路二：</p><p>先排序，然后找处于n/2位置的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length >> <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路三：</p><p>摩尔投票法思路<br>候选人(cand_num)初始化为nums[0]，票数count初始化为1。<br>当遇到与cand_num相同的数，则票数count = count + 1，否则票数count = count - 1。<br>当票数count为0时，更换候选人，并将票数count重置为1。<br>遍历完数组后，cand_num即为最终答案。</p><p>为何这行得通呢？<br>投票法是遇到相同的则票数 + 1，遇到不同的则票数 - 1。<br>且“多数元素”的个数> ⌊ n/2 ⌋，其余元素的个数总和<= ⌊ n/2 ⌋。<br>因此“多数元素”的个数 - 其余元素的个数总和 的结果 肯定 >= 1。<br>这就相当于每个“多数元素”和其他元素 两两相互抵消，抵消到最后肯定还剩余至少1个“多数元素”。</p><p>无论数组是1 2 1 2 1，亦或是1 2 2 1 1，总能得到正确的候选人。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> cand_num = nums[<span class="number">0</span>], count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < nums.length; ++i) {</span><br><span class="line">            <span class="keyword">if</span> (cand_num == nums[i])</span><br><span class="line">                ++count;</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (--count == <span class="number">0</span>) {</span><br><span class="line">                    cand_num = nums[i];</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cand_num;</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1071-字符串的最大公因子</title>
      <link href="/2020/03/12/1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/"/>
      <url>/2020/03/12/1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。</p><p>返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。</p><p> 示例 1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：str1 = <span class="string">"ABCABC"</span>, str2 = <span class="string">"ABC"</span></span><br><span class="line">输出：<span class="string">"ABC"</span></span><br></pre></td></tr></tbody></table></figure></div><p>示例 2：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：str1 = <span class="string">"ABABAB"</span>, str2 = <span class="string">"ABAB"</span></span><br><span class="line">输出：<span class="string">"AB"</span></span><br></pre></td></tr></tbody></table></figure></div><p>示例 3：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：str1 = <span class="string">"LEET"</span>, str2 = <span class="string">"CODE"</span></span><br><span class="line">输出：<span class="string">""</span></span><br></pre></td></tr></tbody></table></figure></div><p>思路：</p><p>如果它们有公因子 abc，那么 str1 就是 m 个 abc 的重复，str2 是 n 个 abc 的重复，连起来就是 m+n 个 abc，好像 m+n 个 abc 跟 n+m 个 abc 是一样的。</p><p>所以如果 str1 + str2 === str2 + str1 就意味着有解。</p><p>我们也很容易想到<strong>（其实需要严格的数学证明）</strong> str1 + str2 !== str2 + str1 也是无解的充要条件。</p><p>当确定有解的情况下，最优解是长度为 gcd(str1.length, str2.length) 的字符串。</p><p><strong>因为如果能循环以它的约数为长度的字符串，自然也能够循环以它为长度的字符串，所以这个理论长度就是我们要找的最优解。</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>{</span><br><span class="line">     <span class="keyword">if</span>(!(str1 + str2).equals(str2 + str1))</span><br><span class="line">       <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">     <span class="keyword">return</span> str1.substring(<span class="number">0</span>, gcd(str1.length(), str2.length()));</span><br><span class="line">  }</span><br><span class="line"><span class="comment">//辗转相除法求最大公因数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>{</span><br><span class="line">     <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a%b);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串比较</title>
      <link href="/2020/03/12/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/"/>
      <url>/2020/03/12/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="equals-与"><a href="#equals-与" class="headerlink" title="equals() 与 =="></a>equals() 与 ==</h4><p>关于字符串比较用equals还是用==,总结一下</p><p>字符串为对象:</p><p><strong>1.”==”</strong></p><p>所有”对象变量”用==作比较时比的是两个对象在堆中的引用.</p><p><strong>2.”equals()”</strong></p><p>所有对象的equals方法继承自Object类的方法,而String重写了equals方法的比较算法,它比较的是字符串的内容,即在堆中的了符序列</p><p><strong>3.特点</strong></p><p>字符串是一种比较特殊的对象,这里的特殊指的是在运行期间,它的赋值直接改变引用(当然,任何对象的赋值都是直接改变的引用,只不过字符串这种东西往往让人容易理解为它是在原来的基础上操作的,尤其是+=这类操作),而不是在原来所引用的内存块中做修改.(因此有了StringBuffer类的出现)</p><p><strong>结论:</strong></p><p>1.</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">String s2 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);    <span class="comment">//true</span></span><br></pre></td></tr></tbody></table></figure></div><p>按照上面的说法,第一个true不难理解.</p><p>而第2个之所以也为true是因为,java编译器用的类似于C语言中的”文字池机制”,即在源代码中所有的字符串常量声明全部放在一块内存区域,因此当一个字符串声明时赋值的是一个字符串常量,那么如果”文字池”中有这个字符串常量,编译器将直接把它的引用赋值给这个变量.</p><p>因此在用==来比较s1和s2时,将会得到true.</p><p>2.</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">String s2 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">s1 = s1 + <span class="string">"a"</span>;</span><br><span class="line"></span><br><span class="line">s2 = s2 + <span class="string">"a"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);    <span class="comment">//false</span></span><br></pre></td></tr></tbody></table></figure></div><p>第3,4行的赋值操作在运行期间执行,根据上面的知识点3:两个变量的引用将会发生改变.因此这时用==相比时将会得到false;</p><p>(在运行期间所得到的字符串内容,将不会放到所谓的”文字池”之中,然后如果有相同内容的变量引用相同内容,这样作的话需要每次字符串改变时需要检查它的内容,并再在文字池中查找看是否有相同内容的常量,太过浪费效率.)</p><p>(“文字池机制”也许也是为什么字符串对象在作更改时,直接改变引用的一个原因,因为如果直接对引用的内存块作操作的话,另一个指向相同引用的字符串变量将也会发什么改变,发生逻辑混淆)</p><p>3.</p><p>代码略.</p><p>当字符串对象从不同地方(字符串常量;本地资源文件读取;网络传输:如表单提交;等等)获得时:除了是编译期间用相同常量赋值的字符串变量的引用相同外,其它的全部是新的引用.因此,与这种变量直接用==相比时将得到false,即使内容相同</p><p><strong>应用结论:</strong></p><p>1.如果是单纯的比较字符串内容的话:用equals()</p><p>2.如果确实是要比较两个变量的引用的话:用==</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Servlet总结</title>
      <link href="/2020/03/11/Servlet%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/11/Servlet%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>写Servlet可以实现Servlet接口，但是需要重写5个方法。继承HttpServlet会更方便。</p><h4 id="Servlet生命周期可分为5个步骤"><a href="#Servlet生命周期可分为5个步骤" class="headerlink" title="Servlet生命周期可分为5个步骤"></a>Servlet生命周期可分为5个步骤</h4><ol><li><strong>加载Servlet</strong>。当Tomcat第一次访问Servlet的时候，<strong>Tomcat会负责创建Servlet的实例</strong></li><li><strong>初始化</strong>。当Servlet被实例化后，Tomcat会<strong>调用init()方法初始化这个对象</strong></li><li><strong>处理服务</strong>。当浏览器<strong>访问Servlet</strong>的时候，Servlet <strong>会调用service()方法处理请求</strong></li><li><strong>销毁</strong>。当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，<strong>让该实例释放掉所占的资源</strong>。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁</li><li><strong>卸载</strong>。当Servlet调用完destroy()方法后，等待垃圾回收。如果<strong>有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作</strong>。</li></ol><ul><li><p>简单总结：<strong>只要访问Servlet，service()就会被调用。init()只有第一次访问Servlet的时候才会被调用。</strong></p><p>destroy()只有在Tomcat关闭的时候才会被调用。</p></li></ul><h4 id="Servlet的细节"><a href="#Servlet的细节" class="headerlink" title="Servlet的细节"></a>Servlet的细节</h4><ol><li>一个已经被注册的servlet可以被映射多次</li><li>映射的URL可以使用通配符</li></ol><h4 id="Servlet是单例的"><a href="#Servlet是单例的" class="headerlink" title="Servlet是单例的"></a>Servlet是单例的</h4><ul><li>为什么是单例的？<strong>浏览器多次对Servlet的请求</strong>，一般情况下，<strong>服务器只创建一个Servlet对象</strong>，也就是说，Servlet对象<strong>一旦创建了</strong>，就会<strong>驻留在内存中，为后续的请求做服务，直到服务器关闭</strong>。</li><li>每次访问请求对象和响应对象都是新的。对于<strong>每次访问请求</strong>，Servlet引擎都会<strong>创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象</strong>，然后将这两<strong>个对象作为参数传递给它调用的Servlet的service()方法</strong>，<strong>service方法再根据请求方式分别调用doXXX方法</strong>。</li></ul><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><p>当多个用户访问Servlet的时候，<strong>服务器会为每个用户创建一个线程</strong>。<strong>当多个用户并发访问Servlet共享资源的时候就会出现线程安全问题</strong>。</p><p>原则：</p><ol><li>如果一个<strong>变量需要多个用户共享</strong>，则应当在访问该变量的时候，<strong>加同步机制synchronized (对象){}</strong></li><li>如果一个变量<strong>不需要共享</strong>，则<strong>直接在 doGet() 或者 doPost()定义</strong>.这样不会存在线程安全问题</li></ol><h4 id="load-on-startup"><a href="#load-on-startup" class="headerlink" title="load-on-startup"></a>load-on-startup</h4><p>如果在<servlet>元素中配置了一个<load-on-startup>元素，那么<strong>WEB应用程序在启动时</strong>，就会<strong>装载并创建Servlet的实例对象</strong>、以及<strong>调用Servlet实例对象的init()方法</strong>。</load-on-startup></servlet></p><p>作用：</p><ol><li>为web应用写一个InitServlet，这个<strong>servlet配置为启动时装载</strong>，为整个web应用<strong>创建必要的数据库表和数据</strong></li><li>完成一些定时的任务【定时写日志，定时备份数据】</li></ol><h4 id="ServletConfig对象有什么用？"><a href="#ServletConfig对象有什么用？" class="headerlink" title="ServletConfig对象有什么用？"></a>ServletConfig对象有什么用？</h4><blockquote><p>通过此对象可以读取web.xml中配置的初始化参数。</p></blockquote><p>现在问题来了，<strong>为什么我们要把参数信息放到web.xml文件中呢</strong>？我们可以直接在程序中都可以定义参数信息，<strong>搞到web.xml文件中又有什么好处呢</strong>？</p><p>好处就是：<strong>能够让你的程序更加灵活</strong>【更换需求，更改配置文件web.xml即可，程序代码不用改】</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1013-将数组分成和相等的三个部分</title>
      <link href="/2020/03/11/1013-%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86/"/>
      <url>/2020/03/11/1013-%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给你一个整数数组 <code>A</code>，只有可以将其划分为三个和相等的非空部分时才返回 <code>true</code>，否则返回 <code>false</code>。</p><p>示例 1：</p><p>输出：[0,2,1,-6,6,-7,9,1,2,0,1]<br>输出：true<br>解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1</p><p>示例 2：</p><p>输入：[0,2,1,-6,6,7,9,-1,2,0,1]<br>输出：false</p><p>示例 3：</p><p>输入：[3,3,6,5,-2,2,5,1,-9,4]<br>输出：true<br>解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4</p><p>思路：一开始准备直接找，现求和，然后求三等分的值，但是发现有很多特殊情况忘记考虑了，比如和可能为0，前面已经加和到三等分值的时候，是否要从这里分，越想越乱越复杂，其实实际上，直接找的话，依次遍历，加和到三等分就记录一次，正常会记录到3次，有种特殊情况[1,-1,1,-1,1,-1,1,-1]是4次，但小于2次的肯定不满足。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">        <span class="comment">//求和，求三等分</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < A.length; i++)</span><br><span class="line">            sum += A[i]; </span><br><span class="line">      <span class="comment">//如果不是3的倍数</span></span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">3</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//依次遍历</span></span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j < A.length; j++){</span><br><span class="line">            tmp += A[j]; </span><br><span class="line">            <span class="keyword">if</span>(tmp == sum/<span class="number">3</span>){</span><br><span class="line">                tmp = <span class="number">0</span>;</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count >= <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>双指针解法：</p><p>前后两个指针left，right同时向中间靠，如果left左边和为sum/3，并且right右边和也为sum/3了，说明符合条件。如果left与right相遇，说明不符合条件。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">        <span class="comment">//求和，求三等分</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < A.length; i++)</span><br><span class="line">            sum += A[i]; </span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">3</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftSum = A[left];</span><br><span class="line">        <span class="keyword">int</span> right = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightSum = A[right];</span><br><span class="line">      <span class="comment">//如果左右指针还没有相遇</span></span><br><span class="line">        <span class="keyword">while</span>(right - left > <span class="number">1</span>){</span><br><span class="line">            <span class="comment">//如果找到了</span></span><br><span class="line">            <span class="keyword">if</span>(leftSum == sum/<span class="number">3</span> && rightSum == sum/<span class="number">3</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//向中间靠</span></span><br><span class="line">            <span class="keyword">if</span>(leftSum != sum/<span class="number">3</span>){</span><br><span class="line">                left++;</span><br><span class="line">                leftSum += A[left]; </span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(rightSum != sum/<span class="number">3</span>){</span><br><span class="line">                right--;</span><br><span class="line">                rightSum += A[right]; </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">      <span class="comment">//指针相遇还未找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>眼疲劳的解决方法</title>
      <link href="/2020/03/11/%E7%9C%BC%E7%96%B2%E5%8A%B3%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2020/03/11/%E7%9C%BC%E7%96%B2%E5%8A%B3%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>长期习惯：</p><p>一，减少使用手机的时间。早上起来的第一个小时不碰手机，睡前1小时不碰手机，不在黑暗的环境下看手机。</p><p>二，提高眨眼频率。</p><p>三，每看屏幕二十分钟，挺胸抬头转转脖子，闭目或者远眺20秒。</p><p>短期缓解：</p><p>热毛巾敷眼10分钟。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 健康 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>543-二叉树的直径</title>
      <link href="/2020/03/10/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
      <url>/2020/03/10/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p><p>示例 :<br>给定二叉树</p><pre><code>    1   / \  2   3 / \     4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p><p>思路：这题比较容易出错的地方是，误以为必须要经过根结点。</p><p>深度优先遍历计算深度，然后在遍历的过程中，计算以每一个为“根结点”的最长路径，更新最大值。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) { val = x; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//深度优先遍历，过程中更新“二叉树的直径”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = dfs(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = dfs(root.right);</span><br><span class="line">        res = Math.max(res, left + right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程</title>
      <link href="/2020/03/09/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/03/09/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="创建多线程有3种方式"><a href="#创建多线程有3种方式" class="headerlink" title="创建多线程有3种方式"></a>创建多线程有3种方式</h4><ol><li>继承线程类Thread</li><li>实现Runnable接口</li><li>匿名类</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread t1= <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">                             </span><br><span class="line">            }</span><br><span class="line">        };</span><br></pre></td></tr></tbody></table></figure></div><p>注意：启动线程是start()方法，run()并不能启动一个新的线程</p><h4 id="常见线程方法"><a href="#常见线程方法" class="headerlink" title="常见线程方法"></a>常见线程方法</h4><ol><li>sleep 当前线程暂停</li><li>join 加入到当前线程。主线程会等待该线程结束完毕， 才会往下运行。</li><li>setPriority 设置优先级。优先级高的线程会有更大的几率获得CPU资源。</li><li>yield 临时暂停</li><li>setDaemon 设为守护线程。守护线程的概念是：当一个进程里，所有的线程都是守护线程的时候，结束当前进程。</li></ol><h4 id="多线程的同步问题"><a href="#多线程的同步问题" class="headerlink" title="多线程的同步问题"></a>多线程的同步问题</h4><p>多个线程同时修改一个数据的时候，可能导致的问题。</p><p>解决方式：synchronized同步对象</p><p>synchronized表示当前线程独占某个对象，如果其他线程试图占有对象，就会等待，直到当前线程释放该对象。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121-买卖股票的最佳时机</title>
      <link href="/2020/03/09/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2020/03/09/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p>示例 1:</p><p>输入: [7,1,5,3,6,4]</p><p>输出: 5</p><p>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</p><p>​     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p><p>示例 2:</p><p>输入: [7,6,4,3,1]</p><p>输出: 0</p><p>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p>方法一：暴力枚举</p><p>使用两个变量 i 和 j ，它们分别表示买进这支股票和卖出这支股票，枚举它们在价格数组上可能出现的所有位置。编码很简单，写一个二重循环即可。</p><p>参考代码 1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len < <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有可能不做交易，因此结果的初始值设置为 0 </span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < len - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j < len; j++) {</span><br><span class="line">                res = Math.max(res, prices[j] - prices[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>复杂度分析：</p><p>时间复杂度：O(N^2)，这里 N 是股价数组的长度；</p><p>空间复杂度：O(1)</p><p>复杂度较高，提交到 LeetCode 以后排名稍微靠后。</p><p>方法二：针对暴力枚举的优化</p><p>我们发现：其实只需要关心之前（不包括现在）看到的最低股价，于是在遍历的过程中，记录下之前看到的最低股价，就可以省去内层循环。</p><p>参考代码 2：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len < <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 表示在当前位置之前的最小值，假设修正法（打擂台法）</span></span><br><span class="line">        <span class="keyword">int</span> minVal = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 注意：这里从 1 开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < len; i++) {</span><br><span class="line">            res = Math.max(res, prices[i] - minVal);</span><br><span class="line">            minVal = Math.min(minVal, prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>复杂度分析：</p><p>时间复杂度：O(N)</p><p>空间复杂度：O(1)</p><p>方法三：动态规划</p><p>动态规划的 5 个步骤：</p><p>1、设定状态</p><p>这道题其实是一个典型的二维 dp 问题。“动态规划”用于多阶段最优化问题的求解。这里天数代表每个阶段，即一天一天看，设置为第一维。为了消除后效性（前面的状态确定下来以后不会因为后面状态而更改），将当天是否持股设置为第二维的状态。于是：</p><p>状态 dp[i][j] 表示：在索引为 i 的这一天，用户手上持股状态为 j 所获得的最大利润。</p><p>说明：</p><p>j 只有 2 个值：0 表示不持股（特指卖出股票以后的不持股状态），1 表示持股。</p><p>“用户手上不持股”不代表用户一定在索引为 i 的这一天把股票抛售了；</p><p>2、思考状态转移方程</p><p>dp[i][0] 怎样转移？</p><p>dp[i - 1][0] ：当然可以从昨天不持股转移过来，表示从昨天到今天什么都不操作，这一点是显然的；</p><p>dp[i - 1][1] + prices[i]：昨天持股，就在索引为 i 的这一天，我卖出了股票，状态由 1 变成了 0，此时卖出股票，因此加上这一天的股价。</p><p>综上：dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);</p><p>dp[i][1] 怎样转移？</p><p>dp[i - 1][1] ：昨天持股，今天什么都不操作，当然可以从昨天持股转移过来，这一点是显然的；</p><p>-prices[i]：注意：状态 1 不能由状态 0 来，因为事实上，状态 0 特指：“卖出股票以后不持有股票的状态”，请注意这个状态和“没有进行过任何一次交易的不持有股票的状态”的区别。</p><p>因此，-prices[i] 就表示，在索引为 i 的这一天，执行买入操作得到的收益。注意：因为题目只允许一次交易，因此不能加上 dp[i - 1][0]。</p><p>综上：dp[i][1] = max(dp[i - 1][1], -prices[i]);</p><p>3、考虑初始值</p><p>第 0 天不持股，显然 dp[0][0] = 0；</p><p>第 0 天持股，显然dp[0][1] = -prices[0]。</p><p>4、考虑输出</p><p>从状态转移方程可以看出，每一天的状态都考虑了之前的状态。在只发生一次交易的情况下，持有这支股票一定不能使我们获得最大利润。因此输出是 dp[len - 1][0]，不可能是持股的状态 dp[len - 1][1]，</p><p>参考代码 3：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len < <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0：用户手上不持股所能获得的最大利润，特指卖出股票以后的不持股，非指没有进行过任何交易的不持股</span></span><br><span class="line">        <span class="comment">// 1：用户手上持股所能获得的最大利润</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：因为题目限制只能交易一次，因此状态只可能从 1 到 0，不可能从 0 到 1</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < len; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>复杂度分析：</p><p>时间复杂度：O(N)</p><p>空间复杂度：O(N)</p><p>说明：如果我们一定要区分“不持有股票”的状态是“一开始不持有”和“卖出股票以后的不持有”，设置 3 个状态即可，我个人认为更加清晰。</p><p>下面状态的设置和状态转移方程均写在代码注释中：</p><p>参考代码 4：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len < <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0：不进行任何操作</span></span><br><span class="line">        <span class="comment">// 1：用户执行了一次买入操作</span></span><br><span class="line">        <span class="comment">// 2：用户执行了一次卖出操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态转移方程：</span></span><br><span class="line">        <span class="comment">// dp[i][0] 永远等于 0</span></span><br><span class="line">        <span class="comment">// dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])</span></span><br><span class="line">        <span class="comment">// dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：如果是 `[7, 6, 5, 4, 3]` 这种波动，应该不交易，</span></span><br><span class="line">        <span class="comment">// 因此输出是：max(dp[len - 1][0], dp[len - 1][2])</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 这里状态 2 不应该有值，设置为 0 不影响正确性</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < len; i++) {</span><br><span class="line">            <span class="comment">// 可以不显式赋值，因为 int 的初值就是 0</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[len - <span class="number">1</span>][<span class="number">0</span>], dp[len - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>复杂度分析：</p><p>时间复杂度：O(N)</p><p>空间复杂度：O(N)</p><p>说明：事实上，这一版代码，由于 dp[i][0] = 0 恒成立，和“参考代码 3”其实是等价的。</p><p>由于 dp[i] 仅仅依赖于 dp[i - 1] ，因此，我们可以使用滚动数组的技巧压缩变量。下面根据“参考代码 3”进行修改：</p><p>参考代码 5：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len < <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < len; i++) {</span><br><span class="line">            dp[i & <span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[(i - <span class="number">1</span>) & <span class="number">1</span>][<span class="number">0</span>], dp[(i - <span class="number">1</span>) & <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i & <span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[(i - <span class="number">1</span>) & <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[(len - <span class="number">1</span>) & <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>复杂度分析：</p><p>时间复杂度：O(N)</p><p>空间复杂度：O(1)，状态压缩以后相当于只用了 4 个变量。</p><p>我们继续观察“参考代码 3”，因为状态只能从 1 到 0，即先有状态 1 再有状态 0，我们在填写“状态表 dp” 的时候，只需要用 1 维，因此填表的时候，先写 0 再写 1 即可。</p><p>参考代码 6：（根据“参考代码 3”进行修改）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len < <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < len; i++) {</span><br><span class="line">            dp[<span class="number">0</span>] = Math.max(dp[<span class="number">0</span>], dp[<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[<span class="number">1</span>] = Math.max(dp[<span class="number">1</span>], -prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>复杂度分析：</p><p>时间复杂度：O(N)O(N)；</p><p>空间复杂度：O(1)O(1)，状态压缩以后相当于只用了 22 个变量。</p><p>很有意思的是，可以将此时的数组 dp 语义化，dp[1] = Math.max(dp[1], -prices[i]); 等价于 dp[1] = Math.min(dp[1], prices[i]); 其实就是“参考代码 2” 中的 minVal，dp[0] 等价于 “参考代码 2” 中的 res。</p><p>方法四：使用差分数组（参考）</p><p>因为我们关注股票的变化，因此明天减去今天的差价在一定程度上是有研究价值的。我们使用数组 diff 表示差分数组。</p><p>说明：差分 diff 是 difference 的缩写。</p><p>差分数组是这样得到的：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] diff = <span class="keyword">new</span> <span class="keyword">int</span>[len - <span class="number">1</span>]; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < len - <span class="number">1</span>; i++) {</span><br><span class="line">diff[i] = prices[i + <span class="number">1</span>] - prices[i]; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>那么：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff[<span class="number">2</span>] + diff[<span class="number">1</span>] = prices[<span class="number">3</span>] - prices[<span class="number">2</span>] + (prices[<span class="number">2</span>] - prices[<span class="number">1</span>]) =  prices[<span class="number">3</span>] - prices[<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure></div><p>我们再多写几个：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff[<span class="number">3</span>] + diff[<span class="number">2</span>] + diff[<span class="number">1</span>] = (diff[<span class="number">4</span>] - diff[<span class="number">3</span>]) + (prices[<span class="number">3</span>] - prices[<span class="number">2</span>]) + (prices[<span class="number">2</span>] - prices[<span class="number">1</span>]) =  prices[<span class="number">4</span>] - prices[<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure></div><p>我们发现：差分数组的连续子区间和的值，就正好是原始股价数组进行一次交易的差价（后 - 前）。因此，我们可以在差分数组上，求“最大连续子序列的和”，这里参考了「力扣」第 53 题：“最大子序和” 的做法。</p><p>参考代码 7：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len < <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 差分数组比原始数组的长度少 1</span></span><br><span class="line">        <span class="keyword">int</span>[] diff = <span class="keyword">new</span> <span class="keyword">int</span>[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < len - <span class="number">1</span>; i++) {</span><br><span class="line">            diff[i] = prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i] 以 diff[i] 结尾的子序列的和的最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len - <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < len - <span class="number">1</span>; i++) {</span><br><span class="line">            dp[i] = Math.max(diff[i], dp[i - <span class="number">1</span>] + diff[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还是要考虑到 [7 , 6, 5, 4, 3] 这种不交易的情况</span></span><br><span class="line">        <span class="comment">// 初值应该赋值成 0</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < len - <span class="number">1</span>; i++) {</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>复杂度分析：</p><p>时间复杂度：O(N)</p><p>空间复杂度：O(N)</p></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>322-零钱兑换</title>
      <link href="/2020/03/08/322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
      <url>/2020/03/08/322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> coins = [1, 2, 5], amount = 11 <strong>输出:</strong> 3  <strong>解释:</strong> 11 = 5 + 5 + 1</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> coins = [2], amount = 3 <strong>输出:</strong> -1</p><p><strong>说明</strong>:</p><p>你可以认为每种硬币的数量是无限的。</p><p>动态规划自顶向下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (amount < <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//用数组保存已经计算过的结果（剪枝）</span></span><br><span class="line">        <span class="keyword">return</span> coinChange(coins, amount, <span class="keyword">new</span> <span class="keyword">int</span>[amount]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount, <span class="keyword">int</span>[] count)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (amount < <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(count[amount-<span class="number">1</span>] !=<span class="number">0</span> ) <span class="keyword">return</span> count[amount-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//每次拿一种一个硬币</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins){</span><br><span class="line">            <span class="keyword">int</span> res = coinChange(coins, amount-coin, count);</span><br><span class="line">            <span class="keyword">if</span>(res >= <span class="number">0</span> && min > res)</span><br><span class="line">                min = res;</span><br><span class="line">        }</span><br><span class="line">        count[amount-<span class="number">1</span>] = (min == Integer.MAX_VALUE) ? -<span class="number">1</span> : min + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> count[amount-<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>动态规划-自底向上：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>{</span><br><span class="line">        <span class="comment">//数量最大是amount，当硬币金额都为1的时候</span></span><br><span class="line">        <span class="keyword">int</span> max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//dp[i]表示总金额为i的结果</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, max);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//逐个计算dp[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i <= amount; i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j < coins.length; j++){</span><br><span class="line">                <span class="keyword">if</span>(coins[j] <= i)</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i-coins[j]]+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[amount] > amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java_Deque用法</title>
      <link href="/2020/03/07/Java-Deque%E7%94%A8%E6%B3%95/"/>
      <url>/2020/03/07/Java-Deque%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>​    Deque(Double ended queue)是一种线性集合，其允许在集合两端进行数据的插入和删除操作。大多数的Deque实现没有确定的可保存元素数目，但是在本接口中，仍然提供了对容量限制型的队列的支持。本接口中提供了可以双向访问队列中元素的方法，与基本队列Queue类似，其提供的方法在执行失败时均存在两种处理形式：抛出异常或者返回一个特殊值(一般为null或者false)。其中第二中形式的插入操作是为有容量限制的Deque实现设计，而一般情况下，插入操作不会出现失败的情况。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双端队列 </tag>
            
            <tag> 集合框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-队列的最大值</title>
      <link href="/2020/03/07/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/2020/03/07/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><p>注意队列的头和尾（左边是尾，右边是头）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Deque<integer> queue;</integer></span><br><span class="line">    <span class="keyword">private</span> Deque<integer> help;</integer></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        queue = <span class="keyword">new</span> ArrayDeque<>();</span><br><span class="line">        help = <span class="keyword">new</span> ArrayDeque<>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty() ? -<span class="number">1</span> : help.peekFirst();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//进栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        queue.offerLast(value);</span><br><span class="line">        <span class="keyword">while</span>(!help.isEmpty() && value > help.peekLast()){</span><br><span class="line">            help.pollLast();</span><br><span class="line">        }</span><br><span class="line">        help.offerLast(value);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(queue.isEmpty()){</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> val = queue.pollFirst();</span><br><span class="line">        <span class="keyword">if</span>(help.peekFirst() == val){</span><br><span class="line">            help.pollFirst();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.max_value();</span></span><br><span class="line"><span class="comment"> * obj.push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双端队列 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
