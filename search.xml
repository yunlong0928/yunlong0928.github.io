<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>3-从尾到头打印链表</title>
      <link href="/2020/04/12/3-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/04/12/3-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><p>思路：有两种思路，第一是利用栈先入后出的特性完成，第二是利用递归。</p><p>堆栈实现：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList<integer> <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </integer></span>{</span><br><span class="line">        Stack<integer> stack = <span class="keyword">new</span> Stack<>();</integer></span><br><span class="line">        <span class="comment">//入栈</span></span><br><span class="line">        <span class="keyword">while</span>(listNode != <span class="keyword">null</span>){</span><br><span class="line">            stack.push(listNode.val);</span><br><span class="line">            listNode = listNode.next;</span><br><span class="line">        }</span><br><span class="line">        ArrayList<integer> arr = <span class="keyword">new</span> ArrayList<integer>();</integer></integer></span><br><span class="line">        <span class="comment">//出栈</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())</span><br><span class="line">            arr.add(stack.pop());</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>递归实现：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    ArrayList<integer> arr = <span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList<integer> <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </integer></span>{</span><br><span class="line">        <span class="keyword">if</span>(listNode != <span class="keyword">null</span>){</span><br><span class="line">            <span class="comment">//需要好好理解这个逻辑</span></span><br><span class="line">            printListFromTailToHead(listNode.next);</span><br><span class="line">            arr.add(listNode.val);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大数据学习方法</title>
      <link href="/2020/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
      <url>/2020/04/12/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>学习应该是理论和项目交叉来的。抓重点。</p><ul><li>数仓：学完Hadoop和Hive就可以看项目，看第一遍之后至少里面的hql能看懂，但涉及到的建模，脚本这些看不懂。接着就可以去看关于数仓建模以及数据仓库的一些知识点，另外可以学习下shell。数仓项目里面可能还有Sqoop，Kettle什么的，这种属于小框架和工具，遇到的时候去搜下它是什么就可以了。</li><li>实时：学完Spark或Flink，就可以开搞，如果涉及到Kafka和Flume也可以仅做了解。然后就开始看项目，第一遍看不懂很正常，看第二遍，第二遍你就知道你哪里看不懂了，把项目按阶段切开，去网上搜相关的Demo，网上的Demo大都通俗易懂，然后自己整理一下拼凑在项目里。</li><li>学完之后写简历，开始雕刻，业务场景怎么写，负责的内容怎么写，项目的流程怎么描述，开发过程是什么，数据量机器多少合适，有没有难点，框架怎么配置等等…前面学习的内容可能不会很多，但后面雕刻这部分是比较难的。可以借助外力，去网上找面经往自己的项目上套，去网上看技术难点往自己项目上套。搞完项目就剩项目框架的一些底层原理了，这个资料就更多了。</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>dubbo学习记录</title>
      <link href="/2020/04/11/dubbo%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/04/11/dubbo%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>为什么要用Dubbo？无dubbo情况下，RPC普遍存在的问题：</p><ol><li>rpc调用需要定制开发，很多额外的工作量</li><li><strong>分布式服务中，服务达到几百上千时，相互之间的调用错综复杂，相互依赖严重</strong></li><li>对集群性的服务，需要负载策略</li><li>对集群性的服务，需要能动态扩展节点</li></ol><p>dubbo介绍：<br>1，一个分布式、高性能、透明化的RPC服务框架。<br>2，提供服务自动注册、自动发现等高效服务治理方案。<br>3，其功能主要包括：高性能NIO通讯及多协议集成，服务动态寻址与路由，软负载均衡与容错，依赖分析与降级等。</p><p>dubbo架构流程：</p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200411164957620.png" data-fancybox="group" data-caption="image-20200411164957620" class="fancybox"><img alt="image-20200411164957620" style="zoom:50%;" title="image-20200411164957620" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200411164957620.png" class="lazyload"></a><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200411175008866.png" data-fancybox="group" data-caption="image-20200411175008866" class="fancybox"><img alt="image-20200411175008866" title="image-20200411175008866" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200411175008866.png" class="lazyload"></a></p><ol><li>container负责启动、加载、运行provider</li><li>provider启动时，向registry注册自己的服务<strong>(生产者注册服务)</strong></li><li>cousumer启动时，向registry订阅自己的服务<strong>（消费者订阅服务）</strong></li><li>registry提供provider列表给consumer，实时推送变动情况<strong>（注册中心提供能提供对应服务的服务器列表，并实时更新）</strong></li><li>consumer根据provider列表，按负载算法选一台provider调用（<strong>消费者选择调用哪台机器的服务，软负载均衡）</strong></li><li>monitor统计rpc的调用频次</li></ol></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2-顺时针打印矩阵</title>
      <link href="/2020/04/11/2-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
      <url>/2020/04/11/2-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10</p><p>思路：</p><ol><li><p>常规思路。用标记数组记录是否被访问，按右下左上右…的循环前进，遇到拐角处（下个位置已被访问或者越界）转换方向。边界处理有些麻烦。</p></li><li><p>比常规思路清晰一些。用一个剥圈函数，这个函数的核心就是 <strong>左上点和右下点</strong> 每次走完剥圈函数之后 左上角坐标++，右下角– 往圈内移。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    ArrayList  a=<span class="keyword">new</span> ArrayList(); <span class="comment">//  new一个数组 以便下面函数能调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tX=<span class="number">0</span>;<span class="comment">//左上x坐标</span></span><br><span class="line">        <span class="keyword">int</span> tY=<span class="number">0</span>;<span class="comment">//左上y坐标</span></span><br><span class="line">        <span class="keyword">int</span> dX=matrix.length-<span class="number">1</span>;<span class="comment">//右下x坐标</span></span><br><span class="line">        <span class="keyword">int</span> dY=matrix[<span class="number">0</span>].length-<span class="number">1</span>;<span class="comment">//右下y坐标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(tX<=dX&&tY<=dY){ <span class="comment">//左上边界最多到达右下边界 用于判断是否还是剥圈打印</span></span><br><span class="line">            printEdge(matrix,tX,tY,dX,dY);</span><br><span class="line">            tX++;</span><br><span class="line">            tY++;</span><br><span class="line">            dX--;</span><br><span class="line">            dY--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">printEdge</span><span class="params">(<span class="keyword">int</span> [][] m,<span class="keyword">int</span> tX,<span class="keyword">int</span> tY,<span class="keyword">int</span> dX,<span class="keyword">int</span> dY)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(tX==dX){    <span class="comment">//先判断是否只是一横行 如果是 打印该横行的列（通常用于内圈）</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=tY;i<=dY;i++){</span><br><span class="line">                a.add(m[tX][i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tY==dY){  <span class="comment">//再判断是否只是一竖列 如果是 打印该横行的列（通常用于内圈</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=tX;i<=dX;i++){</span><br><span class="line">                a.add(m[i][tY]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">int</span> curY=tY;<span class="comment">//用2个变量储存 用于判断当前位置</span></span><br><span class="line">            <span class="keyword">int</span> curX=tX;</span><br><span class="line">            <span class="keyword">while</span>(curY!=dY){      <span class="comment">//当前位置未到达当前行的最右列 --》往右去</span></span><br><span class="line">                a.add(m[tX][curY]);</span><br><span class="line">                curY++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(curX!=dX){      <span class="comment">//当前位置未到达当前列的最底行 --》往下去</span></span><br><span class="line">                a.add(m[curX][dY]);</span><br><span class="line">                curX++;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(curY!=tY){      <span class="comment">//当前位置未到达当前行的最左列 --》往左去</span></span><br><span class="line">                a.add(m[dX][curY]);</span><br><span class="line">                curY--;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">while</span>(curX!=tX){      <span class="comment">//当前位置未到达当前列的最顶行 --》往上去</span></span><br><span class="line">                a.add(m[curX][tY]);</span><br><span class="line">                curX--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li></ol><ol start="3"><li><p>最清晰的思路。模拟设定边界。<a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200411112605399.png" data-fancybox="group" data-caption="image-20200411112605399" class="fancybox"><img alt="image-20200411112605399" title="image-20200411112605399" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200411112605399.png" class="lazyload"></a>)<a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200411112652380.png" data-fancybox="group" data-caption="image-20200411112652380" class="fancybox"><img alt="image-20200411112652380" title="image-20200411112652380" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200411112652380.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix) {</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[(r + <span class="number">1</span>) * (b + <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) {</span><br><span class="line">          <span class="comment">// 从左到右，依靠上边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i <= r; i++) res[x++] = matrix[t][i]; </span><br><span class="line">            <span class="keyword">if</span>(++t > b) <span class="keyword">break</span>;<span class="comment">//每次走完一个方向，向内收缩边界，并判断是否打印完毕</span></span><br><span class="line">          <span class="comment">// 从上到下，依靠右边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i <= b; i++) res[x++] = matrix[i][r];</span><br><span class="line">            <span class="keyword">if</span>(l > --r) <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 从右到左，依靠下边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i >= l; i--) res[x++] = matrix[b][i];</span><br><span class="line">            <span class="keyword">if</span>(t > --b) <span class="keyword">break</span>;</span><br><span class="line">          <span class="comment">// 从下到上，依靠左边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = b; i >= t; i--) res[x++] = matrix[i][l];</span><br><span class="line">            <span class="keyword">if</span>(++l > r) <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li></ol></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1-包含min函数的栈</title>
      <link href="/2020/04/10/1-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
      <url>/2020/04/10/1-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p><strong>题目描述</strong></p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><p><strong>思路：</strong>普通栈的 push() 和 pop() 函数的复杂度为 O(1) ，而获取栈最小值min() 函数需要遍历整个栈，复杂度为 O(N)。这道题的难点是将 min() 函数复杂度降为 O(1)，可通过建立辅助栈实现。</p><p>数据栈 A ： 用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。<br>辅助栈 B ： 用于存储栈 A 中所有<strong>非严格降序</strong>的元素，则栈 A 中的最小元素始终对应栈 BB的栈顶元素，即 min() 函数只需返回栈 B 的栈顶元素即可。</p><p>因此，只需设法维护好 栈 B<em>B</em> 的元素，使其保持非严格降序，即可实现 min() 函数的O(1)复杂度。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200410112503218.png" data-fancybox="group" data-caption="image-20200410112503218" class="fancybox"><img alt="image-20200410112503218" title="image-20200410112503218" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200410112503218.png" class="lazyload"></a></p><p>函数设计：<br><strong>push(x) 函数</strong>： 重点是保持栈 B 的元素是 <strong>非严格降序</strong> 的。</p><p>将 x 压入栈 A （即 A.add(x) ）；<br>若 ① 栈 B 为空 或 ② x 小于等于 栈 B 的栈顶元素，则将 x 压入栈 B<br><strong>pop() 函数</strong>： 重点是保持栈 A, B的元素一致性 。</p><p>执行栈 A 出栈，将出栈元素记为 y ；<br>若 y 等于栈 B 的栈顶元素，则执行栈 B 出栈<br><strong>top() 函数</strong>： 直接返回栈 A 的栈顶元素即可</p><p><strong>min() 函数</strong>： 直接返回栈 BB 的栈顶元素即可</p><p>代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>{</span><br><span class="line">    Stack<integer> A, B;</integer></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>{</span><br><span class="line">        A = <span class="keyword">new</span> Stack<>();</span><br><span class="line">        B = <span class="keyword">new</span> Stack<>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">        A.add(x);</span><br><span class="line">        <span class="keyword">if</span>(B.empty() || x <= B.peek()){</span><br><span class="line">            B.add(x);</span><br><span class="line">        }   </span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> a = A.peek();</span><br><span class="line">        <span class="keyword">int</span> b = B.peek();</span><br><span class="line">        <span class="keyword">if</span>(a == b)</span><br><span class="line">            B.pop();</span><br><span class="line">        A.pop();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> A.peek();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python批量修改文件内容</title>
      <link href="/2020/04/09/python%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/"/>
      <url>/2020/04/09/python%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>今天想把文章的分类改一下，把“算法”改成“LeetCode”。手动改的话，需要一个个打开文件替换单词，用Python很快就搞定了。以后再想修改分类的时候，可以继续用。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line">mds = glob.glob(<span class="string">'文件目录/*.md'</span>)</span><br><span class="line"><span class="keyword">for</span> one_md <span class="keyword">in</span> mds:</span><br><span class="line">    print(one_md)</span><br><span class="line">    f = open(one_md, <span class="string">'r+'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    all_the_lines = f.readlines()</span><br><span class="line">    f.seek(<span class="number">0</span>)</span><br><span class="line">    f.truncate()</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> all_the_lines:</span><br><span class="line">        line = line.replace(<span class="string">'- 算法'</span>, <span class="string">'- LeetCode'</span>)</span><br><span class="line">        f.write(line)</span><br><span class="line">    f.close()</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>129-求根到叶子节点数字之和</title>
      <link href="/2020/04/09/129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/"/>
      <url>/2020/04/09/129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。</p><p>例如，从根到叶子节点路径 1->2->3 代表数字 123。</p><p>计算从根到叶子节点生成的所有数字之和。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例 1:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">输出: 25</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 1->2 代表数字 12.</span><br><span class="line">从根到叶子节点路径 1->3 代表数字 13.</span><br><span class="line">因此，数字总和 = 12 + 13 = 25.</span><br></pre></td></tr></tbody></table></figure></div><p>思路：先序遍历的思想+数字求和(每一层都比上层和*10+当前根节点的值)。递归的艺术。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">return</span> preorderSumNumbers(root, sum);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//求root下所有路径的数字和，并附带上层的数字和用于累加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">preorderSumNumbers</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//sum表示到当前这个节点，路径代表的数字</span></span><br><span class="line">        sum = sum * <span class="number">10</span> + root.val;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> && root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        <span class="keyword">return</span> preorderSumNumbers(root.left, sum) + preorderSumNumbers(root.right, sum);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>575-分糖果</title>
      <link href="/2020/04/09/575-%E5%88%86%E7%B3%96%E6%9E%9C/"/>
      <url>/2020/04/09/575-%E5%88%86%E7%B3%96%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>有N个小朋友站在一排，每个小朋友都有一个评分</p><p>你现在要按以下的规则给孩子们分糖果：</p><ul><li>每个小朋友至少要分得一颗糖果</li><li>分数高的小朋友要他比旁边得分低的小朋友分得的糖果多</li></ul><p>你最少要分发多少颗糖果？</p><p>思路：不太容易想出来。</p><p>先从左到右遍历一遍，找出并处理所有右边分值大于左边分值的情况，再从右到左遍历一遍，找出并处理所有左边分值大于右边分值的情况，</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="keyword">int</span>[] ratings)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = ratings.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">      <span class="comment">//所有人的糖果初始都发一个</span></span><br><span class="line">        Arrays.fill(count, <span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//从左向右扫描，保证一个方向上分数更大的糖果更多</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < len; i++){</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] > ratings[i-<span class="number">1</span>])</span><br><span class="line">                count[i] = count[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//从右向左扫描，保证另一个方向上分数更大的糖果更多</span></span><br><span class="line">      <span class="comment">//注意 count[i] <= count[i+1] 这个条件</span></span><br><span class="line">        <span class="comment">//如果已经满足 count[i] > count[i+1]，就不用调整了</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i >= <span class="number">0</span>; i--){</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] > ratings[i+<span class="number">1</span>] && count[i] <= count[i+<span class="number">1</span>])</span><br><span class="line">                count[i] = count[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//求和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < len; i++){</span><br><span class="line">            res += count[i];</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL常用操作</title>
      <link href="/2020/04/06/MySQL%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/04/06/MySQL%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>学会MySQL的关键是理解其语句的执行顺序。</p><h4 id="语法顺序"><a href="#语法顺序" class="headerlink" title="语法顺序"></a>语法顺序</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select[distinct]  </span><br><span class="line">from  </span><br><span class="line">join </span><br><span class="line">on  </span><br><span class="line">where  </span><br><span class="line">group by  </span><br><span class="line">having  </span><br><span class="line">union  </span><br><span class="line">order by  </span><br><span class="line">limit</span><br></pre></td></tr></tbody></table></figure></div><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from  </span><br><span class="line">on  </span><br><span class="line">join  </span><br><span class="line">where  </span><br><span class="line">group by  </span><br><span class="line">having  </span><br><span class="line">select  </span><br><span class="line">distinct  </span><br><span class="line">union  </span><br><span class="line">order by</span><br></pre></td></tr></tbody></table></figure></div><h4 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h4><p>用法：WHERE 条件1 AND/OR 条件2</p><p>常用的操作符都可以用，注意<>和！= 一样表示不等于</p><h4 id="Like子句（模糊查询）"><a href="#Like子句（模糊查询）" class="headerlink" title="Like子句（模糊查询）"></a>Like子句（模糊查询）</h4><p>用法：<strong>用在where子句中</strong>。WHERE 字段1 LIKE 条件1</p><p>MySQL提供了四种匹配方式</p><ol><li><p><strong>%</strong>：表示任意 0 个或多个字符。</p></li><li><p><strong>_</strong>：表示任意单个字符。</p></li><li><p><strong>[]</strong>：表示括号内所列字符中的一个（类似正则表达式）。</p></li><li><p><strong>[^]</strong> ：表示不在括号所列之内的单个字符。</p><p>例如：</p></li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">'%a'     //以a结尾的数据</span><br><span class="line">'a%'     //以a开头的数据</span><br><span class="line">'%a%'    //含有a的数据</span><br><span class="line">'_a_'    //三位且中间字母是a的</span><br><span class="line">'_a'     //两位且结尾字母是a的</span><br><span class="line">'a_'     //两位且开头字母是a的</span><br></pre></td></tr></tbody></table></figure></div><h4 id="ORDER-BY（排序）"><a href="#ORDER-BY（排序）" class="headerlink" title="ORDER BY（排序）"></a>ORDER BY（排序）</h4><p>用法：指定字段作为排序的条件。用ASC 或 DESC 关键字来设置查询结果是按升序或降序排列。 默认情况下，是按升序排列。</p><h4 id="GROUP-BY（分组）"><a href="#GROUP-BY（分组）" class="headerlink" title="GROUP BY（分组）"></a>GROUP BY（分组）</h4><p>用法：根据某个字段对结果集进行分组。在分组的列上可以使用 COUNT, SUM, AVG等函数。</p><p>Having和where类似，但必须和group by同时使用，用来根据指定条件过滤分组</p><h4 id="join（连接）"><a href="#join（连接）" class="headerlink" title="join（连接）"></a>join（连接）</h4><p>用法：多表根据主外键进行连接。默认情况下join指的是inner join</p><ul><li><strong>INNER JOIN（内连接）</strong>：获取两个表中字段匹配关系的记录。</li><li><strong>LEFT JOIN（左连接）：</strong>获取左表所有记录，即使右表没有对应匹配的记录。</li><li><strong>RIGHT JOIN（右连接）：</strong> 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。</li></ul><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200406114320943.png" data-fancybox="group" data-caption="image-20200406114320943" class="fancybox"><img alt="image-20200406114320943" title="image-20200406114320943" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200406114320943.png" class="lazyload"></a></p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200406114340472.png" data-fancybox="group" data-caption="image-20200406114340472" class="fancybox"><img alt="image-20200406114340472" title="image-20200406114340472" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200406114340472.png" class="lazyload"></a></p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200406114355213.png" data-fancybox="group" data-caption="image-20200406114355213" class="fancybox"><img alt="image-20200406114355213" title="image-20200406114355213" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200406114355213.png" class="lazyload"></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>139-单词拆分</title>
      <link href="/2020/04/05/139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
      <url>/2020/04/05/139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个字符串s和一组单词dict，判断s是否可以用空格分割成一个单词序列，使得单词序列中所有的单词都是dict中的单词（序列可以包含一个或多个单词）。</p><p>例如:<br>给定s=“leetcode”；<br>dict=[“leet”, “code”].<br>返回true，因为”leetcode”可以被分割成”leet code”.</p><p>注意：dict中可以有很多单词，而且s中重复的单词在dict中有一个就可以。</p><p>思路：动态规划。</p><p>状态转移方程：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(i) 表示s[0,i]是否可以分词</span><br><span class="line">f(i) = f(j) && f(j+1,i); 0 <= j < i</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, Set<string> dict)</string></span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">      <span class="comment">//注意这个细节，申请的长度为len+1。arr[i]表示字符串前i个是否可以划分单词</span></span><br><span class="line">        <span class="keyword">boolean</span>[] arr = <span class="keyword">new</span> <span class="keyword">boolean</span>[len+<span class="number">1</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">//把握整体思想，细节实际使用时再注意</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i <= len; i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j < i; j++){</span><br><span class="line">                <span class="keyword">if</span>(arr[j]&&dict.contains(s.substring(j,i))){</span><br><span class="line">                    arr[i] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> arr[len];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划解题思路</title>
      <link href="/2020/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/"/>
      <url>/2020/04/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p><strong>动态规划问题的⼀般形式就是求最值</strong></p><p><strong>求解动态规划的核⼼问题是穷举</strong></p><p>动态规划的穷举有点特别，因为这类问题<strong>存在「重叠⼦问题」</strong>，如果暴⼒穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优 化穷举过程，避免不必要的计算。 ⽽且，动态规划问题⼀定会<strong>具备「最优⼦结构」</strong>，才能通过⼦问题的最值，得到原问题的最值。 </p><p>只有列出<strong>正确的「状态转移⽅程」</strong>才能正确地穷举。 </p><p>动态规划三要素：</p><ul><li><p>重叠⼦问题</p></li><li><p>最优⼦结构</p></li><li><p><strong>状态转移⽅程</strong>（最关键的）</p><ul><li>明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base </li></ul><p>case </p></li></ul></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>143-重排链表</title>
      <link href="/2020/04/03/143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/04/03/143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>将给定的单链表L： <strong>L 0→L 1→…→L n-1→L n</strong>,</p><p>重新排序为： <strong>L 0→L n →L 1→L n-1→L 2→L n-2→…</strong></p><p>要求使用原地算法，并且不改变节点的值</p><p>例如：对于给定的单链表</p><p>{1,2,3,4,5,6}，将其重新排序为{1,6,2,5,3,4}.</p><p>{1,2,3,4,5,6,7}，将其重新排序为{1,7,2,6,3,5,4}.</p><p>思路：</p><ol><li>先用快慢指针找到中间节点（<strong>注意链表长度为偶数时，中间节点为前半段的末尾节点</strong>）</li><li>拆分链表，将中间节点之后的链表反转</li><li>合并前半段和后半段（反转过的）链表</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 快满指针找到中间节点</span></span><br><span class="line">      <span class="comment">//注意这里的写法，可以记下来，经常用到，不用单独考虑长度为偶数的情况</span></span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span> && fast.next.next != <span class="keyword">null</span>){</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 拆分链表，并反转中间节点之后的链表</span></span><br><span class="line">      <span class="comment">//这里反转链表用的是头插法，如果不理解画下图就明白了</span></span><br><span class="line">        ListNode after = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(after != <span class="keyword">null</span>){</span><br><span class="line">            ListNode temp = after.next;</span><br><span class="line">            after.next = pre;</span><br><span class="line">            pre = after;</span><br><span class="line">            after = temp;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 合并两个链表（这两个链表长度相等或相差1）</span></span><br><span class="line">      <span class="comment">//配合画图理解思路</span></span><br><span class="line">        ListNode first = head;</span><br><span class="line">        after = pre;</span><br><span class="line">        <span class="keyword">while</span>(first != <span class="keyword">null</span> && after != <span class="keyword">null</span>){</span><br><span class="line">            ListNode ftemp = first.next;</span><br><span class="line">            ListNode aftemp = after.next;</span><br><span class="line">            first.next = after;</span><br><span class="line">            first = ftemp;</span><br><span class="line">            after.next = first;        </span><br><span class="line">            after = aftemp;        </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>141-环形链表</title>
      <link href="/2020/04/03/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/04/03/141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>判断给定的链表中是否有环</p><p>思路一：</p><p>用快慢指针。如果没有环，快指针就会先到达尾部，如果有环，那么快慢指针一定会相遇。为什么一定会相遇？考虑下面这种情况（记作情况 A）- 假如快跑者只落后慢跑者一步，在下一次迭代中，它们就会分别跑了一步或两步并相遇。其他情况又会怎样呢？例如，我们没有考虑快跑者在慢跑者之后两步或三步的情况。但其实不难想到，因为在下一次或者下下次迭代后，又会变成上面提到的情况 A。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next.next;</span><br><span class="line">      <span class="comment">//快指针去追慢指针</span></span><br><span class="line">        <span class="keyword">while</span>(slow != fast){</span><br><span class="line">          <span class="comment">//如果快指针到了尾部，说明没有环</span></span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路二：</p><p>用哈希表。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">    Set<listnode> nodesSeen = <span class="keyword">new</span> HashSet<>();</listnode></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">if</span> (nodesSeen.contains(head)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            nodesSeen.add(head);</span><br><span class="line">        }</span><br><span class="line">        head = head.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>289-生命游戏</title>
      <link href="/2020/04/02/289-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/"/>
      <url>/2020/04/02/289-%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态：1 即为活细胞（live），或 0 即为死细胞（dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：</p><ol><li>如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；</li><li>如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活；</li><li>如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；</li><li>如果死细胞周围正好有三个活细胞，则该位置死细胞复活；</li></ol><p>根据当前状态，写一个函数来计算面板上所有细胞的下一个（一次更新后的）状态。下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。</p><p>注意，面板上所有格子需要<strong>同时被更新</strong>：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。</p><p>示例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入： </span><br><span class="line">[</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,1],</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,1,1],</span><br><span class="line">  [0,1,0]</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></div><p>思路一：</p><p><strong>复制一个数组保存之前的状态，然后修改原数组。</strong>原理很简单，但是要注意细胞状态的同时更新，因为每个细胞状态改变后，会影响这轮更新中其他细胞的判断。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] neighbors = {<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>};</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = board.length;</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建复制数组 copyBoard</span></span><br><span class="line">        <span class="keyword">int</span>[][] copyBoard = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从原数组复制一份到 copyBoard 中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row < rows; row++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col < cols; col++) {</span><br><span class="line">                copyBoard[row][col] = board[row][col];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历面板每一个格子里的细胞</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row < rows; row++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col < cols; col++) {</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对于每一个细胞统计其八个相邻位置里的活细胞数量</span></span><br><span class="line">                <span class="keyword">int</span> liveNeighbors = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//用这种方式向周围扩展，可以学习借鉴</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">3</span>; i++) {</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < <span class="number">3</span>; j++) {</span><br><span class="line"><span class="comment">//如果是自身就跳过，那么就还剩8个“邻居”</span></span><br><span class="line">                        <span class="keyword">if</span> (!(neighbors[i] == <span class="number">0</span> && neighbors[j] == <span class="number">0</span>)) {</span><br><span class="line">                            <span class="keyword">int</span> r = (row + neighbors[i]);</span><br><span class="line">                            <span class="keyword">int</span> c = (col + neighbors[j]);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 查看相邻的细胞是否是活细胞</span></span><br><span class="line">                            <span class="keyword">if</span> ((r < rows && r >= <span class="number">0</span>) && (c < cols && c >= <span class="number">0</span>) && (copyBoard[r][c] == <span class="number">1</span>)) {</span><br><span class="line">                                liveNeighbors += <span class="number">1</span>;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 规则 1 或规则 3      </span></span><br><span class="line">                <span class="keyword">if</span> ((copyBoard[row][col] == <span class="number">1</span>) && (liveNeighbors < <span class="number">2</span> || liveNeighbors > <span class="number">3</span>)) {</span><br><span class="line">                    board[row][col] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 规则 4</span></span><br><span class="line">                <span class="keyword">if</span> (copyBoard[row][col] == <span class="number">0</span> && liveNeighbors == <span class="number">3</span>) {</span><br><span class="line">                    board[row][col] = <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路二：<strong>使用额外的状态。</strong>上一种方法空间开销比较大，其实可以用一种新的状态既保存之前的状态，又能表示现在的状态。举个例子，如果细胞之前的状态是 0，但是在更新之后变成了 1，我们就可以给它定义一个复合状态 2。这样我们看到 2，既能知道目前这个细胞是活的，还能知道它之前是死的。</p><p>具体的计算规则如下所示：</p><ol><li><p>规则 1：如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡。这时候，<strong>将细胞值改为 -1，代表这个细胞过去是活的现在死了；</strong></p></li><li><p>规则 2：如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活。这时候<strong>不改变细胞的值，仍为 1；</strong></p></li><li><p>规则 3：如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡。这时候，<strong>将细胞的值改为 -1，代表这个细胞过去是活的现在死了</strong>。可以看到，因为规则 1 和规则 3 下细胞的起始终止状态是一致的，因此它们的复合状态也一致；</p></li><li><p>规则 4：如果死细胞周围正好有三个活细胞，则该位置死细胞复活。这时候，<strong>将细胞的值改为 2，代表这个细胞过去是死的现在活了。</strong></p></li></ol><p>这样思路就很简单了，第一遍遍历的时候，用复合状态更新数组，然后根据复合状态的规则恢复成正常的表示方式。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gameOfLife</span><span class="params">(<span class="keyword">int</span>[][] board)</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] neighbors = {<span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>};</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rows = board.length;</span><br><span class="line">        <span class="keyword">int</span> cols = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历面板每一个格子里的细胞</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row < rows; row++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col < cols; col++) {</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对于每一个细胞统计其八个相邻位置里的活细胞数量</span></span><br><span class="line">                <span class="keyword">int</span> liveNeighbors = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">3</span>; i++) {</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < <span class="number">3</span>; j++) {</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!(neighbors[i] == <span class="number">0</span> && neighbors[j] == <span class="number">0</span>)) {</span><br><span class="line">                            <span class="comment">// 相邻位置的坐标</span></span><br><span class="line">                            <span class="keyword">int</span> r = (row + neighbors[i]);</span><br><span class="line">                            <span class="keyword">int</span> c = (col + neighbors[j]);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 查看相邻的细胞是否是活细胞</span></span><br><span class="line">                            <span class="keyword">if</span> ((r < rows && r >= <span class="number">0</span>) && (c < cols && c >= <span class="number">0</span>) && (Math.abs(board[r][c]) == <span class="number">1</span>)) {</span><br><span class="line">                                liveNeighbors += <span class="number">1</span>;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 规则 1 或规则 3 </span></span><br><span class="line">                <span class="keyword">if</span> ((board[row][col] == <span class="number">1</span>) && (liveNeighbors < <span class="number">2</span> || liveNeighbors > <span class="number">3</span>)) {</span><br><span class="line">                    <span class="comment">// -1 代表这个细胞过去是活的现在死了</span></span><br><span class="line">                    board[row][col] = -<span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 规则 4</span></span><br><span class="line">                <span class="keyword">if</span> (board[row][col] == <span class="number">0</span> && liveNeighbors == <span class="number">3</span>) {</span><br><span class="line">                    <span class="comment">// 2 代表这个细胞过去是死的现在活了</span></span><br><span class="line">                    board[row][col] = <span class="number">2</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 board 得到一次更新后的状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row < rows; row++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col < cols; col++) {</span><br><span class="line">                <span class="keyword">if</span> (board[row][col] > <span class="number">0</span>) {</span><br><span class="line">                    board[row][col] = <span class="number">1</span>;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    board[row][col] = <span class="number">0</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>147-对链表进行插入排序</title>
      <link href="/2020/04/02/147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/04/02/147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>使用插入排序对链表进行排序。</p><p>思路：</p><ol><li><p>新建一个虚拟节点。因为有的节点可能会直接插到head之前</p></li><li><p>cur指向的节点及其后面所有节点都是未排序的，前面的都是排好序的</p></li><li><p>每次插入一个节点时，pre都从dummy开始往后寻找插入点（dummy后一个节点到cur前一个节点都是排好序的）</p></li><li><p>找到插入点后移动指针进行插入</p></li></ol><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200402103532859.png" data-fancybox="group" data-caption="image-20200402103532859" class="fancybox"><img alt="image-20200402103532859" title="image-20200402103532859" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200402103532859.png" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) {</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        <span class="comment">//判断一下</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//新建一个虚拟节点。因为有的节点可能会直接插到head之前</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//curr指向的节点及其后面所有节点都是未排序的，前面的都是排好序的</span></span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="keyword">null</span>){</span><br><span class="line">            <span class="comment">//每次循环，pre都重新指向dummy，dummy后一个节点到curr前一个节点都是排好序的</span></span><br><span class="line">            ListNode pre = dummy;</span><br><span class="line">            <span class="comment">//保存一下当前节点后面一个节点的引用</span></span><br><span class="line">            ListNode next = curr.next;</span><br><span class="line">            <span class="comment">//每次都从dummy节点下一个开始找，前面都是排好序的，如果小于当前节点则指针后移，一直找到pre.next为空</span></span><br><span class="line">            <span class="comment">//或者比当前节点大的时候，停止，表明pre的下一个节点就是当前节点应该放的位置</span></span><br><span class="line">            <span class="keyword">while</span>(pre.next != <span class="keyword">null</span> && pre.next.val < curr.val){</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//找到当前节点应该放的位置之后，下面的工作就是移动指针，让curr插到pre和pre.next中间</span></span><br><span class="line">            <span class="comment">//然后让curr后移一位，前面都是排好序的</span></span><br><span class="line">            curr.next = pre.next;</span><br><span class="line">            pre.next = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//dummy后面就是我们所需要的用插入排序排好序的链表</span></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis总结</title>
      <link href="/2020/04/01/Mybatis%E6%80%BB%E7%BB%93/"/>
      <url>/2020/04/01/Mybatis%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="Mybatis作用"><a href="#Mybatis作用" class="headerlink" title="Mybatis作用"></a>Mybatis作用</h4><p>用JDBC操作数据库比较繁琐，Mybatis可以简化对数据库的操作</p><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><ul><li>SqlMapConfig.xml。全局的配置文件，配置mybatis的运行环境等信息</li><li>mapper.xml。对应一张表，配置了操作数据库的SQL语句，需要在SqlMapConfig.xml中加载</li><li>构造SQLSessionFactory（会话工厂）</li><li>通过会话工厂创建Sqlsession（会话），用它操作数据库</li></ul><h4 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h4><p>增删改查有一对多，多对一，多对多等，一般会准备好pojo对象，并且对象的属性和数据库表中的字段一一对应。</p><p>以最简单的增加操作为例：</p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200401225818536.png" data-fancybox="group" data-caption="image-20200401225818536" class="fancybox"><img alt="image-20200401225818536" style="zoom:50%;" title="image-20200401225818536" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200401225818536.png" class="lazyload"></a><p>在mapper文件里，通过select，insert等标签写SQL语句。标签上的id是为了上面调用时找到这条语句， parameterType指定了传入的参数类型，resultType表指定了返回结果的类型。其中 <strong>#{ }用来表示占位符</strong>，<strong>${ }用来表示字符串拼接</strong></p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200401230028536.png" data-fancybox="group" data-caption="image-20200401230028536" class="fancybox"><img alt="image-20200401230028536" style="zoom:50%;" title="image-20200401230028536" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200401230028536.png" class="lazyload"></a><h4 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h4><p>在mapper.xml文件里可以用<strong><if> <where></where></if></strong>等标签，根据参数动态调整SQL语句。</p><p>例如：如果没有传参数name,那么就查询所有，如果有name参数，那么就进行模糊查询</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listProduct"</span> <span class="attr">resultType</span>=<span class="string">"Product"</span>></span></span><br><span class="line">select * from product_</span><br><span class="line"><span class="tag"><<span class="name">if</span> <span class="attr">test</span>=<span class="string">"name!=null"</span>></span></span><br><span class="line">where name like concat('%',#{name},'%')</span><br><span class="line"><span class="tag"><!--<span class="name"-->if</span>></span> <br><span class="line"><span class="tag"><!--<span class="name"-->select</span>></span><br></pre></td></tr></tbody></table></figure></div><h4 id="修改为注解的方式"><a href="#修改为注解的方式" class="headerlink" title="修改为注解的方式"></a>修改为注解的方式</h4><p>例如：</p><p>原本有Category.xml</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><!--?xml version="1.0" encoding="UTF-8"?--></span></span><br><span class="line"><span class="meta">mapper</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.how2java.pojo"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addCategory"</span> <span class="attr">parameterType</span>=<span class="string">"Category"</span> ></span></span><br><span class="line">        insert into category_ ( name ) values (#{name})    </span><br><span class="line">    <span class="tag"><!--<span class="name"-->insert</span>></span><br><span class="line">    </span><br><span class="line">    <span class="tag"><<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteCategory"</span> <span class="attr">parameterType</span>=<span class="string">"Category"</span> ></span></span><br><span class="line">        delete from category_ where id= #{id}   </span><br><span class="line">    <span class="tag"><!--<span class="name"-->delete</span>></span><br><span class="line">    </span><br><span class="line">    <span class="tag"><<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getCategory"</span> <span class="attr">parameterType</span>=<span class="string">"_int"</span> <span class="attr">resultType</span>=<span class="string">"Category"</span>></span></span><br><span class="line">        select * from   category_  where id= #{id}    </span><br><span class="line">    <span class="tag"><!--<span class="name"-->select</span>></span><br><span class="line"></span><br><span class="line">    <span class="tag"><<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateCategory"</span> <span class="attr">parameterType</span>=<span class="string">"Category"</span> ></span></span><br><span class="line">        update category_ set name=#{name} where id=#{id}    </span><br><span class="line">    <span class="tag"><!--<span class="name"-->update</span>></span><br><span class="line">    <span class="tag"><<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listCategory"</span> <span class="attr">resultType</span>=<span class="string">"Category"</span>></span></span><br><span class="line">        select * from   category_      </span><br><span class="line">    <span class="tag"><!--<span class="name"-->select</span>></span>    <br><span class="line"><span class="tag"><!--<span class="name"-->mapper</span>></span><br></pre></td></tr></tbody></table></figure></div><p>修改为注解的方式就要新增加接口CategoryMapper ，并在接口中声明的方法上，加上注解，其实就是把SQL语句从XML挪到了注解上来</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Delete;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Update;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.xxx.pojo.Category;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CategoryMapper</span> </span>{</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">" insert into category_ ( name ) values (#{name}) "</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(Category category)</span></span>;  </span><br><span class="line">       </span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">" delete from category_ where id= #{id} "</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>;  </span><br><span class="line">       </span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from category_ where id= #{id} "</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Category <span class="title">get</span><span class="params">(<span class="keyword">int</span> id)</span></span>;  </span><br><span class="line">     </span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"update category_ set name=#{name} where id=#{id} "</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Category category)</span></span>;   </span><br><span class="line">       </span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">" select * from category_ "</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List<category> <span class="title">list</span><span class="params">()</span></category></span>;  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>然后在mybatis的配置文件中，增加对CategoryMapper的映射</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">mappers</span>></span></span><br><span class="line">        <span class="tag"><<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.xxx.mapper.CategoryMapper"</span>/></span> </span><br><span class="line"><span class="tag"><!--<span class="name"-->mappers</span>></span><br></pre></td></tr></tbody></table></figure></div><p>简单的测试一下。要注意CategoryMapper接口是不能凭空实例化的，必然是某个类实现了这个接口，这个类去进行实例化。下面并没有出现这个实现类，那么这个实现类是如何存在的呢？ 这个是由mybatis采用动态代理技术临时创建的实现类。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.how2java.mapper.CategoryMapper;</span><br><span class="line"><span class="keyword">import</span> com.how2java.pojo.Category;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMybatis</span> </span>{</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">        String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line">        CategoryMapper mapper = session.getMapper(CategoryMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//        add(mapper);</span></span><br><span class="line"><span class="comment">//        delete(mapper);</span></span><br><span class="line"><span class="comment">//        get(mapper);</span></span><br><span class="line"><span class="comment">//        update(mapper);</span></span><br><span class="line">        listAll(mapper);</span><br><span class="line">             </span><br><span class="line">        session.commit();</span><br><span class="line">        session.close();</span><br><span class="line">  </span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(CategoryMapper mapper)</span> </span>{</span><br><span class="line">        Category c= mapper.get(<span class="number">8</span>);</span><br><span class="line">        c.setName(<span class="string">"修改了的Category名称"</span>);</span><br><span class="line">        mapper.update(c);</span><br><span class="line">        listAll(mapper);</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(CategoryMapper mapper)</span> </span>{</span><br><span class="line">        Category c= mapper.get(<span class="number">8</span>);</span><br><span class="line">        System.out.println(c.getName());</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(CategoryMapper mapper)</span> </span>{</span><br><span class="line">        mapper.delete(<span class="number">2</span>);</span><br><span class="line">        listAll(mapper);</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(CategoryMapper mapper)</span> </span>{</span><br><span class="line">        Category c = <span class="keyword">new</span> Category();</span><br><span class="line">        c.setName(<span class="string">"新增加的Category"</span>);</span><br><span class="line">        mapper.add(c);</span><br><span class="line">        listAll(mapper);</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAll</span><span class="params">(CategoryMapper mapper)</span> </span>{</span><br><span class="line">        List<category> cs = mapper.list();</category></span><br><span class="line">        <span class="keyword">for</span> (Category c : cs) {</span><br><span class="line">            System.out.println(c.getName());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>日志</li><li>事务管理</li><li>延迟加载</li><li>分页</li><li>一/二级缓存</li><li>c3p0连接池</li><li>逆向工程</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>144-二叉树的前序遍历</title>
      <link href="/2020/04/01/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2020/04/01/144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>二叉树的前序遍历（非递归）</p><p>思路：</p><p>1.根节点入栈</p><p>2.如果栈不为空，取出栈顶元素并访问。栈顶元素的右子节点，左子节点（如果结点为null则跳过）依次入栈。<strong>（注意顺序是先入右子结点，再入左子节点）</strong></p><p>3.重复第二步</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) { val = x; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList<integer> <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </integer></span>{</span><br><span class="line">        ArrayList<integer> res = <span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Stack<treenode> stack = <span class="keyword">new</span> Stack<>();</treenode></span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()){</span><br><span class="line">          <span class="comment">//访问节点</span></span><br><span class="line">            TreeNode p = stack.pop();</span><br><span class="line">            res.add(p.val);</span><br><span class="line">          <span class="comment">//右子节点入栈</span></span><br><span class="line">            <span class="keyword">if</span>(p.right != <span class="keyword">null</span>)</span><br><span class="line">                stack.push(p.right);</span><br><span class="line">          <span class="comment">//左子节点入栈</span></span><br><span class="line">            <span class="keyword">if</span>(p.left != <span class="keyword">null</span>)</span><br><span class="line">                stack.push(p.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>149-直线上最多的点数</title>
      <link href="/2020/03/30/149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/"/>
      <url>/2020/03/30/149-%E7%9B%B4%E7%BA%BF%E4%B8%8A%E6%9C%80%E5%A4%9A%E7%9A%84%E7%82%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>对于给定的n个位于同一二维平面上的点，求最多能有多少个点位于同一直线上。</p><p>思路：穷举法，判断多点是否在同一直线时，要注意特殊情况，水平或垂直。其他的方法有点复杂，比如计算斜率，用double可能还不够精确。</p><p>1) 选择第一个点A1 </p><p>2) 选择第二个点A2, 和第一个点构成一条直线, </p><p>3) 遍历剩下的n-2个点Ai, 判断Ai与A1构成的直线是否与A2与A1构成的直线保持一致,若是,则A1A2直线上的点数就+1</p><p>4)每次求完A1A2直线上的最大点数, 和结果取最大值. 遍历结束就是结果 </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPoints</span><span class="params">(Point[] points)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == points) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (points.length < <span class="number">3</span>) {</span><br><span class="line">            <span class="keyword">return</span> points.length;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> maxPoints = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < points.length; i++) {</span><br><span class="line">        <span class="comment">//第一个点</span></span><br><span class="line">            <span class="keyword">int</span> x1 = points[i].x;</span><br><span class="line">            <span class="keyword">int</span> y1 = points[i].y;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j < points.length; j++) {</span><br><span class="line">              <span class="comment">//第二个点</span></span><br><span class="line">                <span class="keyword">int</span> x2 = points[j].x;</span><br><span class="line">                <span class="keyword">int</span> y2 = points[j].y;</span><br><span class="line">                <span class="keyword">int</span> max = <span class="number">2</span>;</span><br><span class="line">              <span class="comment">//遍历剩下的点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k < points.length; k++) {</span><br><span class="line">                    <span class="keyword">if</span> (k == i || k == j) {</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    }</span><br><span class="line"><span class="keyword">int</span> x3 = points[k].x;</span><br><span class="line">                    <span class="keyword">int</span> y3 = points[k].y;</span><br><span class="line">                    <span class="keyword">boolean</span> flag;</span><br><span class="line">                  <span class="comment">//如果是水平线</span></span><br><span class="line">                    <span class="keyword">if</span> (x1 == x2) {</span><br><span class="line">                        flag = x3 == x1;</span><br><span class="line">                    } </span><br><span class="line">                  <span class="comment">//如果是垂直线</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (y1 == y2) {</span><br><span class="line">                        flag = y3 == y1;</span><br><span class="line">                    }</span><br><span class="line">                  <span class="comment">//这里用乘法别用除法</span></span><br><span class="line">                  <span class="keyword">else</span> {</span><br><span class="line">                        flag = (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 -x1);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span> (flag) {</span><br><span class="line">                        max++;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                maxPoints = Math.max(maxPoints, max);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> maxPoints;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1162-地图分析</title>
      <link href="/2020/03/30/1162-%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/"/>
      <url>/2020/03/30/1162-%E5%9C%B0%E5%9B%BE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。</p><p>我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。</p><p>如果我们的地图上只有陆地或者海洋，请返回 -1。</p><p>示例 1：</p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200330002822357.png" data-fancybox="group" data-caption="image-20200330002822357" class="fancybox"><img alt="image-20200330002822357" style="zoom:50%;" title="image-20200330002822357" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200330002822357.png" class="lazyload"></a><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[[1,0,1],[0,0,0],[1,0,1]]</span><br><span class="line">输出：2</span><br><span class="line">解释： 海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。</span><br></pre></td></tr></tbody></table></figure></div><p>思路：一开始的思路是，遍历地图找到海洋，然后写个函数求海洋坐标(x,y)距离陆地最近的距离，理论上也能写出来。但是思路不太优雅。</p><p>其他解法：<strong>只要先把所有的陆地都入队，然后从各个陆地同时开始一层一层的向海洋扩散，那么最后扩散到的海洋就是最远的海洋。</strong></p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/367df5172fd16d2637e591f6586d146772758438c66660c86719ffb2d36eb14d-image.png" data-fancybox="group" data-caption="image.png" class="fancybox"><img alt="image.png" title="image.png" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/367df5172fd16d2637e591f6586d146772758438c66660c86719ffb2d36eb14d-image.png" class="lazyload"></a></p><p>很巧妙的是，直接将距离保存到了原矩阵中，同时也避免了再次访问，一举多用。比如上面的数字2，就能说明这个地方距离陆地最近的距离是1（2减一）。体会一下上面的思想。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] dx = {<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>};</span><br><span class="line">        <span class="keyword">int</span>[] dy = {<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>};</span><br><span class="line"></span><br><span class="line">        Queue<<span class="keyword">int</span>[]> queue = <span class="keyword">new</span> ArrayDeque<>();</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">// 先把所有的陆地都入队。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < m; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < n; j++) {</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) {</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] {i, j});</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从各个陆地开始，一圈一圈的遍历海洋，最后遍历到的海洋就是离陆地最远的海洋。</span></span><br><span class="line">        <span class="keyword">boolean</span> hasOcean = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] point = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            point = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> x = point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 取出队列的元素，将其四周的海洋入队。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">4</span>; i++) {</span><br><span class="line">                <span class="keyword">int</span> newX = x + dx[i];</span><br><span class="line">                <span class="keyword">int</span> newY = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (newX < <span class="number">0</span> || newX >= m || newY < <span class="number">0</span> || newY >= n || grid[newX][newY] != <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">              <span class="comment">//直接将距离保存到了原矩阵中，同时也避免了再次访问</span></span><br><span class="line">                grid[newX][newY] = grid[x][y] + <span class="number">1</span>; </span><br><span class="line">                hasOcean = <span class="keyword">true</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] {newX, newY});</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有陆地或者没有海洋，返回-1。</span></span><br><span class="line">        <span class="keyword">if</span> (point == <span class="keyword">null</span> || !hasOcean) {</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回最后一次遍历到的海洋的距离。</span></span><br><span class="line">        <span class="keyword">return</span> grid[point[<span class="number">0</span>]][point[<span class="number">1</span>]] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>145-二叉树的后序遍历</title>
      <link href="/2020/03/29/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2020/03/29/145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>二叉树的后序遍历，一直理解的不太透彻。</p><p>方法一：递归</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) { val = x; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    ArrayList<integer> res = <span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList<integer> <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </integer></span>{</span><br><span class="line">        hx(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hx</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        bl(root.left);</span><br><span class="line">        bl(root.right);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>方法二：</p><p>要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。</p><ul><li>如果P不存在左孩子和右孩子，则可以直接访问它</li><li>或者P存在孩子，但是其孩子都已被访问过了，则同样可以直接访问该结点</li><li>若非上述两种情况，则将P的<strong>右孩子和左孩子依次入栈</strong>，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList<integer> <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </integer></span>{</span><br><span class="line">        ArrayList<integer> list = <span class="keyword">new</span> ArrayList<>();</integer></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">         </span><br><span class="line">        Stack<treenode> stack = <span class="keyword">new</span> Stack<>();</treenode></span><br><span class="line">  <span class="comment">//保存上一次被访问（也就是被添加到list）结点</span></span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()){</span><br><span class="line">            <span class="comment">// 只看栈顶元素，不弹出</span></span><br><span class="line">            TreeNode cur = stack.peek();</span><br><span class="line">          <span class="comment">//这里的判断很巧妙。正常情况下，入栈顺序是根-右-左。如果遇到特殊情况，就可以直接访问了</span></span><br><span class="line">          <span class="comment">//1.栈顶元素没有孩子结点</span></span><br><span class="line">          <span class="comment">//2.上一次被访问的如果是栈顶的左子结点，说明栈顶元素没有右子结点</span></span><br><span class="line">          <span class="comment">//上一次被访问的如果是栈顶的右子结点，说明找栈顶元素的孩子结点都被访问过了</span></span><br><span class="line">            <span class="keyword">if</span>((cur.left == <span class="keyword">null</span> && cur.right == <span class="keyword">null</span>)</span><br><span class="line">                || (pre != <span class="keyword">null</span> && (pre == cur.left || pre == cur.right))){</span><br><span class="line">                list.add(cur.val);</span><br><span class="line">              <span class="comment">//被访问之后就被出栈了</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                pre = cur;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">              <span class="comment">//注意这里的入栈顺序，先右再左</span></span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)</span><br><span class="line">                    stack.push(cur.right);</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)</span><br><span class="line">                    stack.push(cur.left);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>方法三：</p><p>把前序遍历 根 - 左 - 右 改成 根 - 右 - 左，然后reverse。</p><p>方法四：经典解法</p><p>核心思想是用栈做辅助空间，先<strong>从根往左一直入栈，直到为空</strong>，然后判断栈顶元素的右孩子，<strong>如果不为空且未被访问过</strong>，则从它开始重复左孩子入栈的过程；否则说明此时栈顶为要访问的节点（因为左右孩子都是要么为空要么已访问过了）， 出栈然后访问即可，接下来再判断栈顶元素的右孩子…直到栈空。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList<integer> <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </integer></span>{</span><br><span class="line">        TreeNode p = root, r = <span class="keyword">null</span>;        <span class="comment">//P记录当前节点，r用来记录上一次访问的节点</span></span><br><span class="line">        Stack<treenode> s = <span class="keyword">new</span> Stack<treenode>();</treenode></treenode></span><br><span class="line">        ArrayList<integer> list = <span class="keyword">new</span> ArrayList<integer>();</integer></integer></span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span> || !s.isEmpty()) {</span><br><span class="line">            <span class="keyword">if</span>(p != <span class="keyword">null</span>) {     <span class="comment">//左孩子一直入栈，直到左孩子为空</span></span><br><span class="line">                s.push(p);</span><br><span class="line">                p = p.left;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                p = s.peek();</span><br><span class="line">                p = p.right;</span><br><span class="line">                <span class="keyword">if</span>(p != <span class="keyword">null</span> && p != r) {   <span class="comment">//如果栈顶元素的右孩子不为空，且未被访问过</span></span><br><span class="line">                    s.push(p);              <span class="comment">//则右孩子进栈，然后重复左孩子一直进栈直到为空的过程</span></span><br><span class="line">                    p = p.left;</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    p = s.pop();            <span class="comment">//否则出栈，访问，r记录刚刚访问的节点</span></span><br><span class="line">                    list.add(p.val);</span><br><span class="line">                    r = p;</span><br><span class="line">                    p = <span class="keyword">null</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>136-只出现一次的数字</title>
      <link href="/2020/03/28/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2020/03/28/136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>现在有一个整数类型的数组，数组中素只有一个元素只出现一次，其余的元素都出现两次。</p><p><strong>注意：</strong></p><p>你需要给出一个线性时间复杂度的算法，你能在不使用额外内存空间的情况下解决这个问题么？</p><p>思路：要求线性复杂度就不能用排序了，不能用额外空间就用不了Map了。只能想办法一次遍历解决。想到<strong>异或</strong>，<strong>两个相同数字异或结果是0，一个数和0异或还是它本身</strong>。所以遍历一遍把每个元素异或一下就是答案了。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">int</span> res = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < len; i++)</span><br><span class="line">            res ^= A[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>红黑树总结</title>
      <link href="/2020/03/27/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/27/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="什么是红黑树？"><a href="#什么是红黑树？" class="headerlink" title="什么是红黑树？"></a>什么是红黑树？</h4><p>红黑树是一种<strong>自平衡的二叉查找树</strong>，它相对二叉搜索树增加了一个存储位来标识结点颜色。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/1460000014262656.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/1460000014262656.png" class="lazyload"></a></p><h4 id="红黑树有什么用？"><a href="#红黑树有什么用？" class="headerlink" title="红黑树有什么用？"></a>红黑树有什么用？</h4><p>用二叉查找树一般来说可以很快地查找出对应的元素，但是也有特殊情况：</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/1460000014262653.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/1460000014262653.png" class="lazyload"></a></p><p>上面符合二叉树的特性，但是它是线性的，完全没树的用处。树是要<strong>“均衡”</strong>才能将它的优点展示出来。因此，就有了<strong>平衡树</strong>（左右两个子树的高度差的绝对值不超过1）这么一个概念。红黑树就是一种平衡树，它可以<strong>保证二叉树基本符合平衡的结构</strong>，防止极端情况下时间复杂度的退化。</p><p>一个二叉查找树在插入一些结点后，就不能保证树的平衡性了，也就无法保证查找效率。那红黑树又是如何做到的呢？</p><p>红黑树背后的原理是2-3树</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/23-tree-example.png" data-fancybox="group" data-caption="2-3-tree" class="fancybox"><img alt="2-3-tree" title="2-3-tree" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/23-tree-example.png" class="lazyload"></a></p><p>背后原理有些复杂，如果工作中遇到再来深究。</p><h4 id="红黑树的应用"><a href="#红黑树的应用" class="headerlink" title="红黑树的应用"></a>红黑树的应用</h4><ul><li><p>在Java的散列表中，如果桶数满的时候，JDK8会将<strong>链表转成红黑树</strong></p></li><li><p>TreeSet、TreeMap底层都是红黑树来实现的</p></li></ul></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>148-排序链表</title>
      <link href="/2020/03/27/148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
      <url>/2020/03/27/148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p>示例 1:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4->2->1->3</span><br><span class="line">输出: 1->2->3->4</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -1->5->3->4->0</span><br><span class="line">输出: -1->0->3->4->5</span><br></pre></td></tr></tbody></table></figure></div><p>思路：要求时间空间复杂度分别为O(nlogn)和O(1)，自然想到二分法，从而联想到归并排序。但是这里是对链表进行排序，找中间节点和和合并的时候，需要注意一下。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">       <span class="comment">// 1、递归结束条件</span></span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) {</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 2、找到链表中间节点并断开链表 & 递归下探</span></span><br><span class="line">       ListNode midNode = middleNode(head);</span><br><span class="line">       ListNode rightHead = midNode.next;</span><br><span class="line">       midNode.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       ListNode left = sortList(head);</span><br><span class="line">       ListNode right = sortList(rightHead);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 3、当前层业务操作（合并有序链表）</span></span><br><span class="line">       <span class="keyword">return</span> mergeTwoLists(left, right);</span><br><span class="line">   }</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//  找到链表中间节点</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">       <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) {</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       }</span><br><span class="line">       ListNode slow = head;</span><br><span class="line">       ListNode fast = head.next.next;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (fast != <span class="keyword">null</span> && fast.next != <span class="keyword">null</span>) {</span><br><span class="line">           slow = slow.next;</span><br><span class="line">           fast = fast.next.next;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> slow;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 合并两个有序链表</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>{</span><br><span class="line">       ListNode sentry = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">       ListNode curr = sentry;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span>(l1 != <span class="keyword">null</span> && l2 != <span class="keyword">null</span>) {</span><br><span class="line">           <span class="keyword">if</span>(l1.val < l2.val) {</span><br><span class="line">               curr.next = l1;</span><br><span class="line">               l1 = l1.next;</span><br><span class="line">           } <span class="keyword">else</span> {</span><br><span class="line">               curr.next = l2;</span><br><span class="line">               l2 = l2.next;</span><br><span class="line">           }</span><br><span class="line"></span><br><span class="line">           curr = curr.next;</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">       curr.next = l1 != <span class="keyword">null</span> ? l1 : l2;</span><br><span class="line">       <span class="keyword">return</span> sentry.next;</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/2020/03/27/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/03/27/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>基于分治思想，将待排序的序列分成两个长度相等的子序列，为每一个子序列排序，然后再将他们合并成一个序列。合并两个子序列的过程也就是两路归并。</p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>归并排序是一种<strong>稳定的</strong>排序算法，但是它需要一个与待排序数组一样大的辅助数组空间。由于归并排序每次划分时两个子序列的长度基本一样，所以归并排序最好、最差和平均时间复杂度都是O(nlog2n)。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/70.gif" data-fancybox="group" data-caption="过程" class="fancybox"><img alt="过程" title="过程" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/70.gif" class="lazyload"></a></p><p>将两个排好序的子序列合并为一个序列的方法是：每次都从这两个子序列的最小值中选出一个更小值。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/70-20200327122852779.gif" data-fancybox="group" data-caption="这里写图片描述" class="fancybox"><img alt="这里写图片描述" title="这里写图片描述" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/70-20200327122852779.gif" class="lazyload"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span></span>{</span><br><span class="line">  <span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, inr end)</span></span>{</span><br><span class="line"><span class="comment">//当子序列中只有一个元素时结束递归</span></span><br><span class="line"><span class="keyword">if</span>(start < end){</span><br><span class="line"><span class="keyword">int</span> mid = (start + end)/<span class="number">2</span>;<span class="comment">//划分子序列</span></span><br><span class="line">mergeSort(a, start, mid);<span class="comment">//对左侧子序列进行排序</span></span><br><span class="line">mergeSort(a, mid+<span class="number">1</span>, end);<span class="comment">//对右侧子序列进行排序</span></span><br><span class="line">merge(a, start, mid, end);<span class="comment">//合并</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">  <span class="comment">//合并</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line"><span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];<span class="comment">//辅助数组</span></span><br><span class="line"><span class="keyword">int</span> p1 = left, p2 = mid + <span class="number">1</span>, k = left;<span class="comment">//p1,p2是检测指针，k是存放指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(p1 <= mid && p2 <= right){</span><br><span class="line"><span class="keyword">if</span>(a[p1] <= a[p2])</span><br><span class="line">tmp[k++] = a[p1++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tmp[k++] = a[p2++];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果第一个序列未检测完，直接将后面所有元素加到合并的序列中</span></span><br><span class="line"><span class="keyword">while</span>(p1 <= mid)</span><br><span class="line">tmp[k++] = a[p1++];</span><br><span class="line"><span class="keyword">while</span>(p2 <= right)</span><br><span class="line">tmp[k++] = a[p2++];</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制回原数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = left; i <= right; i++)</span><br><span class="line">a[i] = tmp[i];</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客迁移记录</title>
      <link href="/2020/03/26/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/03/26/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="GitHubPages被中间人攻击了"><a href="#GitHubPages被中间人攻击了" class="headerlink" title="GitHubPages被中间人攻击了"></a>GitHubPages被中间人攻击了</h4><p>今天上传文章后打开博客，发现无法访问了</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200326181436663.png" data-fancybox="group" data-caption="image-20200326181436663" class="fancybox"><img alt="image-20200326181436663" title="image-20200326181436663" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200326181436663.png" class="lazyload"></a></p><p>不知道什么原因，上午还好好的，下午就这样了。</p><p>找了很多资料，怀疑是GitHubPages给自定义域名颁发的证书到期了，然后我在阿里云申请了一个免费的SSL证书，绑定审核之后还是无法访问。</p><p>然后我搜了一下别人有没有类似情况，才发现</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200326181826031.png" data-fancybox="group" data-caption="image-20200326181826031" class="fancybox"><img alt="image-20200326181826031" title="image-20200326181826031" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200326181826031.png" class="lazyload"></a></p><p>而且维基百科也已经更新了这次事件</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200326181943462.png" data-fancybox="group" data-caption="image-20200326181943462" class="fancybox"><img alt="image-20200326181943462" title="image-20200326181943462" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200326181943462.png" class="lazyload"></a></p><p>只能等官方结果了，不知道什么时候能恢复。</p><h4 id="七牛云图床迁移到阿里云OSS"><a href="#七牛云图床迁移到阿里云OSS" class="headerlink" title="七牛云图床迁移到阿里云OSS"></a>七牛云图床迁移到阿里云OSS</h4><p>今天才发现，七牛云的图床分配的是测试域名，只有30天有效期，马上就到期了。要么买个阿里云服务器备案，或者借别人一个二级域名，但是都很麻烦且不长久。然后发现阿里云OSS，很便宜，而且不存在域名失效的问题。一开始想用阿里云官方的在线迁移服务（公测中需要申请），等了半天也没审核通过。想到其实直接从七牛云上批量下载下来，再批量上传就行，也就四十多张图片，所以用qshell把七牛云的图片批量下载到了本地。</p><p>接下来就是替换原来博客中的图片外链。本来想写个Java程序处理一下，但是对IO流操作不熟悉，没搞出来，思路很简单。最后直接在sublime里全局替换，也挺快的。</p><h4 id="CodingPages和GitHubPages双托管"><a href="#CodingPages和GitHubPages双托管" class="headerlink" title="CodingPages和GitHubPages双托管"></a>CodingPages和GitHubPages双托管</h4><p>配置完之后，每次部署都会同时上传到GitHub和Coding。域名解析作了修改，国外访问转向Github，国内访问转向Coding，现在的博客访问速度比之前快了很多，ping在90ms左右，之前是200以上。Coding免费颁发SLL证书，但是每3个月就会到期，需要重新申请。为了到时候重新申请方便，就把GitHubPages的解析停了，因为也基本没有国外访问的。之后如果想访问GitHub上的Pages，就使用原生的yunlong0928.github.io</p></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>消息队列总结</title>
      <link href="/2020/03/26/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/26/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="什么是消息队列？"><a href="#什么是消息队列？" class="headerlink" title="什么是消息队列？"></a>什么是消息队列？</h4><p>可以简单的理解为<strong>把要传输的数据放在队列中</strong>。把数据放到消息队列叫做<strong>生产者</strong>，从消息队列里边取数据叫做<strong>消费者</strong>。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018845304.png" data-fancybox="group" data-caption="图片来源" class="fancybox"><img alt="图片来源" title="图片来源" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018845304.png" class="lazyload"></a></p><h4 id="为什么要用消息队列？有什么好处？"><a href="#为什么要用消息队列？有什么好处？" class="headerlink" title="为什么要用消息队列？有什么好处？"></a>为什么要用消息队列？有什么好处？</h4><p>先假设一个场景：系统A做的是<strong>主要的业务</strong>，而系统B、C、D是<strong>非主要</strong>的业务。比如系统A处理的是<strong>订单下单</strong>，而系统B是订单下单成功了，那发送一条短信告诉具体的用户此订单已成功，而系统C和系统D也是处理一些小事而已。</p><ul><li><p>解耦。生产者（系统A）只负责把数据写到队列中，谁想要或不想要这个数据(消息)，生产者一点也不用关心。这样生产者（系统A）就与其他消费者（系统BCD）解耦了。</p></li><li><p>异步。生产者把数据写到消息队列中，就可以直接返回了，其他操作异步处理，无需等待</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018845311.jpeg" data-fancybox="group" data-caption="此时才用了100ms" class="fancybox"><img alt="此时才用了100ms" title="此时才用了100ms" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018845311.jpeg" class="lazyload"></a></p></li><li><p>削峰/限流。如下图，系统B和系统C<strong>根据自己的能够处理的请求数去消息队列中拿数据</strong>，这样即便有每秒有8000个请求，那只是把请求放在消息队列中，去拿消息队列的消息<strong>由系统自己去控制</strong>，这样就不会把整个系统给搞崩。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018845313.jpeg" data-fancybox="group" data-caption="写到消息队列中，系统从消息队列中拿到请求" class="fancybox"><img alt="写到消息队列中，系统从消息队列中拿到请求" title="写到消息队列中，系统从消息队列中拿到请求" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018845313.jpeg" class="lazyload"></a></p></li></ul><h4 id="使用消息队列有什么问题？为什么不能用JDK实现的队列而要用消息队列中间件？"><a href="#使用消息队列有什么问题？为什么不能用JDK实现的队列而要用消息队列中间件？" class="headerlink" title="使用消息队列有什么问题？为什么不能用JDK实现的队列而要用消息队列中间件？"></a>使用消息队列有什么问题？为什么不能用JDK实现的队列而要用消息队列中间件？</h4><ul><li><p>高可用。消息队列<strong>肯定不能是单机</strong>的。如果是单机的消息队列，万一这台机器挂了，那整个系统几乎就是不可用了。所以，当我们项目中使用消息队列，都是得<strong>集群/分布式</strong>的。要做集群/分布式就必然希望该消息队列能够提供<strong>现成</strong>的支持，而不是自己写代码手动去实现。</p></li><li><p>数据丢失问题。我们将数据写到消息队列上，系统B和C还没来得及取消息队列的数据，就挂掉了。<strong>如果没有做任何的措施，我们的数据就丢了</strong>。</p></li></ul><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018845315.jpeg" data-fancybox="group" data-caption="数据丢失问题" class="fancybox"><img alt="数据丢失问题" title="数据丢失问题" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018845315.jpeg" class="lazyload"></a>我们都知道Redis可以将数据持久化磁盘上，万一Redis挂了，还能从磁盘从将数据恢复过来。同样地，消息队列中的数据也需要存在别的地方，这样才尽可能减少数据的丢失。那存在哪呢？磁盘？数据库？Redis？分布式文件系统？同步存储还是异步存储？</p><ul><li><p>消费者怎么得到消息队列的数据？有两种办法</p><ul><li>生产者将数据放到消息队列中，消息队列有数据了，<strong>主动叫</strong>消费者去拿(俗称push)。</li><li>消费者不断去<strong>轮训</strong>消息队列，看看有没有新的数据，如果有就消费(俗称pull)</li></ul></li><li><p>其他问题。消息重复消费了怎么办啊？想保证消息是<strong>绝对</strong>有顺序的怎么做？虽然消息队列给我们带来了那么多的好处，但同时我们发现引入消息队列也会<strong>提高系统的复杂性</strong>。市面上现在已经有不少消息队列轮子了，每种消息队列都有自己的特点，<strong>选取哪种MQ还得好好斟酌</strong>。</p></li></ul></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式与集群</title>
      <link href="/2020/03/26/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E9%9B%86%E7%BE%A4/"/>
      <url>/2020/03/26/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="什么是集群？"><a href="#什么是集群？" class="headerlink" title="什么是集群？"></a>什么是集群？</h4><ul><li>多台计算机完成<strong>同样的</strong>工作，对外可以被看作一台计算机。每个节点都提供相同的服务，那么这样系统的处理能力就相当于提升了好几倍（有几个节点就相当于提升了这么多倍）。</li><li>用户的请求究竟由哪个节点来处理呢？最好能够让此时负载较小的节点来处理，一般需要在所有节点之前增加一个“调度者”的角色，用户的所有请求都先交给它，然后它根据当前所有节点的负载情况，决定将这个请求交给哪个节点处理。这个“调度者”就是——负载均衡服务器</li><li>从单机结构到集群结构，你的代码基本无需要作任何修改，你要做的仅仅是多部署几台服务器，每台服务器部署相同的代码就可以</li></ul><h4 id="什么是分布式？"><a href="#什么是分布式？" class="headerlink" title="什么是分布式？"></a>什么是分布式？</h4><ul><li>一个业务分拆多个子业务，部署在不同的服务器上(不同的服务器运行不同的代码，为了同一个目的)</li><li>可以将每个模块抽取独立出来，访问量大的模块用好的服务器，访问少的模块用差的服务器。这样的好处是：一、资源合理利用了。二、耦合度降低了：每个模块独立出来，各干各的事，便于扩展</li><li>假设需要开发一个在线商城。按照微服务的思想，我们需要按照功能模块拆分成多个独立的服务，如：用户服务、产品服务、订单服务、后台管理服务、数据分析服务等等。这一个个服务都是一个个独立的项目，可以独立运行。如果服务之间有依赖关系，那么通过RPC方式调用。</li></ul><h5 id="分布式和集群的区别？"><a href="#分布式和集群的区别？" class="headerlink" title="分布式和集群的区别？"></a>分布式和集群的区别？</h5><ul><li><strong>分布式不一定就是不同的组件，同一个组件也可以</strong>，关键在于是否通过交换信息的方式进行协作。分布式是指通过网络连接的多个组件，通过交换信息协作而形成的系统。而集群，是指同一种组件的多个实例，形成的逻辑上的整体。</li><li><strong>分布式系统也可以是一个集群</strong>。例子就是zookeeper等，它的特征是服务之间会互相通信协作。</li><li><strong>分布式系统也可以不是集群</strong>。就是多个不同组件构成的系统</li><li><strong>集群也可以不是分布式系统</strong>。比如多个经过负载均衡的HTTP服务器，它们之间不会互相通信，如果不带上负载均衡的部分的话，一般不叫做分布式系统。</li></ul><h5 id="分布式-微服务-SOA，这三个概念其实差不多"><a href="#分布式-微服务-SOA，这三个概念其实差不多" class="headerlink" title="分布式/微服务/SOA，这三个概念其实差不多"></a>分布式/微服务/SOA，这三个概念其实差不多</h5><ul><li><p><strong>分布式</strong>：不同模块部署在不同服务器上<br>作用：分布式解决网站高并发带来问题</p></li><li><p><strong>SOA</strong>：业务系统分解为多个组件，让每个组件都独立提供离散，自治，可复用的服务能力，通过服务的组合和编排来实现上层的业务流程<br>作用：简化维护,降低整体风险,伸缩灵活</p></li><li><p><strong>微服务</strong>：架构设计概念,各服务间隔离（分布式也是隔离）,自治（分布式依赖整体组合）其它特性(单一职责,边界,异步通信,独立部署)是分布式概念的跟严格执行SOA到微服务架构的演进过程<br>作用：各服务可独立应用，组合服务也可系统应用</p></li></ul><h4 id="CAP理论："><a href="#CAP理论：" class="headerlink" title="CAP理论："></a>CAP理论：</h4><ul><li>数据一致性。<strong>所有</strong>节点拥有数据的最新版本</li><li>可用性。数据具备高可用性</li><li>分区容错性。<strong>容忍网络出现分区</strong>，分区之间网络不可达</li></ul><p>分布式系统节点之间的通信是通过网络来进行的。<strong>只要是分布式系统</strong>，那很有可能会出现一种情况：因为一些<strong>故障</strong>，使得有些<strong>节点之间不连通</strong>了，整个网络就分成了<strong>几块区域</strong>。所以<strong>CAP是无法完全兼顾的</strong>。</p><h4 id="为什么需要SpringCloud？"><a href="#为什么需要SpringCloud？" class="headerlink" title="为什么需要SpringCloud？"></a>为什么需要SpringCloud？</h4><p>一个大项目拆分出多个模块以后，会出现各种各样的问题，SpringCloud提供了一整套解决方案</p><p>SpringCloud的<strong>基础功能</strong>：</p><ul><li>服务治理： Spring Cloud Eureka</li><li>客户端负载均衡： Spring Cloud Ribbon</li><li>服务容错保护： Spring Cloud Hystrix</li><li>声明式服务调用： Spring Cloud Feign</li><li>API网关服务：Spring Cloud Zuul</li><li>分布式配置中心： Spring Cloud Config</li></ul><p>SpringCloud的高级功能：</p><ul><li>消息总线： Spring Cloud Bus</li><li>消息驱动的微服务： Spring Cloud Stream</li><li>分布式服务跟踪： Spring Cloud Sleuth</li></ul><h5 id="Eureka是做什么的？为什么需要Eureka？"><a href="#Eureka是做什么的？为什么需要Eureka？" class="headerlink" title="Eureka是做什么的？为什么需要Eureka？"></a>Eureka是做什么的？为什么需要Eureka？</h5><p>分布式的子系统之间不在同一个环境下，需要远程调用，比如A服务调用B服务，代码里要<strong>显式地通过IP地址调用</strong>：<code>http://123.123.123.123:8888/user/1</code></p><p>B服务又可能需要调用C服务。也就是各个服务之间有耦合。如果B服务的IP地址变了，其他服务就得手动更新。服务多的情况下，维护这些配置就变的很麻烦。</p><p>为了解决微服务架构中的<strong>服务实例维护问题(ip地址)</strong>，就需要Eureka了。</p><h5 id="Eureka是怎么解决这个问题的？"><a href="#Eureka是怎么解决这个问题的？" class="headerlink" title="Eureka是怎么解决这个问题的？"></a>Eureka是怎么解决这个问题的？</h5><p>我们现在的问题是：现在有A、B、C、D四个服务，它们之间会互相调用(而且IP地址很可能会发生变化)，一旦某个服务的IP地址变了，那服务中的代码要跟着变，手动维护这些静态配置(IP)非常麻烦。</p><p>Eureka会创建一个E服务，将A、B、C、D四个服务的信息都<strong>注册</strong>到E服务上，E服务维护这些已经注册进来的信息</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/view.png" data-fancybox="group" data-caption="preview" class="fancybox"><img alt="preview" title="preview" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/view.png" class="lazyload"></a></p><p>A、B、C、D四个服务都可以<strong>拿到</strong>Eureka(服务E)那份<strong>注册清单</strong>。A、B、C、D四个服务互相调用不再通过具体的IP地址，而是<strong>通过服务名来调用</strong>。</p><p>Eureka的细节：</p><p>Eureka专门用于给其他服务注册的称为Eureka Server(服务注册中心)，其余注册到Eureka Server的服务称为Eureka Client。Eureka Client<strong>分为服务提供者和服务消费者</strong>。但很可能，某服务<strong>既是服务提供者又是服务消费者</strong>。单纯的服务消费者可以不在Eureka-Server注册。</p><p>Eureka的治理机制：</p><ul><li><p>服务提供者</p><ul><li><strong>服务注册：</strong>启动的时候会通过发送REST请求的方式将<strong>自己注册到Eureka Server上</strong>，同时带上了自身服务的一些元数据信息。</li><li><strong>服务续约：</strong>在注册完服务之后，<strong>服务提供者会维护一个心跳</strong>用来持续告诉Eureka Server: “我还活着 ” 。</li><li><strong>服务下线：</strong>当服务实例进行正常的关闭操作时，它会<strong>触发一个服务下线的REST请求</strong>给Eureka Server, 告诉服务注册中心：“我要下线了 ”。</li></ul></li><li><p>服务消费者</p><ul><li><strong>获取服务：</strong>当我们<strong>启动服务消费者</strong>的时候，它会发送一个REST请求给服务注册中心，来获取上面注册的服务清单</li><li><strong>服务调用：</strong>服务消费者在获取服务清单后，通过<strong>服务名</strong>可以获得具体提供服务的实例名和该实例的元数据信息。在进行服务调用的时候，<strong>优先访问同处一个Zone中的服务提供方</strong>。</li></ul></li><li><p>Eureka Server(服务注册中心)</p><ul><li><strong>失效剔除：</strong>默认每隔一段时间（默认为60秒） 将当前清单中超时（默认为90秒）<strong>没有续约的服务剔除出去</strong>。</li><li><strong>自我保护：</strong>。EurekaServer 在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%(通常由于网络不稳定导致)。 Eureka Server会将当前的<strong>实例注册信息保护起来</strong>， 让这些实例不会过期，尽可能<strong>保护这些注册信息</strong>。</li></ul></li></ul><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000016157677.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000016157677.png" class="lazyload"></a></p><h5 id="Ribbon是做什么的？"><a href="#Ribbon是做什么的？" class="headerlink" title="Ribbon是做什么的？"></a>Ribbon是做什么的？</h5><p>为了实现服务的<strong>高可用</strong>，我们可以将<strong>服务提供者集群</strong>。集群就要用到负载均衡来合理分担用户的请求。</p><p>负载均衡又区分了两种类型：</p><ul><li>客户端负载均衡(Ribbon)<ul><li>服务实例的<strong>清单在客户端</strong>，客户端进行负载均衡算法分配。</li><li>(从上面的知识我们已经知道了：客户端可以从Eureka Server中得到一份服务清单，在发送请求时通过负载均衡算法，<strong>在多个服务器之间选择一个进行访问</strong>)</li></ul></li><li>服务端负载均衡(Nginx)<ul><li>服务实例的<strong>清单在服务端</strong>，服务器进行负载均衡算法分配</li></ul></li></ul><p>SpringCloud也支持负载均衡功能，只不过它是<strong>客户端的负载均衡</strong>，这个功能实现就是Ribbon！</p><h5 id="Hystrix是做什么的？"><a href="#Hystrix是做什么的？" class="headerlink" title="Hystrix是做什么的？"></a>Hystrix是做什么的？</h5><p>如果我们在<strong>调用多个远程服务时，某个服务出现延迟</strong>，在<strong>高并发</strong>的情况下，由于单个服务的延迟，可能导致<strong>所有的请求都处于延迟状态</strong>，甚至在几秒钟就使服务处于负载饱和的状态，资源耗尽，直到不可用，最终导致这个分布式系统都不可用，这就是“雪崩”。Spring Cloud Hystrix实现了<strong>断路器、线程隔离</strong>等一系列服务保护功能，提高容错。</p><h5 id="Feign是做什么的？"><a href="#Feign是做什么的？" class="headerlink" title="Feign是做什么的？"></a>Feign是做什么的？</h5><p>Feign整合了Ribbon和Hystrix，而且还提供了<strong>声明式的服务调用</strong>(不再通过RestTemplate)，达到使用HTTP请求远程服务时能与调用本地方法一样的编码体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求。</p><p>根据上面的内容，我们设计出来的架构可能是这样</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000016157688.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000016157688.png" class="lazyload"></a></p><p>SpringCloud的其他基础功能还有Zuul和Config，但是没有实践过，没有具体场景，不是很好理解，等到以后用到了再研究吧</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 集群 </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis总结</title>
      <link href="/2020/03/26/Redis%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/26/Redis%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="Redis是什么？"><a href="#Redis是什么？" class="headerlink" title="Redis是什么？"></a>Redis是什么？</h4><p>Redis是一个开源的，<strong>基于内存的数据结构存储</strong>，可用作于数据库、<strong>缓存</strong>、消息中间件。从经验上来看，常用作缓存</p><h4 id="为什么要用Redis？"><a href="#为什么要用Redis？" class="headerlink" title="为什么要用Redis？"></a>为什么要用Redis？</h4><h5 id="为什么要用缓存？"><a href="#为什么要用缓存？" class="headerlink" title="为什么要用缓存？"></a>为什么要用缓存？</h5><p>如果网站出现了性能问题(访问时间慢)，一般是由于<strong>数据库撑不住了</strong>。因为一般数据库的读写都是要经过<strong>磁盘</strong>的，而磁盘的速度相对内存来说是很慢的。有了缓存就不用每次读取的时候都查一次数据库。就想CPU的一级缓存，二级缓存一样，思想是一样的。</p><h5 id="为什么不能用Map做缓存？"><a href="#为什么不能用Map做缓存？" class="headerlink" title="为什么不能用Map做缓存？"></a>为什么不能用Map做缓存？</h5><p>如果自己设计一个缓存，可能会这样设计</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get value from cache</span></span><br><span class="line">String value = map.get(<span class="string">"someKey"</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == value) {</span><br><span class="line">  <span class="comment">// get value from DataBase</span></span><br><span class="line">  value = queryValueFromDB(<span class="string">"someKey"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>但是Java自带的map或者guava是本地缓存，而且生命周期会随着JVM的销毁而结束。redis或memcached之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据。此外还有这些原因：</p><ul><li>Redis 可以用几十 G 内存来做缓存，Map 不行，一般 JVM 也就分几个 G 数据就够大。</li><li>Redis 的缓存可以持久化，Map 是内存对象，程序一重启数据就没了。</li><li>dis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象。</li><li>Redis 缓存有过期机制，Map 本身无此功能。</li><li>Redis 有丰富的 API，Map 就简单太多了</li></ul><h4 id="什么时候用Redis集群？"><a href="#什么时候用Redis集群？" class="headerlink" title="什么时候用Redis集群？"></a>什么时候用Redis集群？</h4><p>用一台Redis缓存服务器可能会出现两个问题：</p><ul><li><strong>Redis内存不足</strong>：随着使用Redis的客户端越来越多，Redis上的缓存数据也越来越大，而一台机器的内存毕竟是有限的，放不了那么多数据。</li><li><strong>Redis吞吐量低</strong>：客户端变多了，可Redis还是只有一台，而且Redis是单线程的。这就好比我开了一家饭店，一开始每天只有100位客人，我雇一位服务员就可以，后来生意好了，每天有1000位客人，可我还是只雇一位服务员。<strong>一台机器的带宽和处理器都是有限的</strong>，Redis自然会忙不过来，吞吐量已经不足以支撑越来越庞大的系统</li></ul><p>所以这时候，就可以使用Redis集群。客户端的请求会通过负载均衡算法（通常是一致性Hash），分散到各个Redis服务器上。</p><h4 id="Redis集群存在的问题"><a href="#Redis集群存在的问题" class="headerlink" title="Redis集群存在的问题"></a>Redis集群存在的问题</h4><ul><li><strong>数据可用性差</strong>：如果其中一台Redis挂了，那么上面全部的缓存数据都会丢失，导致原来可以从缓存中获取的请求，都去访问数据库了，数据库压力陡增。</li><li><strong>数据查询缓慢</strong>：监测发现，每天有一段时间，Redis 1的访问量非常高，而且大多数请求都是去查一个相同的缓存数据，导致Redis 1非常忙碌，吞吐量不足以支撑这个高的查询负载。</li></ul><p>其实就是主从复制问题。解决办法可以是数据库里头经常用到的<strong>Master-Slave模式</strong>，给每一台Redis都加上一台Slave。</p><h4 id="Redis还有哪些问题？"><a href="#Redis还有哪些问题？" class="headerlink" title="Redis还有哪些问题？"></a>Redis还有哪些问题？</h4><ul><li><strong>数据结构。</strong>Redis不仅仅是数据存储器，而是数据结构存储器。Redis支持客户端直接往里面塞各种类型的数据结构，比如String、List、Set、SortedSet、Map等等。</li><li><strong>剔除策略。</strong>缓存数据不能无限增长，总得剔除掉一些数据，好让新的缓存数据放进来，这就需要LRU算法了</li><li><strong>负载均衡</strong>。用到了集群，就免不了需要用到负载均衡，用什么负载均衡算法？在哪里使用负载均衡？</li><li><strong>Presharding。</strong>如果一开始只有三台Redis服务器，后来发现需要加多一台才能满足业务需要，要怎么办？</li><li><strong>数据持久化。</strong>如果机器突然全部断电了，缓存数据还能恢复吗？可以的</li><li><strong>数据同步。</strong></li></ul><p>如果不想安装环境，可以在这里<a href="http://try.redis.io/" target="_blank" rel="noopener">TryRedis</a>熟悉一下Redis的操作和指令</p></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZooKeeper总结</title>
      <link href="/2020/03/26/ZooKeeper%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/26/ZooKeeper%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="什么是Zookeeper？可以用来做什么？"><a href="#什么是Zookeeper？可以用来做什么？" class="headerlink" title="什么是Zookeeper？可以用来做什么？"></a>什么是Zookeeper？可以用来做什么？</h4><p>使用分布式系统无法避免对节点管理的问题(需要<strong>实时感知节点的状态</strong>、对<strong>节点进行统一管理</strong>等等)，而由于这些问题处理起来可能相对麻烦和提高了系统的复杂性，ZooKeeper中间件就是用来解决分布式系统中的这些通用基础问题的。</p><p>ZooKeeper的主要功能有：统一配置管理、统一命名服务、分布式锁、集群管理。</p><h4 id="Zookeeper自身的结构和机制"><a href="#Zookeeper自身的结构和机制" class="headerlink" title="Zookeeper自身的结构和机制"></a>Zookeeper自身的结构和机制</h4><p>ZooKeeper的<strong>数据结构</strong>，可以看做是一颗<strong>树</strong>，每个节点叫做<strong>ZNode</strong>。每一个节点可以通过<strong>路径</strong>来标识。</p><p>Znode分为<strong>两种</strong>类型：</p><ul><li><strong>短暂/临时(Ephemeral)</strong>：当客户端和服务端断开连接后，所创建的Znode(节点)<strong>会自动删除</strong></li><li><strong>持久(Persistent)</strong>：当客户端和服务端断开连接后，所创建的Znode(节点)<strong>不会删除</strong></li></ul><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876288.jpeg" data-fancybox="group" data-caption="Znode和Znode的类型" class="fancybox"><img alt="Znode和Znode的类型" title="Znode和Znode的类型" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876288.jpeg" class="lazyload"></a></p><p>ZooKeeper和Redis一样，也是C/S结构(分成客户端和服务端)</p><p>另外一个是<strong>监听器</strong></p><p><strong>常见</strong>的监听场景有以下两项：</p><ul><li>监听Znode节点的<strong>数据变化</strong></li><li>监听子节点的<strong>增减变化</strong></li></ul><p>通过<strong>监听+Znode节点(持久/短暂[临时])</strong>，ZooKeeper就能实现上面那么多功能了。</p><h4 id="具体怎么做？"><a href="#具体怎么做？" class="headerlink" title="具体怎么做？"></a>具体怎么做？</h4><h5 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h5><p>我们可以将配置文件放在ZooKeeper的Znode节点中，其他系统监听着这个Znode节点有无变更，如果变更了，<strong>及时</strong>响应。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876292.jpeg" data-fancybox="group" data-caption="系统A、B、C监听着ZooKeeper的节点，一旦common.yml内容有变化，及时响应" class="fancybox"><img alt="系统A、B、C监听着ZooKeeper的节点，一旦common.yml内容有变化，及时响应" title="系统A、B、C监听着ZooKeeper的节点，一旦common.yml内容有变化，及时响应" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876292.jpeg" class="lazyload"></a></p><h5 id="统一命名管理"><a href="#统一命名管理" class="headerlink" title="统一命名管理"></a>统一命名管理</h5><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876293.jpeg" data-fancybox="group" data-caption="通过名称去访问旗下的IP" class="fancybox"><img alt="通过名称去访问旗下的IP" title="通过名称去访问旗下的IP" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876293.jpeg" class="lazyload"></a></p><h5 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h5><p>比如系统A，B，C都去访问/locks节点</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876294.jpeg" data-fancybox="group" data-caption="系统A、B、C都去访问locks节点" class="fancybox"><img alt="系统A、B、C都去访问locks节点" title="系统A、B、C都去访问locks节点" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876294.jpeg" class="lazyload"></a></p><p>访问的时候会创建<strong>带顺序号的临时/短暂</strong>(<code>EPHEMERAL_SEQUENTIAL</code>)节点，比如，系统A创建了<code>id_000000</code>节点，系统B创建了<code>id_000002</code>节点，系统C创建了<code>id_000001</code>节点。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876295.jpeg" data-fancybox="group" data-caption="创建出临时带顺序号的节点" class="fancybox"><img alt="创建出临时带顺序号的节点" title="创建出临时带顺序号的节点" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876295.jpeg" class="lazyload"></a></p><p>接着，拿到/locks节点下的所有子节点(id_000000,id_000001,id_000002)，<strong>判断自己创建的是不是最小的那个节点</strong></p><p>如果是，则拿到锁（执行完操作后，把创建的节点给删掉，也就是释放锁）</p><p>如果不是，则监听比自己要小1的节点变化</p><p>例如：</p><ul><li>系统A拿到/locks节点下的所有子节点，经过比较，发现自己(<code>id_000000</code>)，是所有子节点最小的。所以得到锁</li><li>系统B拿到/locks节点下的所有子节点，经过比较，发现自己(<code>id_000002</code>)，不是所有子节点最小的。所以监听比自己小1的节点<code>id_000001</code>的状态</li><li>系统C拿到<code>/locks</code>节点下的所有子节点，经过比较，发现自己(<code>id_000001</code>)，不是所有子节点最小的。所以监听比自己小1的节点<code>id_000000</code>的状态</li><li>……</li><li>等到系统A执行完操作以后，将自己创建的节点删除(<code>id_000000</code>)。通过监听，系统C发现<code>id_000000</code>节点已经删除了，发现自己已经是最小的节点了，于是顺利拿到锁</li><li>….系统B如上</li></ul><h5 id="集群状态"><a href="#集群状态" class="headerlink" title="集群状态"></a>集群状态</h5><p>还是以三个系统A、B、C为例，在ZooKeeper中创建<strong>临时节点</strong>即可</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876296.jpeg" data-fancybox="group" data-caption="各维护一个临时节点" class="fancybox"><img alt="各维护一个临时节点" title="各维护一个临时节点" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/1460000018876296.jpeg" class="lazyload"></a></p><p>只要系统A挂了，那<code>/groupMember/A</code>这个节点就会删除，通过<strong>监听</strong><code>groupMember</code>下的子节点，系统B和C就能够感知到系统A已经挂了。(新增也是同理)</p></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> ZooKeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合框架总结</title>
      <link href="/2020/03/26/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/26/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>集合框架分两类，继承Collection接口的，和继承Map接口的</p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/WX20200328-170608@2x.png" data-fancybox="group" data-caption="WX20200328-170608@2x" class="fancybox"><img alt="WX20200328-170608@2x" style="zoom:50%;" title="WX20200328-170608@2x" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/WX20200328-170608@2x.png" class="lazyload"></a><h2 id="Collection介绍"><a href="#Collection介绍" class="headerlink" title="Collection介绍"></a>Collection介绍</h2><h3 id="为什么需要Collection？"><a href="#为什么需要Collection？" class="headerlink" title="为什么需要Collection？"></a>为什么需要Collection？</h3><p>存储多个对象。常⽤的容器有StringBuffffered,数组，虽然也有对象数组，但是数组的⻓度是不可变的。</p><h3 id="数组和集合的区别"><a href="#数组和集合的区别" class="headerlink" title="数组和集合的区别"></a>数组和集合的区别</h3><ul><li>⻓度的区别。数组的⻓度固定，集合的⻓度可变</li><li>内容不同。数组存储的是同⼀种类型的元素，集合可以存储不同类型的元素(但是⼀般我们不这样做)</li><li>元素的数据类型。数组可以存储基本数据类型,也可以存储引⽤类型。集合只能存储引⽤类型<strong>(</strong>如果是简单的<strong>int</strong>，它会⾃动装箱成<strong>Integer)</strong></li></ul><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200328165706553.png" data-fancybox="group" data-caption="image-20200328165706553" class="fancybox"><img alt="image-20200328165706553" style="zoom: 50%;" title="image-20200328165706553" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200328165706553.png" class="lazyload"></a><p>集合框架有一些基础的通用功能，比如增加删除等，Collection就是其他数据结构都需要继承的接口</p><h3 id="Collection的基础功能"><a href="#Collection的基础功能" class="headerlink" title="Collection的基础功能"></a>Collection的基础功能</h3><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200328170011206.png" data-fancybox="group" data-caption="image-20200328170011206" class="fancybox"><img alt="image-20200328170011206" style="zoom:50%;" title="image-20200328170011206" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200328170011206.png" class="lazyload"></a><h3 id="迭代器Iterator介绍"><a href="#迭代器Iterator介绍" class="headerlink" title="迭代器Iterator介绍"></a>迭代器Iterator介绍</h3><p>Collection的源码中继承了Iterable，有iterator()这个⽅法，作用是遍历元素。又因为不同的数据结构遍历的方式可能不同，所以Iterator接口一般在实现类中实现，比如ArrayList，LinkedList等</p><h2 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h2><ul><li>ArrayList 底层数据结构是数组。线程不安全 </li><li>LinkedList 底层数据结构是链表。线程不安全</li><li>Vector 底层数据结构是数组。线程安全</li></ul><h3 id="ArrayList解析"><a href="#ArrayList解析" class="headerlink" title="ArrayList解析"></a>ArrayList解析</h3><p>ArrayList底层是一个数组，可以扩容，所以能实现动态增长。</p><ul><li>构造方法。如果指定了容量，数组就初始化成对应的容量</li><li><strong>add方法</strong><ul><li>add(E e) ：⾸先去检查⼀下数组的容量是否⾜够，如果足够就直接添加，如果不够就扩容到原来的1.5倍。第⼀次扩容后，如果容量还是⼩于minCapacity（数组所需要的最小容量），就将容量扩充为minCapacity。</li><li>add(int index, E element) ： 检查⻆标，然后检查空间，如果有需要进⾏扩容。最后插入元素</li></ul></li><li>get方法。检查角标是否在正常范围，返回元素</li><li>set方法。检查角标，替代元素，返回旧值</li><li><strong>remove方法：</strong> 检查⻆标，删除元素，计算出需要移动的元素个数并移动，设置为null，让Gc回收</li></ul><p>细节补充：</p><ul><li><p>ArrayList是基于动态数组实现的，在增（扩容时调用Arrays.copyof）删（调用System.arraycopy）的时候，需要对数组拷⻉复制。</p></li><li><p>ArrayList的默认初始化容量是<strong>10</strong>，每次扩容时候增加原先容量的⼀半，也就是变为原来的<strong>1.5</strong>倍</p></li><li><p>删除元素时不会减少容量，若希望减少容量则调⽤<strong>trimToSize()</strong></p></li><li><p>它不是线程安全的。它能存放null值。</p></li></ul><h3 id="Vector与ArrayList的区别"><a href="#Vector与ArrayList的区别" class="headerlink" title="Vector与ArrayList的区别"></a>Vector与ArrayList的区别</h3><ul><li>Vector是jdk1.2的类了，⽐较⽼旧的⼀个集合类。</li><li>Vector底层也是数组，与ArrayList最⼤的区别就是：<strong>同步(线程安全)</strong>。方法上加了synchronized</li><li>ArrayList在底层数组不够⽤时在原来的基础上扩展<strong>0.5</strong>倍，<strong>Vector</strong>是扩展<strong>1</strong>倍。</li></ul><h3 id="LinkedList解析"><a href="#LinkedList解析" class="headerlink" title="LinkedList解析"></a>LinkedList解析</h3><p>LinkedList底层是<strong>双向链表</strong>，实现了<strong>Deque</strong>接⼝，可以像操作队列和栈⼀样操作LinkedList</p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200402205602940.png" data-fancybox="group" data-caption="image-20200402205602940" class="fancybox"><img alt="image-20200402205602940" style="zoom:50%;" title="image-20200402205602940" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200402205602940.png" class="lazyload"></a><ul><li><p>构造方法。无参数或者传入一个Collection的集合</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200402205820745.png" data-fancybox="group" data-caption="image-20200402205820745" class="fancybox"><img alt="image-20200402205820745" title="image-20200402205820745" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200402205820745.png" class="lazyload"></a></p></li><li><p>add方法。实际上就是往链表最后添加元素</p></li><li><p>remove方法。参数是一个Objec，遍历时用equals方法找到这个元素，然后执行下面的操作</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200402210142936.png" data-fancybox="group" data-caption="image-20200402210142936" class="fancybox"><img alt="image-20200402210142936" title="image-20200402210142936" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200402210142936.png" class="lazyload"></a></p></li><li><p>get方法。传入一个坐标，如果坐标小于长度的一半，就从头遍历，否则从尾遍历</p></li><li><p>set方法。和get类似</p></li></ul><h3 id="List集合总结"><a href="#List集合总结" class="headerlink" title="List集合总结"></a>List集合总结</h3><ul><li><p><strong>ArrayList</strong>：</p><ul><li>底层实现是数组</li><li>ArrayList的默认初始化容量是10，每次扩容时候增加原先容量的⼀半，也就是变为原来的1.5倍 </li><li>在增删时候，需要数组的拷⻉复制<strong>(navite</strong> ⽅法由<strong>C/C++</strong>实现<strong>)</strong></li></ul></li><li><p><strong>LinkedList</strong>：</p><ul><li>底层实现是双向链表（⽅便实现往前遍历）</li></ul></li><li><p><strong>Vector</strong>：</p><ul><li>底层是数组，现在已少⽤，被ArrayList替代，原因有两个：<ol><li>Vector所有⽅法都是同步，有性能损失。</li><li>Vector初始length是10 超过length时 以100%⽐率增⻓，相⽐于<strong>ArrayList</strong>更多消耗内存。</li></ol></li></ul></li></ul><p>总的来说：查询多⽤<strong>ArrayList</strong>，增删多⽤<strong>LinkedList</strong>。</p><p><strong>但ArrayList</strong>增删慢不是绝对的：</p><ul><li><p>如果增加元素⼀直是使⽤ add (增加到末尾)的话，那是ArrayList要快</p></li><li><p>⼀直删除末尾的元素也是<strong>ArrayList</strong>要快（不⽤复制移动位置）</p></li></ul><h2 id="Map介绍"><a href="#Map介绍" class="headerlink" title="Map介绍"></a><strong>Map介绍</strong></h2><p>常用功能：</p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200404105527582.png" data-fancybox="group" data-caption="image-20200404105527582" class="fancybox"><img alt="image-20200404105527582" style="zoom:50%;" title="image-20200404105527582" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200404105527582.png" class="lazyload"></a><p>值得关注的四个实现类：HashMap，ConcurrentHashMap，LinkedHashMap，TreeMap</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200404105603024.png" data-fancybox="group" data-caption="image-20200404105603024" class="fancybox"><img alt="image-20200404105603024" title="image-20200404105603024" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/blog2/image-20200404105603024.png" class="lazyload"></a></p><p>如果散列表太满，是需要对散列表再散列，创建⼀个桶数更多的散列表，并将原有的元素插⼊到新表</p><p>中，丢弃原来的表~</p><p>装填因⼦(load factor)决定了何时对散列表再散列~</p><p>装填因⼦默认为0.75，如果表中超过了<strong>75%</strong>的位置已经填⼊了元素，那么这个表就会⽤双倍的桶数</p><p>⾃动进⾏再散列</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>150-逆波兰表达式求值</title>
      <link href="/2020/03/26/150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
      <url>/2020/03/26/150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>计算逆波兰式（后缀表达式）的值</p><p>运算符仅包含”+”,”-“,”*”和”/“，被操作数可能是整数或其他表达式</p><p>例如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">["2", "1", "+", "3", "*"] -> ((2 + 1) * 3) -> 9</span><br><span class="line">["4", "13", "5", "/", "+"] -> (4 + (13 / 5)) -> 6</span><br></pre></td></tr></tbody></table></figure></div><p>思路：</p><blockquote><p>从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 op 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</p></blockquote><p>例如后缀表达式“3 4 + 5 × 6 -”：</p><ol><li>从左至右扫描，将3和4压入堆栈；</li><li>遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素，注意与前缀表达式做比较），计算出3+4的值，得7，再将7入栈；</li><li>将5入栈；</li><li>接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</li><li>将6入栈；</li><li>最后是-运算符，计算出35-6的值，即29，由此得出最终结果。</li></ol><p>这里用了Integer.parseInt的异常来判断是否是数字，用别的方式也可以</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>{</span><br><span class="line">        Stack<integer> stack = <span class="keyword">new</span> Stack<>();</integer></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < tokens.length; i++){</span><br><span class="line">            <span class="keyword">try</span>{</span><br><span class="line">              <span class="comment">//如果是数字，入栈</span></span><br><span class="line">                <span class="keyword">int</span> num = Integer.parseInt(tokens[i]);</span><br><span class="line">                stack.add(num);</span><br><span class="line">            }<span class="keyword">catch</span> (Exception e) {</span><br><span class="line">              <span class="comment">//如果是操作符，弹出栈顶两个元素，求值，再入栈</span></span><br><span class="line">                <span class="keyword">int</span> b = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> a = stack.pop();</span><br><span class="line">                stack.add(get(a, b, tokens[i]));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">      <span class="comment">//最后的结果在栈里</span></span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//根据a,b和操作数计算值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, String operator)</span></span>{</span><br><span class="line">        <span class="keyword">switch</span> (operator) {</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">            <span class="keyword">return</span> a+b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">            <span class="keyword">return</span> a-b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">            <span class="keyword">return</span> a*b;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">            <span class="keyword">return</span> a/b;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solr总结</title>
      <link href="/2020/03/25/Solr%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/25/Solr%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/Center.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/Center.png" class="lazyload"></a></p><p>在solr中如果要搜索 word1 那么就出 返回 doc1 和 doc2 如果 搜索 word1 和 word3 那么就会做一个交叉，返回doc2。</p></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>111-二叉树的最小深度</title>
      <link href="/2020/03/25/111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/"/>
      <url>/2020/03/25/111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>求给定二叉树的最小深度。最小深度是指树的根结点到最近叶子结点的最短路径上结点的数量。</p><p>思路：感觉层次遍历和广度优先搜索有点类似，没体会到区别在哪</p><p>BFS标准解法（非递归）：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) { val = x; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue<treenode> q = <span class="keyword">new</span> LinkedList<>();</treenode></span><br><span class="line">        <span class="comment">//当前层的个数</span></span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//下一层的个数</span></span><br><span class="line">        <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前所在层</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">        q.offer(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()){</span><br><span class="line">            TreeNode t = q.poll();</span><br><span class="line">          <span class="comment">//当前层结点个数减一</span></span><br><span class="line">            cur--;</span><br><span class="line">          <span class="comment">//如果找到一个叶子结点，提前退出</span></span><br><span class="line">            <span class="keyword">if</span>(t.left == <span class="keyword">null</span> && t.right == <span class="keyword">null</span>) <span class="keyword">return</span> index;</span><br><span class="line">          <span class="comment">//检查左子结点</span></span><br><span class="line">            <span class="keyword">if</span>(t.left != <span class="keyword">null</span>){</span><br><span class="line">              <span class="comment">//入队</span></span><br><span class="line">                q.offer(t.left);</span><br><span class="line">              <span class="comment">//下一层结点个数加一</span></span><br><span class="line">                next++;</span><br><span class="line">            }</span><br><span class="line">          <span class="comment">//检查右子结点</span></span><br><span class="line">            <span class="keyword">if</span>(t.right != <span class="keyword">null</span>){</span><br><span class="line">                q.offer(t.right);</span><br><span class="line">                next++;</span><br><span class="line">            }</span><br><span class="line">          <span class="comment">//如果当前层全部遍历了</span></span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="number">0</span>){</span><br><span class="line">                <span class="comment">//获取下一层个数</span></span><br><span class="line">                cur = next;</span><br><span class="line">                <span class="comment">//下一层从0开始</span></span><br><span class="line">                next = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//层数加一</span></span><br><span class="line">                index++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>普通递归：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//if(root.left == null && root.right == null)</span></span><br><span class="line">        <span class="comment">//    return 1;</span></span><br><span class="line">        <span class="keyword">int</span> left = run(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = run(root.right);</span><br><span class="line">      <span class="comment">//注意这里，很巧妙</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> || right == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> left + right + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.min(left, right) + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>非递归层序遍历解法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> && root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        Queue<treenode> queue = <span class="keyword">new</span> LinkedList<>();</treenode></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">            <span class="keyword">int</span> len = queue.size();</span><br><span class="line">            depth++;</span><br><span class="line">          <span class="comment">//一次取一层</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < len; i++){</span><br><span class="line">                TreeNode cur = queue.poll();           </span><br><span class="line">                <span class="keyword">if</span>(cur.left == <span class="keyword">null</span> && cur.right == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="keyword">null</span>)</span><br><span class="line">                    queue.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="keyword">null</span>)</span><br><span class="line">                    queue.offer(cur.right);</span><br><span class="line">            }              </span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> 层序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-按摩师</title>
      <link href="/2020/03/24/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%89%E6%91%A9%E5%B8%88/"/>
      <url>/2020/03/24/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8C%89%E6%91%A9%E5%B8%88/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。</p><p>注意：本题相对原题稍作改动 </p><p>示例 1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [1,2,3,1]</span><br><span class="line">输出： 4</span><br><span class="line">解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [2,7,9,3,1]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。</span><br></pre></td></tr></tbody></table></figure></div><p>示例 3：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入： [2,1,4,5,3,1,1,3]</span><br><span class="line">输出： 12</span><br><span class="line">解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。</span><br></pre></td></tr></tbody></table></figure></div><p>思路：</p><p>递推方程：dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])</p><p>空间O(n)的写法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i < n; i++){</span><br><span class="line">            dp[i] = Math.max(nums[i] + dp[i-<span class="number">2</span>], dp[i-<span class="number">1</span>]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>空间优化到O(1)的写法</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < nums.length; i++) {</span><br><span class="line">            <span class="keyword">int</span> c = Math.max(b, a + nums[i]);</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>我最开始的写法，超出时间限制了。对动态规划理解的不够深，想用一种回溯法来选择。我写的和动态规划，路径树都是一样的，但我这种要遍历整个树，动态规划用DP做了剪枝。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">massage</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> serve(nums, <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">serve</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(i >= nums.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = nums[i] + serve(nums, i+<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> n = serve(nums, i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> m > n ? m : n;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lucene总结</title>
      <link href="/2020/03/23/Lucene%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/23/Lucene%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>作用：站内全文检索。</p><p>如何使用：</p><p>创建索引库，创建查询</p><p>根据搜索关键字出现的频率进行排序 </p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lucene </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>876-链表的中间结点</title>
      <link href="/2020/03/23/876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/"/>
      <url>/2020/03/23/876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个带有头结点 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5]</span><br><span class="line">输出：此列表中的结点 3 (序列化形式：[3,4,5])</span><br><span class="line">返回的结点值为 3 。</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,5,6]</span><br><span class="line">输出：此列表中的结点 4 (序列化形式：[4,5,6])</span><br><span class="line">由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。</span><br></pre></td></tr></tbody></table></figure></div><blockquote><p><strong>提示：</strong></p><ul><li>给定链表的结点数介于 <code>1</code> 和 <code>100</code> 之间。</li></ul></blockquote><p>思路：这道题比较简单，我用的快慢指针，但是在边界处理的地方不够简洁。这道题有三种解法，发散下思路。</p><p>方法一：用数组。</p><p>链表的缺点在于不能通过下标访问对应的元素。因此我们可以考虑对链表进行遍历，同时将遍历到的元素依次放入数组 A 中。如果我们遍历到了 N 个元素，那么链表以及数组的长度也为 N，对应的中间节点即为 A[N/2]。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        ListNode[] A = <span class="keyword">new</span> ListNode[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) {</span><br><span class="line">            A[t++] = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> A[t / <span class="number">2</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>方法二：单指针法</p><p>我们可以对方法一进行空间优化，省去数组 A。</p><p>我们可以对链表进行两次遍历。第一次遍历时，我们统计链表中的元素个数 N；第二次遍历时，我们遍历到第 N/2 个元素（链表的首节点为第 0 个元素）时，将该元素返回即可。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) {</span><br><span class="line">            ++n;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (k < n / <span class="number">2</span>) {</span><br><span class="line">            ++k;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>方法三：快慢指针法</p><p>用两个指针 <code>slow</code> 与 <code>fast</code> 一起遍历链表。<code>slow</code> 一次走一步，<code>fast</code> 一次走两步。那么当 <code>fast</code> 到达链表的末尾时，<code>slow</code> 必然位于中间。</p><p>下面是我自己写的，处理的不好</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) { val = x; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        ListNode low = head;</span><br><span class="line">        ListNode high = head;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(head.next.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        <span class="keyword">while</span>(high != <span class="keyword">null</span>){</span><br><span class="line">            low = low.next;</span><br><span class="line">            high = high.next.next;</span><br><span class="line">            <span class="keyword">if</span>(high.next == <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">return</span> low;</span><br><span class="line">            }<span class="keyword">else</span> <span class="keyword">if</span>(high.next.next == <span class="keyword">null</span>){</span><br><span class="line">                <span class="keyword">return</span> low.next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>更简洁的做法是这样</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> && fast.next != <span class="keyword">null</span>) {</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>945-使数组唯一的最小增量</title>
      <link href="/2020/03/22/945-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F/"/>
      <url>/2020/03/22/945-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%94%AF%E4%B8%80%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A2%9E%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。</p><p>返回使 A 中的每个值都是唯一的最少操作次数。</p><p>示例 1:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：经过一次 move 操作，数组将变为 [1, 2, 3]。</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,2,1,2,1,7]</span><br><span class="line">输出：6</span><br><span class="line">解释：经过 6 次 move 操作，数组将变为 [3, 4, 1, 2, 5, 7]。</span><br><span class="line">可以看出 5 次或 5 次以下的 move 操作是不能让数组的每个值唯一的。提示：</span><br></pre></td></tr></tbody></table></figure></div><p>0 <= A.length <= 40000<br>0 <= A[i] < 40000</p><p>思路一：</p><p>由于 A[i] 的范围为 [0, 40000)，我们可以用数组统计出每个数出现的次数，然后对于每个重复出现的数，我们暴力地将它递增，直到它增加到一个没有重复出现的数为止。但这样的方法的时间复杂度较大，可以达到 O(N^2)，例如数组 A 中所有元素都是 1 的情况。</p><p>因此，我们不能对重复出现的数暴力的进行递增，而是用以下的做法：当我们找到一个没有出现过的数的时候，将之前某个重复出现的数增加成这个没有出现过的数。注意，这里 「之前某个重复出现的数」 是可以任意选择的，它并不会影响最终的答案，因为将 P 增加到 X 并且将 Q 增加到 Y，与将 P 增加到 Y 并且将 Q 增加到 X 都需要进行 (X + Y) - (P + Q) 次操作。</p><p>例如当数组 A 为 [1, 1, 1, 1, 3, 5] 时，我们发现有 3 个重复的 1，且没有出现过 2，4 和 6，因此一共需要进行 (2 + 4 + 6) - (1 + 1 + 1) = 9 次操作。</p><p>算法步骤：</p><p>首先统计出每个数出现的次数，然后从小到大遍历每个数 x：</p><p>如果 x 出现了两次以上，就将额外出现的数记录下来（例如保存到一个列表中）；</p><p>如果 x 没有出现过，那么在记录下来的数中选取一个 v，将它增加到 x，需要进行的操作次数为 x - v。</p><p>我们还可以对该算法进行优化，使得我们不需要将额外出现的数记录下来。<strong>还是以 [1, 1, 1, 1, 3, 5] 为例，当我们发现有 3 个重复的 1 时，我们先将操作次数减去 1 + 1 + 1。接下来，当我们发现 2，4 和 6 都没有出现过时，我们依次将操作次数增加 2，4 和 6。</strong></p><p>有一点可优化：<strong>初始化数组大小实际上 A.length() + max(A) 即可。</strong> </p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">      <span class="comment">//实际上大小为 A.length() + max(A) 即可</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80000</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : A) count[x]++;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//记录结果</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//记录重复的数字个数</span></span><br><span class="line">        <span class="keyword">int</span> rep = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">80000</span>; i++){</span><br><span class="line">          <span class="comment">//如果i是重复的</span></span><br><span class="line">            <span class="keyword">if</span>(count[i] >= <span class="number">2</span>){</span><br><span class="line">                rep += count[i] - <span class="number">1</span>;</span><br><span class="line">                ans -= i*(count[i] - <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">          <span class="comment">//如果i的位置为空，且前面有重复的未放置的数字</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rep > <span class="number">0</span> && count[i] == <span class="number">0</span>){</span><br><span class="line">                rep--;</span><br><span class="line">                ans += i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路二：</p><p>先排序。遍历的时候把后面的数变成比前一个数大1即可，在这个过程中记录增加的步数。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minIncrementForUnique</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < A.length; i++){</span><br><span class="line">        <span class="keyword">if</span>(A[i] <= A[i-<span class="number">1</span>]){</span><br><span class="line">        res += A[i-<span class="number">1</span>]-A[i]+<span class="number">1</span>;</span><br><span class="line">            A[i] = A[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速排序模板</title>
      <link href="/2020/03/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/"/>
      <url>/2020/03/20/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>基本思想：</p><ul><li><p>1．先从数列中取出一个数作为基准数。</p></li><li><p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p></li><li><p>3．再对左右区间重复第二步，直到各区间只有一个数。  </p></li></ul><p>虽然快速排序称为分治法，但分治法这三个字显然无法很好的概括快速排序的全部步骤。因此我的对快速排序作了进一步的说明：挖坑填数+分治法：</p><p>以一个数组作为示例，取区间第一个数为基准数。</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>72</td><td>6</td><td>57</td><td>88</td><td>60</td><td>42</td><td>83</td><td>73</td><td>48</td><td>85</td></tr></tbody></table><p>初始时，i = 0; j = 9;  X = a[i] = 72</p><p>由于已经将 a[0] 中的数保存到 X 中，<strong>可以理解成在数组 a[0] 上挖了个坑</strong>，可以将其它数据填充到这来。</p><p>从j开始向前找一个比X小或等于X的数。当j=8，符合条件，将a[8]挖出再填到上一个坑a[0]中。a[0]=a[8]; i++; 这样一个坑a[0]就被搞定了，但又形成了一个新坑a[8]，这怎么办了？简单，再找数字来填a[8]这个坑。这次从i开始向后找一个大于X的数，当i=3，符合条件，将a[3]挖出再填到上一个坑中a[8]=a[3]; j–;</p><p>数组变为：</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3 i</th><th>4</th><th>5</th><th>6</th><th>7 j</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>48</td><td>6</td><td>57</td><td>88</td><td>60</td><td>42</td><td>83</td><td>73</td><td>88</td><td>85</td></tr></tbody></table><p>i = 3;  j = 7;  X=72</p><p>再重复上面的步骤，先从后向前找，再从前向后找。</p><p>从j开始向前找，当j=5，符合条件，将a[5]挖出填到上一个坑中，a[3] = a[5]; i++;</p><p>从i开始向后找，当i=5时，由于i==j退出。</p><p>此时，i = j = 5，而a[5]刚好又是上次挖的坑，因此将X填入a[5]。</p><p>数组变为：</p><table><thead><tr><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5 i j</th><th>6</th><th>7</th><th>8</th><th>9</th></tr></thead><tbody><tr><td>48</td><td>6</td><td>57</td><td>42</td><td>60</td><td>72</td><td>83</td><td>73</td><td>88</td><td>85</td></tr></tbody></table><p>可以看出a[5]前面的数字都小于它，a[5]后面的数字都大于它。因此再对a[0…4]和a[6…9]这二个子区间重复上述步骤就可以了。 </p><p>对挖坑填数进行总结:</p><ol><li>i =L; j = R; 将基准数挖出形成第一个坑a[i]。</li><li>j–由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</li><li>i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</li><li>再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</li></ol><p>照着这个总结很容易实现挖坑填数的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">AdjustArray</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="comment">//返回调整后基准数的位置</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">    <span class="keyword">int</span> x = s[l]; <span class="comment">//s[l]即s[i]就是第一个坑</span></span><br><span class="line">    <span class="keyword">while</span> (i < j)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 从右向左找小于x的数来填s[i]</span></span><br><span class="line">        <span class="keyword">while</span>(i < j && s[j] >= x) </span><br><span class="line">            j--;  </span><br><span class="line">        <span class="keyword">if</span>(i < j) </span><br><span class="line">        {</span><br><span class="line">            s[i] = s[j]; <span class="comment">//将s[j]填到s[i]中，s[j]就形成了一个新的坑</span></span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 从左向右找大于或等于x的数来填s[j]</span></span><br><span class="line">        <span class="keyword">while</span>(i < j && s[i] < x)</span><br><span class="line">            i++;  </span><br><span class="line">        <span class="keyword">if</span>(i < j) </span><br><span class="line">        {</span><br><span class="line">            s[j] = s[i]; <span class="comment">//将s[i]填到s[j]中，s[i]就形成了一个新的坑</span></span><br><span class="line">            j--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//退出时，i等于j。将x填到这个坑中。</span></span><br><span class="line">    s[i] = x;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>再写分治的代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort1</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (l < r)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">int</span> i = AdjustArray(s, l, r);<span class="comment">//先成挖坑填数法调整s[]</span></span><br><span class="line">        quick_sort1(s, l, i - <span class="number">1</span>); <span class="comment">// 递归调用 </span></span><br><span class="line">        quick_sort1(s, i + <span class="number">1</span>, r);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>挖坑+分治组合整理下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> s[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (l < r)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1</span></span><br><span class="line">        <span class="keyword">int</span> i = l, j = r, x = s[l];</span><br><span class="line">        <span class="keyword">while</span> (i < j)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span>(i < j && s[j] >= x) <span class="comment">// 从右向左找第一个小于x的数</span></span><br><span class="line">                j--;  </span><br><span class="line">            <span class="keyword">if</span>(i < j) </span><br><span class="line">                s[i++] = s[j];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(i < j && s[i] < x) <span class="comment">// 从左向右找第一个大于等于x的数</span></span><br><span class="line">                i++;  </span><br><span class="line">            <span class="keyword">if</span>(i < j) </span><br><span class="line">                s[j--] = s[i];</span><br><span class="line">        }</span><br><span class="line">        s[i] = x;</span><br><span class="line">        quick_sort(s, l, i - <span class="number">1</span>); <span class="comment">// 递归调用 </span></span><br><span class="line">        quick_sort(s, i + <span class="number">1</span>, r);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>根据情况灵活选择分开写还是整合到一起。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>25-最小的K个数</title>
      <link href="/2020/03/20/25-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/"/>
      <url>/2020/03/20/25-%E6%9C%80%E5%B0%8F%E7%9A%84K%E4%B8%AA%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>输入整数数组 <code>arr</code> ，找出其中最小的 <code>k</code> 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。</p><p><strong>示例 1：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [3,2,1], k = 2</span><br><span class="line">输出：[1,2] 或者 [2,1]</span><br></pre></td></tr></tbody></table></figure></div><p><strong>示例 2：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [0,1,2,1], k = 1</span><br><span class="line">输出：[0]</span><br></pre></td></tr></tbody></table></figure></div><p>思路一：</p><p>直接排序，取前k个数。这道题用快速排序最高效，因为注意到找前K大/前K小问题不需要对整个数组进行O(NlogN)的排序！直接通过快排切分排好第K小的数（下标为K-1），那么它左边的数就是比它小的另外K-1个数。快排模版要记牢。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 最后一个参数表示我们要找的是下标为k-1的数</span></span><br><span class="line">        <span class="keyword">return</span> quickSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] quickSearch(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span></span><br><span class="line">        <span class="keyword">int</span> j = partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (j == k) {</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(nums, j + <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span></span><br><span class="line">        <span class="keyword">return</span> j > k? quickSearch(nums, lo, j - <span class="number">1</span>, k): quickSearch(nums, j + <span class="number">1</span>, hi, k);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> v = nums[lo];</span><br><span class="line">        <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i < j) {</span><br><span class="line">            <span class="keyword">while</span>(i < j && nums[j] >= v) </span><br><span class="line">                 j--;  </span><br><span class="line">        <span class="keyword">if</span>(i < j){</span><br><span class="line">                nums[i] = nums[j]; </span><br><span class="line">                i++;</span><br><span class="line">            } </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">while</span>(i < j && nums[i] <= v)</span><br><span class="line">            i++;  </span><br><span class="line">        <span class="keyword">if</span>(i < j) {</span><br><span class="line">            nums[j] = nums[i]; </span><br><span class="line">            j--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">        nums[i] = v;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路二：</p><p>用PriorityQueue实现大顶堆。保持堆的大小为K，然后遍历数组中的数字，遍历的时候做如下判断：</p><ol><li>若目前堆的大小小于K，将当前数字放入堆中。</li><li>否则判断当前数字与大根堆堆顶元素的大小关系，如果当前数字比大根堆堆顶还大，这个数就直接跳过；反之如果当前数字比大根堆堆顶小，先poll掉堆顶，再将该数字放入堆中。</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) {</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 默认是小根堆，实现大根堆需要重写一下比较器。</span></span><br><span class="line">        Queue<integer> pq = <span class="keyword">new</span> PriorityQueue<>((v1, v2) -> v2 - v1);</integer></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num: arr) {</span><br><span class="line">            <span class="keyword">if</span> (pq.size() < k) {</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (num < pq.peek()) {</span><br><span class="line">                pq.poll();</span><br><span class="line">                pq.offer(num);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回堆中的元素</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[pq.size()];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num: pq) {</span><br><span class="line">            res[idx++] = num;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识盲区</title>
      <link href="/2020/03/19/%E7%9F%A5%E8%AF%86%E7%9B%B2%E5%8C%BA/"/>
      <url>/2020/03/19/%E7%9F%A5%E8%AF%86%E7%9B%B2%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>峰哥项目一的知识盲区：</p><p>hibernate，ssh整合，Solr ，Memcached ，Lucene ，elasticseacrch ，Redis</p></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java面经总结</title>
      <link href="/2020/03/19/java%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/19/java%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h4><ul><li>重载发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序，返回值，修饰访问符不同</li><li>重写发正在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。</li></ul><h4 id="🌟String，StringBuffer，StringBuilder的区别？为什么String不可变？"><a href="#🌟String，StringBuffer，StringBuilder的区别？为什么String不可变？" class="headerlink" title="🌟String，StringBuffer，StringBuilder的区别？为什么String不可变？"></a>🌟String，StringBuffer，StringBuilder的区别？为什么String不可变？</h4><ul><li>String类使用final关键字字符数组保存字符串。可理解为常量，线程安全</li><li>StringBuffer<strong>是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类</strong>，对方法加了同步锁，线程安全。Stringbuilder非线程安全</li></ul><p>####自动装箱与自动拆箱</p><ul><li>基本类型与引用类型的转换</li></ul><h4 id="与equals的区别"><a href="#与equals的区别" class="headerlink" title="==与equals的区别"></a>==与equals的区别</h4><ul><li>== 基本数据类型直接比较值，引用类型比较对象的内存地址</li><li>equals默认等价于==。一般会重写比较规则来比较两个对象。String的equals是被重写过的，按值比较。</li></ul><h4 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h4><ul><li>用于变量（不可修改/不可指向其它对象）</li><li>用于方法（防止继承类修改）</li><li>用于类（不可继承）</li></ul><p>####Object类的常见方法总结（注意native和final）</p><ul><li>getclass 返回当前运行时的Class对象</li><li>hashcode 返回对象的哈希码。主要用在哈希表中</li><li>equals</li><li>clone 需要实现Cloneable接口，并重写clone方法才能用</li><li>toString 默认返回实例哈希码16进制字符串</li><li>notify 唤醒一个在此对象监视器上等待的线程。多个线程在等待只会任意唤醒一个</li><li>notifyAll 同上，但是唤醒所有线程</li><li>wait 暂停线程的执行。sleep方法没有释放锁，wait会释放锁</li><li>finalize 实例被垃圾回收器回收时触发的操作</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Listener总结</title>
      <link href="/2020/03/19/Listener%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/19/Listener%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>Listener 的作用是用于监听 web应用的创建和销毁，以及在其上attribute发生的变化。web应用即ServletContext对象。除了对web应用的监听外，还能监听session和request的生命周期，以及他们的attribute发生的变化。</p><h4 id="Listener-监听-Context"><a href="#Listener-监听-Context" class="headerlink" title="Listener 监听 Context"></a>Listener 监听 Context</h4><p>对Context的监听分<strong>生命周期的监听</strong>，和<strong>Context上Attribute变化的监听</strong>两种。</p><p>下面分别完成简单的示例</p><ul><li><p>编写 ContextListener：</p><p>实现接口ServletContextListener，这个接口有两个方法</p><p><code>public void contextDestroyed(ServletContextEvent arg0)</code> 对应当前web应用的销毁</p><p><code>public void contextInitialized(ServletContextEvent arg0)</code>对应当前web应用的初始化</p></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent arg0)</span> </span>{</span><br><span class="line">System.out.println(<span class="string">"web 应用销毁  "</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent arg0)</span> </span>{</span><br><span class="line">System.out.println(<span class="string">"web 应用初始化 "</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><ul><li><p>配置web.xml</p><p>配置监听器</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">listener</span>></span></span><br><span class="line"><span class="tag"><<span class="name">listener-class</span>></span>listener.ContextListener<span class="tag"><!--<span class="name"-->listener-class</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->listener</span>></span><br></pre></td></tr></tbody></table></figure></div></li></ul><ul><li><p>编写 ContextAttributeListener</p><p>实现接口ServletContextAttributeListener</p><p><code>public void attributeAdded(ServletContextAttributeEvent e)</code>监听属性的增加</p><p><code>public void attributeRemoved(ServletContextAttributeEvent e)</code>监听属性的移除</p><p><code>public void attributeReplaced(ServletContextAttributeEvent e)</code>监听属性的替换</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextAttributeEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextAttributeListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextAttributeListener</span> <span class="keyword">implements</span> <span class="title">ServletContextAttributeListener</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletContextAttributeEvent e)</span> </span>{</span><br><span class="line">System.out.println(<span class="string">"增加属性 "</span>);</span><br><span class="line">System.out.println(<span class="string">"属性是"</span> + e.getName());</span><br><span class="line">System.out.println(<span class="string">"值是"</span> + e.getValue());</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletContextAttributeEvent e)</span> </span>{</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"移除属性 "</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletContextAttributeEvent e)</span> </span>{</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"替换属性"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></li></ul><ul><li><p>配置web.xml</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">listener</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">listener-class</span>></span>listener.ContextAttributeListener<span class="tag"><!--<span class="name"-->listener-class</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->listener</span>></span><br></pre></td></tr></tbody></table></figure></div></li></ul><p>类似的Listener也可以监听Session和Request的生命周期与Attribute变化。</p><p>####Listener的应用</p><p>统计在线人数：</p><p>HTTP协议是短链接的，所以无法在服务端根据建立了多少连接来统计当前有多少人在线。 不过可以通过统计session有多少来估计在线人数。一旦一个用户访问服务器，就会创建一个session. 如果该用户持续访问，那么该session会持续有效。如果经历了30分钟，该用户也没有做任何操作，就表示该用户“下线” 了，其对应的session也会被销毁。所以可以通过统计有多少session被保留来估计当前在线人数。</p><ul><li><p>编写 OnlineNumberListener</p><p>OnlineNumberListener 实现接口HttpSessionListener</p><p>当创建一个session的时候，就把数字+1，并且放在application里。</p><p><code>ServletContext application = e.getSession().getServletContext();</code><br>这就是jsp里的application</p><p><strong>注:</strong> 第一次从application里取数据的时候，是空的，要设置为0。</p><p>当销毁一个session的时候，把这个数字-1</p></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSessionListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlineNumberListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent e)</span> </span>{</span><br><span class="line"></span><br><span class="line">ServletContext application = e.getSession().getServletContext();</span><br><span class="line"></span><br><span class="line">Integer online_number = (Integer) application.getAttribute(<span class="string">"online_number"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == online_number)</span><br><span class="line">online_number = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">online_number++;</span><br><span class="line">application.setAttribute(<span class="string">"online_number"</span>, online_number);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"新增一位在线用户"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent e)</span> </span>{</span><br><span class="line"></span><br><span class="line">ServletContext application = e.getSession().getServletContext();</span><br><span class="line"></span><br><span class="line">Integer online_number = (Integer) application.getAttribute(<span class="string">"online_number"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span>==online_number){</span><br><span class="line">online_number = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">online_number--;</span><br><span class="line">application.setAttribute(<span class="string">"online_number"</span>, online_number);</span><br><span class="line">System.out.println(<span class="string">"一位用户离线"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><ul><li><p>配置web.xml</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">listener</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">listener-class</span>></span>listener.OnlineNumberListener<span class="tag"><!--<span class="name"-->listener-class</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->listener</span>></span><br></pre></td></tr></tbody></table></figure></div></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Filter总结</title>
      <link href="/2020/03/19/Filter%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/19/Filter%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>Filter就像一个一个哨卡，用户的请求需要经过Filter，并且可以有多个过滤器。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200319091345587.png" data-fancybox="group" data-caption="image-20200319091345587" class="fancybox"><img alt="image-20200319091345587" title="image-20200319091345587" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200319091345587.png" class="lazyload"></a></p><p>一个简单的Filter，用来打印用户访问ip地址和访问的页面：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.Filter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//doFilter()方法中的req参数的类型是ServletRequest，需要转换为HttpServletRequest类型方便调用某些方法</span></span><br><span class="line">HttpServletRequest request = (HttpServletRequest) req;</span><br><span class="line">HttpServletResponse response = (HttpServletResponse) res;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取来路用户的ip地址</span></span><br><span class="line">String ip = request.getRemoteAddr();</span><br><span class="line">    <span class="comment">//获取用户访问的页面地址</span></span><br><span class="line">String url = request.getRequestURL().toString();</span><br><span class="line">    </span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">Date d = <span class="keyword">new</span> Date();</span><br><span class="line">String date = sdf.format(d);</span><br><span class="line"><span class="comment">//在控制台打印出来</span></span><br><span class="line">System.out.printf(<span class="string">"%s %s 访问了 %s%n"</span>, date, ip, url);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//过滤器放行，表示继续运行下一个过滤器，或者最终访问的某个servlet,jsp,html等等</span></span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException </span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>写完还需要在web.xml中进行filter的配置，和servlet的配置很类似.</p><p>其中<code><url-pattern>/*</url-pattern></code>表示所有的访问都会过滤</p><p>如果配置成<code><url-pattern>*.jsp</url-pattern></code>就表示只过滤jsp</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">filter</span>></span></span><br><span class="line"><span class="tag"><<span class="name">filter-name</span>></span>FirstFilter<span class="tag"><!--<span class="name"-->filter-name</span>></span><br><span class="line"><span class="tag"><<span class="name">filter-class</span>></span>filter.FirstFilter<span class="tag"><!--<span class="name"-->filter-class</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->filter</span>></span><br><span class="line"></span><br><span class="line"><span class="tag"><<span class="name">filter-mapping</span>></span></span><br><span class="line"><span class="tag"><<span class="name">filter-name</span>></span>FirstFilter<span class="tag"><!--<span class="name"-->filter-name</span>></span><br><span class="line"><span class="tag"><<span class="name">url-pattern</span>></span>/*<span class="tag"><!--<span class="name"-->url-pattern</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->filter-mapping</span>></span><br></pre></td></tr></tbody></table></figure></div><p>另外要注意：</p><ul><li>与Servlet需要配置自启动才会随着tomcat的启动而执行init()方法不一样，Filter<strong>一定</strong>会随着tomcat的启动自启动。</li><li>如果Filter启动失败，或者本身有编译错误，<strong>不仅这个Filter不能使用</strong>，<strong>整个web应用会启动失败</strong>，导致用户无法访问页面</li></ul><p>Filter的应用：</p><ul><li>中文处理</li><li>登陆验证</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ssm项目导入IDEA运行报错</title>
      <link href="/2020/03/18/ssm%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5IDEA%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99/"/>
      <url>/2020/03/18/ssm%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5IDEA%E8%BF%90%E8%A1%8C%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>解决bug的思路：</p><p>出现报错时，先找到日志查看报错信息。报错信息里面大部分都是没用的话，而且一般是一连串的错误。最关键的就是要找到报错的root reason根本原因，往往是有一个地方出错才导致后面的出错，解决了根本原因，其他的也都迎刃而解。root reason一般在报错信息的最上方或最下方。</p><p>之前导入ssm商城项目的时候，报错一直没有解决</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error creating bean with name 'sqlSession' defined in class path resource [applicationContext.xml]: Cannot resolve reference to bean 'dataSource' while setting bean property 'dataSource'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dataSource' defined in class path resource [applicationContext.xml]: Invocation of init method failed; nested exception is java.sql.SQLException: Unknown system variable 'tx_isolation'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'sqlSession' defined in class path resource [applicationContext.xml]: Cannot resolve reference to bean 'dataSource' while setting bean property 'dataSource'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dataSource' defined in class path resource [applicationContext.xml]: Invocation of init method failed; nested exception is java.sql.SQLException: Unknown system variable 'tx_isolation'</span><br></pre></td></tr></tbody></table></figure></div><p>今天终于解决了这个问题，大致原因是dataSource在配置里找不到。想起了昨天也是用cp30配置dataSource的时候报类似的错，然后换成下面的就可以了。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>></span> </span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span>></span> </span><br><span class="line">            <span class="tag"><<span class="name">value</span>></span>com.mysql.jdbc.Driver<span class="tag"><!--<span class="name"-->value</span>></span> <br><span class="line">        <span class="tag"><!--<span class="name"-->property</span>></span> <br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span>></span> </span><br><span class="line">            <span class="tag"><<span class="name">value</span>></span>jdbc:mysql://localhost:3306/xxx?characterEncoding=UTF-8<span class="tag"><!--<span class="name"-->value</span>></span> <br><span class="line">     </span><br><span class="line">        <span class="tag"><!--<span class="name"-->property</span>></span> <br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span>></span> </span><br><span class="line">            <span class="tag"><<span class="name">value</span>></span>root<span class="tag"><!--<span class="name"-->value</span>></span> <br><span class="line">        <span class="tag"><!--<span class="name"-->property</span>></span> <br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>></span> </span><br><span class="line">            <span class="tag"><<span class="name">value</span>></span>admin<span class="tag"><!--<span class="name"-->value</span>></span> <br><span class="line">        <span class="tag"><!--<span class="name"-->property</span>></span>  <br><span class="line">   <span class="tag"><!--<span class="name"-->bean</span>></span><br></pre></td></tr></tbody></table></figure></div><p>同样的方法试了一下，成功！</p><p>虽然还不理解具体的问题原因，但是至少迈出了一步。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git总结</title>
      <link href="/2020/03/18/git%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/18/git%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><ul><li><p>git commit。提交</p></li><li><p>git branch。创建分支</p></li><li><p>git checkout。切换当前分支，也可以用于分离HEAD</p></li><li><p>git merge。合并分支，把两个分支的修改合到一起，但是头结点的父亲结点会有两个。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200318105156046.png" data-fancybox="group" data-caption="image-20200318105156046" class="fancybox"><img alt="image-20200318105156046" title="image-20200318105156046" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200318105156046.png" class="lazyload"></a>     </p></li><li><p>git rebase。合并后的分支在一条线上。</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200318105419248.png" data-fancybox="group" data-caption="image-20200318105419248" class="fancybox"><img alt="image-20200318105419248" title="image-20200318105419248" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200318105419248.png" class="lazyload"></a></p></li><li><p>git reset HEAD^1。本地分支回退</p></li><li><p>git revert HEAD。用新的结点记录表示回退，便于远程分支的更新</p></li><li><p>git clone。克隆远程分支</p></li><li><p>git fetch。本地的o/master从远程分支拉取最新提交，</p></li><li><p>git pull。相当于fetch+merge，把从远程分支拉取的合并到本地分支</p></li><li><p>git push。把本地分支推送到远程分支，同时本地的o/master也会同步</p></li></ul><p>​    实际的团队工作中，分支看起来像这样：</p><p><a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200318110621410.png" data-fancybox="group" data-caption="image-20200318110621410" class="fancybox"><img alt="image-20200318110621410" title="image-20200318110621410" data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/image-20200318110621410.png" class="lazyload"></a></p><p>​    master分支应该是非常稳定的，仅用来发布新版本，平时不能在上面干活。干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本。团队中每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以。</p><p>​    还需要理解<strong>暂存区和工作区</strong>的概念。平时正在修改的文件处于工作区，git add命令实际上就是把要提交的所有修改从工作区放到暂存区，然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。</p><p>想学好git还是得多实践，可以在<a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">这里</a>多模拟练习，当然在GitHub中加入一个开源项目和别人协作，是最好的练习方式。</p></body></html>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>836-矩形重叠</title>
      <link href="/2020/03/18/836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/"/>
      <url>/2020/03/18/836-%E7%9F%A9%E5%BD%A2%E9%87%8D%E5%8F%A0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。</p><p>如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。</p><p>给出两个矩形，判断它们是否重叠并返回结果。</p><p>示例 1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rec1 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>], rec2 = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="keyword">true</span></span><br></pre></td></tr></tbody></table></figure></div><p>示例 2：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：rec1 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>], rec2 = [<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="keyword">false</span></span><br></pre></td></tr></tbody></table></figure></div><p>思路：这道题乍一看很简单，第一直觉是，判断矩形的四个顶点是否在另一个矩形内，但是后来发现，矩形重叠有好多种情况。比如下面这种：</p><p> <a href="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/IMG_0032.JPG" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="https://yylblog.oss-cn-beijing.aliyuncs.com/Blog/IMG_0032.JPG" class="lazyload"></a></p><p>顶点都不在矩形内，或者顶点在边上（1或2个顶点在边上都有可能重叠）。这样看来，重叠的情况就有点多了。考虑反向思维，不重叠的情况有哪些呢？哇，突然发现，不重叠的情况只有4种，上/下/左/右，这就很清晰了。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> !(rec1[<span class="number">2</span>] <= rec2[<span class="number">0</span>] ||   <span class="comment">// left</span></span><br><span class="line">                 rec1[<span class="number">3</span>] <= rec2[<span class="number">1</span>] ||   <span class="comment">// bottom</span></span><br><span class="line">                 rec1[<span class="number">0</span>] >= rec2[<span class="number">2</span>] ||   <span class="comment">// right</span></span><br><span class="line">                 rec1[<span class="number">1</span>] >= rec2[<span class="number">3</span>]);    <span class="comment">// top</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路二：</p><p>如果两个矩形重叠，那么它们重叠的区域一定也是一个矩形，那么这代表了两个矩形与 x轴平行的边（水平边）投影到 x 轴上时会有交集，与 y 轴平行的边（竖直边）投影到 y 轴上时也会有交集。因此，我们可以将问题看作一维线段是否有交集的问题。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleOverlap</span><span class="params">(<span class="keyword">int</span>[] rec1, <span class="keyword">int</span>[] rec2)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (Math.min(rec1[<span class="number">2</span>], rec2[<span class="number">2</span>]) > Math.max(rec1[<span class="number">0</span>], rec2[<span class="number">0</span>]) &&</span><br><span class="line">                Math.min(rec1[<span class="number">3</span>], rec2[<span class="number">3</span>]) > Math.max(rec1[<span class="number">1</span>], rec2[<span class="number">1</span>]));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>尤克里里</title>
      <link href="/2020/03/17/%E5%B0%A4%E5%85%8B%E9%87%8C%E9%87%8C/"/>
      <url>/2020/03/17/%E5%B0%A4%E5%85%8B%E9%87%8C%E9%87%8C/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="目标：熟练演奏白熊音乐-《离开地球表面》"><a href="#目标：熟练演奏白熊音乐-《离开地球表面》" class="headerlink" title="目标：熟练演奏白熊音乐 -《离开地球表面》"></a>目标：熟练演奏白熊音乐 -《离开地球表面》</h4><ul><li><p>已学会：</p><p>《情非得已》，《好像爱这个世界》，《你的答案》，《平凡之路》</p></li><li><p>需要加强的技巧：</p><p>轮扫，轮指，切音，滑音，爬格子，和弦转换，指弹</p></li><li><p>待学：</p><p>看复杂谱，乐理</p></li></ul><h4 id="学习方法："><a href="#学习方法：" class="headerlink" title="学习方法："></a>学习方法：</h4><ul><li>爬格子</li><li>目标导向，练歌</li><li>每周都要练，一定不能停下来</li></ul><p>一年之后，我能把那首歌弹下来吗？坚持！我可以做到！</p></body></html>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ssm整合简单示例</title>
      <link href="/2020/03/17/ssm%E6%95%B4%E5%90%88%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/"/>
      <url>/2020/03/17/ssm%E6%95%B4%E5%90%88%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="整体步骤如下："><a href="#整体步骤如下：" class="headerlink" title="整体步骤如下："></a>整体步骤如下：</h4><ol><li>创建Maven项目</li><li>pom.xml添加依赖</li><li>配置tomcat服务器</li><li>搭建和测试Spring。<ul><li>applicationContext.xml中配置扫描器，spring管理的是service和dao层的注解，controller注解交给springmvc管理。</li><li>给service层对象添加@Service(“xxx”)注解，用扫描注解的方式得到对象，调用测试方法</li></ul></li><li>搭建和测试SpringMVC。<ul><li>配置过滤器，解决中文乱码问题</li><li>配置DispatcherServlet前端控制器</li><li>springmvc.xml中配置注解扫描器，只扫描 controller</li><li>springmvc.xml中配置视图解析器，控制 controller 跳转到 “/WEB-INF/pages/” 目录下，以 “xxx.jsp” 结尾的文件</li><li>开启对 springMVC 注解的支持</li><li>给控制器添加@Controller和@RequestMapping(“/xxx”)</li></ul></li><li>Spring整合SpringMVC<ul><li><strong>目的是在 controller 中能成功调用 service 对象中的方法</strong></li><li>修改web.xml。配置 ContextLoaderListener 监听器，使项目在启动时就去加载applicationContext.xml的配置文件。需要注意web.xml 中的文件配置有先后顺序</li><li>在controller中用@Autowired注入service层对象，并调用测试方法</li></ul></li><li>搭建和测试Mybatis<ul><li>SqlMapConfig.xml中添加数据源配置信息和引入映射文件</li><li>给DAO层的对象添加@Select(“select * from user”)和 @Insert(‘’xxx”)等注解</li><li>在测试类中，加载配置文件，创建工厂，创建 sqlSession 对象，获取代理对象，然后调用dao的方法。<font color="red"><strong>这一步不太理解</strong></font></li></ul></li><li>Spring整合Mybatis<ul><li><strong>目的是把 MyBatis 的数据源，SqlSession 和 dao 都交给 spring 管理</strong></li><li>把 SqlMapConfig.xml 配置文件中的内容配置到 applicationContext.xml 中</li><li>删除 SqlMapConfig.xml</li><li>给DAO对象添加 @Repository 注解</li><li>在service层中用@Autowired注入dao对象</li></ul></li></ol><p>至此，Spring，SpringMVC，Mybatis已整合完成。</p><p>详细步骤：</p><p><a href="https://blog.csdn.net/liyuanyue2017/article/details/96507642" target="_blank" rel="noopener">https://blog.csdn.net/liyuanyue2017/article/details/96507642</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1160-拼写单词</title>
      <link href="/2020/03/17/1160-%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/"/>
      <url>/2020/03/17/1160-%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</p><p>假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p><p>注意：每次拼写时，chars 中的每个字母都只能用一次。</p><p>返回词汇表 words 中你掌握的所有单词的 长度之和。</p><p>示例 1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [<span class="string">"cat"</span>,<span class="string">"bt"</span>,<span class="string">"hat"</span>,<span class="string">"tree"</span>], chars = <span class="string">"atach"</span></span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释： </span><br><span class="line">可以形成字符串 <span class="string">"cat"</span> 和 <span class="string">"hat"</span>，所以答案是 <span class="number">3</span> + <span class="number">3</span> = <span class="number">6</span>。</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [<span class="string">"hello"</span>,<span class="string">"world"</span>,<span class="string">"leetcode"</span>], chars = <span class="string">"welldonehoneyr"</span></span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：</span><br><span class="line">可以形成字符串 <span class="string">"hello"</span> 和 <span class="string">"world"</span>，所以答案是 <span class="number">5</span> + <span class="number">5</span> = <span class="number">10</span>。</span><br></pre></td></tr></tbody></table></figure></div><p>思路：建立字母表的哈希表，再建立每个单词的哈希表，记录次数进行比较。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(String[] words, String chars)</span> </span>{</span><br><span class="line">        HashMap<character, integer> map = <span class="keyword">new</span> HashMap<>();</character,></span><br><span class="line">        <span class="comment">//字母表建立哈希表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < chars.length(); i++){</span><br><span class="line">            <span class="keyword">char</span> c = chars.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(map.get(c) != <span class="keyword">null</span>)</span><br><span class="line">                map.put(c, map.get(c) + <span class="number">1</span>);           </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map.put(c, <span class="number">1</span>); </span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//记录符合条件的单词位置</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[words.length];</span><br><span class="line">        <span class="comment">//遍历每个单词</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j < words.length; j++){</span><br><span class="line">            HashMap<character, integer> word_map = <span class="keyword">new</span> HashMap<>();</character,></span><br><span class="line">            <span class="comment">//每个单词建立哈希表。flag标记是否满足条件</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k < words[j].length(); k++){</span><br><span class="line">                <span class="keyword">char</span> w = words[j].charAt(k);</span><br><span class="line">                <span class="keyword">if</span>(word_map.get(w) != <span class="keyword">null</span>)</span><br><span class="line">                    word_map.put(w, word_map.get(w) + <span class="number">1</span>);           </span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    word_map.put(w, <span class="number">1</span>); </span><br><span class="line">              <span class="comment">//判断是否不满足条件（没有这个字母或者超出数量）</span></span><br><span class="line">                <span class="keyword">if</span>(map.get(w) == <span class="keyword">null</span> || map.get(w) < word_map.get(w)){</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">          <span class="comment">//如果这个单词满足条件，置1</span></span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">                res[j] = <span class="number">1</span>;    </span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//计算符合条件单词的长度之和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">0</span>; m < res.length; m++)</span><br><span class="line">            <span class="keyword">if</span>(res[m] == <span class="number">1</span>)</span><br><span class="line">                sum += words[m].length();</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>还有一种用int[26]模拟哈希的方法。遇到有提示字符串仅包含小写（或者大写）英文字母的题，都可以试着考虑能不能构造长度为26的每个元素分别代表一个字母的数组，来简化计算。对于这道题，用数组c来保存字母表里每个字母出现的次数，如法炮制，再对词汇表中的每个词汇都做一数组w，比较数组w与数组c的对应位置。如果w中的都不大于c，就说明该词可以被拼写出，长度计入结果。如果w其中有一个超过了c，则说明不可以被拼写，直接跳至下一个（这里用到了<strong>带label的continue</strong>语法）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(String[] words, String chars)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">      <span class="comment">//字母表的“哈希”</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> cc : chars.toCharArray()) {</span><br><span class="line">            c[(<span class="keyword">int</span>)(cc - <span class="string">'a'</span>)] += <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        a: <span class="keyword">for</span>(String word : words) {</span><br><span class="line">            <span class="keyword">int</span>[] w = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="comment">//每个单词的“哈希”</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> ww : word.toCharArray()) {</span><br><span class="line">                w[(<span class="keyword">int</span>)(ww - <span class="string">'a'</span>)] += <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//检查每个单词</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i<<span class="number">26</span>; i++) {</span><br><span class="line">                <span class="keyword">if</span>(w[i] > c[i]) {</span><br><span class="line">                    <span class="keyword">continue</span> a;<span class="comment">//这里会跳到a处直接进行下一次循环</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            res += word.length();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>面试题-字符串压缩</title>
      <link href="/2020/03/16/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/"/>
      <url>/2020/03/16/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。</p><p>示例1:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="string">"aabcccccaaa"</span></span><br><span class="line">输出：<span class="string">"a2b1c5a3"</span></span><br></pre></td></tr></tbody></table></figure></div><p>示例2:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="string">"abbccd"</span></span><br><span class="line">输出：<span class="string">"abbccd"</span></span><br><span class="line">解释：<span class="string">"abbccd"</span>压缩后为<span class="string">"a1b2c2d1"</span>，比原字符串长度更长。</span><br></pre></td></tr></tbody></table></figure></div><p>思路：按照要求直接写，注意细节。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(S.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> S;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(S.charAt(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">      <span class="comment">//遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < S.length(); i++){</span><br><span class="line">          <span class="comment">//如果和上个字符相同，计数加一</span></span><br><span class="line">            <span class="keyword">if</span>(S.charAt(i) == sb.charAt(sb.length() - <span class="number">1</span>)){</span><br><span class="line">                count++;         </span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//如果和上个字符不相同</span></span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                <span class="comment">//上个字符的数量</span></span><br><span class="line">                sb.append(count);</span><br><span class="line">              <span class="comment">//当前字符</span></span><br><span class="line">                sb.append(S.charAt(i));</span><br><span class="line">              <span class="comment">//计数重置</span></span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">      <span class="comment">//最后一个字符记得也把计数加上</span></span><br><span class="line">      sb.append(count);</span><br><span class="line">        <span class="keyword">return</span> sb.length() >= S.length() ? S : sb.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>双指针解法：</p><p>使用一前一后两个指针，统计相同字符连续出现的个数，构建新字符串返回</p><p>具体来说，两指针在0位初始，后指针b每次一直移动到所指字符与前指针a所指字符不同的地方，<br>则a所指的字符出现次数为b-a，将字符及其次数插入新字符串中，<br>最后a跳转到b的位置，进入下一个循环</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>{</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a < S.length()) {</span><br><span class="line">            <span class="keyword">while</span>(b < S.length() && S.charAt(a) == S.charAt(b)) {</span><br><span class="line">                b++;</span><br><span class="line">            }</span><br><span class="line">            sb.append(S.charAt(a)).append(String.valueOf(b - a));</span><br><span class="line">            a = b;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sb.length() >= S.length() ? S : sb.toString();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>695-岛屿的最大面积</title>
      <link href="/2020/03/15/695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/"/>
      <url>/2020/03/15/695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)</p><p>示例 1:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line"> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br></pre></td></tr></tbody></table></figure></div><p>类似围棋。</p><p>思路：遍历二维数组，如果遇到1，就在此进行广度优先遍历，访问过的直接置0(沉岛思想)，这样这个岛屿访问完就全为0了，下次不用再进行dfs。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < row; i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j < col; j++){</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>){</span><br><span class="line">                  <span class="comment">//更新岛屿面积最大值</span></span><br><span class="line">                    res = Math.max(res, dfs(i, j, grid));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] grid)</span></span>{</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果不在矩阵内，或者为0，就返回0</span></span><br><span class="line">        <span class="keyword">if</span>(i >= row || j >= col || i < <span class="number">0</span> || j < <span class="number">0</span> || grid[i][j] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//因为当前坐标下是1，代表一个面积，别忘了</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//标记已访问</span></span><br><span class="line">        grid[i][j] = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//上下左右哪个在矩阵内且值为1，就继续dfs</span></span><br><span class="line">        <span class="keyword">if</span>(i - <span class="number">1</span> < row || j < col || i - <span class="number">1</span> >= <span class="number">0</span> || j >= <span class="number">0</span> || grid[i][j] == <span class="number">1</span>)</span><br><span class="line">            res += dfs(i - <span class="number">1</span>, j, grid);</span><br><span class="line">        <span class="keyword">if</span>(i + <span class="number">1</span> < row || j < col || i + <span class="number">1</span> >= <span class="number">0</span> || j >= <span class="number">0</span> || grid[i][j] == <span class="number">1</span>)</span><br><span class="line">            res += dfs(i + <span class="number">1</span>, j, grid);</span><br><span class="line">        <span class="keyword">if</span>(i < row || j - <span class="number">1</span> < col || i >= <span class="number">0</span> || j - <span class="number">1</span> >= <span class="number">0</span> || grid[i][j] == <span class="number">1</span>)</span><br><span class="line">            res += dfs(i, j - <span class="number">1</span>, grid);</span><br><span class="line">        <span class="keyword">if</span>(i < row || j + <span class="number">1</span> < col || i >= <span class="number">0</span> || j + <span class="number">1</span> >= <span class="number">0</span> || grid[i][j] == <span class="number">1</span>)</span><br><span class="line">            res += dfs(i, j + <span class="number">1</span>, grid);</span><br><span class="line">        <span class="keyword">return</span> res;   </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>300-最长上升子序列</title>
      <link href="/2020/03/14/300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2020/03/14/300-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">10</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">101</span>,<span class="number">18</span>]</span><br><span class="line">输出: <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure></div><p>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。<br>说明:</p><p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。<br>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><p>思路一：</p><p>动态规划。</p><p>使用<strong>数组dp</strong>保存每步子问题的最优解。<br>dp[i] 代表以第 i 个元素结尾的最长上升子序列的长度。<br>求解 dp[i] 时，向前遍历找出比 i 元素小的元素 j，令 dp[i] 为 max（dp[i],dp[j]+1)。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i < nums.length; i++){</span><br><span class="line">          <span class="comment">//记录i之前的，且nums[j]<nums[i]的，最大的dp[j]。< span></nums[i]的，最大的dp[j]。<></span><br><span class="line">            <span class="keyword">int</span> maxval = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j < i; j++){</span><br><span class="line">                <span class="keyword">if</span>(nums[j] < nums[i]){</span><br><span class="line">                    maxval = Math.max(dp[j], maxval);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">          <span class="comment">//如果没有符合条件的j，dp[i]应该为1</span></span><br><span class="line">            dp[i] = maxval + <span class="number">1</span>;</span><br><span class="line">            max = Math.max(dp[i], max);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    }</span><br><span class="line">}</span><br></span></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//这种写法更清晰</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < nums.length; i++) {</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j < i; j++) {</span><br><span class="line">                <span class="keyword">if</span>(nums[j] < nums[i]) dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路二：（太巧妙了，至今还不是完全理解）</p><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/</a></p><p>贪心+二分查找。新建一个数组，第一个数先放进去，然后第二个数和第一个数比较，如果说大于第一个数，那么就接在他后面，如果小于第一个数，那么就替换，一般的，如果有i个数，那么每进来一个新的数，都要用二分查找法来得知要替换在哪个位置的数。因为有个for循环，所以是O(N),在加上循环里有个二分查找，所以最后是O(NlogN)的时间复杂度。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span>[] tails = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) {</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>, j = res;</span><br><span class="line">            <span class="keyword">while</span>(i < j) {</span><br><span class="line">                <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(tails[m] < num) i = m + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> j = m;</span><br><span class="line">            }</span><br><span class="line">            tails[i] = num;</span><br><span class="line">            <span class="keyword">if</span>(res == j) res++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>169-多数元素</title>
      <link href="/2020/03/13/169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
      <url>/2020/03/13/169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p>思路一：</p><p>遍历数组，用哈希表记录每个数字出现的次数，遇到超过n/2的就返回</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">1</span>){</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        }</span><br><span class="line">        Map<integer, integer> map = <span class="keyword">new</span> HashMap<>();</integer,></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums){</span><br><span class="line">        <span class="keyword">if</span>(map.get(num) != <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">int</span> tmp = map.get(num) + <span class="number">1</span>;</span><br><span class="line">            map.put(num, tmp);</span><br><span class="line">            <span class="keyword">if</span>(tmp > nums.length/<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">        }  </span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            map.put(num, <span class="number">1</span>);</span><br><span class="line">        }      </span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路二：</p><p>先排序，然后找处于n/2位置的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length >> <span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>思路三：</p><p>摩尔投票法思路<br>候选人(cand_num)初始化为nums[0]，票数count初始化为1。<br>当遇到与cand_num相同的数，则票数count = count + 1，否则票数count = count - 1。<br>当票数count为0时，更换候选人，并将票数count重置为1。<br>遍历完数组后，cand_num即为最终答案。</p><p>为何这行得通呢？<br>投票法是遇到相同的则票数 + 1，遇到不同的则票数 - 1。<br>且“多数元素”的个数> ⌊ n/2 ⌋，其余元素的个数总和<= ⌊ n/2 ⌋。<br>因此“多数元素”的个数 - 其余元素的个数总和 的结果 肯定 >= 1。<br>这就相当于每个“多数元素”和其他元素 两两相互抵消，抵消到最后肯定还剩余至少1个“多数元素”。</p><p>无论数组是1 2 1 2 1，亦或是1 2 2 1 1，总能得到正确的候选人。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> cand_num = nums[<span class="number">0</span>], count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < nums.length; ++i) {</span><br><span class="line">            <span class="keyword">if</span> (cand_num == nums[i])</span><br><span class="line">                ++count;</span><br><span class="line">            <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">if</span> (--count == <span class="number">0</span>) {</span><br><span class="line">                    cand_num = nums[i];</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cand_num;</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1071-字符串的最大公因子</title>
      <link href="/2020/03/12/1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/"/>
      <url>/2020/03/12/1071-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>对于字符串 S 和 T，只有在 S = T + … + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。</p><p>返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。</p><p> 示例 1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：str1 = <span class="string">"ABCABC"</span>, str2 = <span class="string">"ABC"</span></span><br><span class="line">输出：<span class="string">"ABC"</span></span><br></pre></td></tr></tbody></table></figure></div><p>示例 2：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：str1 = <span class="string">"ABABAB"</span>, str2 = <span class="string">"ABAB"</span></span><br><span class="line">输出：<span class="string">"AB"</span></span><br></pre></td></tr></tbody></table></figure></div><p>示例 3：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：str1 = <span class="string">"LEET"</span>, str2 = <span class="string">"CODE"</span></span><br><span class="line">输出：<span class="string">""</span></span><br></pre></td></tr></tbody></table></figure></div><p>思路：</p><p>如果它们有公因子 abc，那么 str1 就是 m 个 abc 的重复，str2 是 n 个 abc 的重复，连起来就是 m+n 个 abc，好像 m+n 个 abc 跟 n+m 个 abc 是一样的。</p><p>所以如果 str1 + str2 === str2 + str1 就意味着有解。</p><p>我们也很容易想到<strong>（其实需要严格的数学证明）</strong> str1 + str2 !== str2 + str1 也是无解的充要条件。</p><p>当确定有解的情况下，最优解是长度为 gcd(str1.length, str2.length) 的字符串。</p><p><strong>因为如果能循环以它的约数为长度的字符串，自然也能够循环以它为长度的字符串，所以这个理论长度就是我们要找的最优解。</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>{</span><br><span class="line">     <span class="keyword">if</span>(!(str1 + str2).equals(str2 + str1))</span><br><span class="line">       <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">     <span class="keyword">return</span> str1.substring(<span class="number">0</span>, gcd(str1.length(), str2.length()));</span><br><span class="line">  }</span><br><span class="line"><span class="comment">//辗转相除法求最大公因数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>{</span><br><span class="line">     <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a%b);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串比较</title>
      <link href="/2020/03/12/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/"/>
      <url>/2020/03/12/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="equals-与"><a href="#equals-与" class="headerlink" title="equals() 与 =="></a>equals() 与 ==</h4><p>关于字符串比较用equals还是用==,总结一下</p><p>字符串为对象:</p><p><strong>1.”==”</strong></p><p>所有”对象变量”用==作比较时比的是两个对象在堆中的引用.</p><p><strong>2.”equals()”</strong></p><p>所有对象的equals方法继承自Object类的方法,而String重写了equals方法的比较算法,它比较的是字符串的内容,即在堆中的了符序列</p><p><strong>3.特点</strong></p><p>字符串是一种比较特殊的对象,这里的特殊指的是在运行期间,它的赋值直接改变引用(当然,任何对象的赋值都是直接改变的引用,只不过字符串这种东西往往让人容易理解为它是在原来的基础上操作的,尤其是+=这类操作),而不是在原来所引用的内存块中做修改.(因此有了StringBuffer类的出现)</p><p><strong>结论:</strong></p><p>1.</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">String s2 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);    <span class="comment">//true</span></span><br></pre></td></tr></tbody></table></figure></div><p>按照上面的说法,第一个true不难理解.</p><p>而第2个之所以也为true是因为,java编译器用的类似于C语言中的”文字池机制”,即在源代码中所有的字符串常量声明全部放在一块内存区域,因此当一个字符串声明时赋值的是一个字符串常量,那么如果”文字池”中有这个字符串常量,编译器将直接把它的引用赋值给这个变量.</p><p>因此在用==来比较s1和s2时,将会得到true.</p><p>2.</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">String s2 = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">s1 = s1 + <span class="string">"a"</span>;</span><br><span class="line"></span><br><span class="line">s2 = s2 + <span class="string">"a"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s1.equals(s2)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);    <span class="comment">//false</span></span><br></pre></td></tr></tbody></table></figure></div><p>第3,4行的赋值操作在运行期间执行,根据上面的知识点3:两个变量的引用将会发生改变.因此这时用==相比时将会得到false;</p><p>(在运行期间所得到的字符串内容,将不会放到所谓的”文字池”之中,然后如果有相同内容的变量引用相同内容,这样作的话需要每次字符串改变时需要检查它的内容,并再在文字池中查找看是否有相同内容的常量,太过浪费效率.)</p><p>(“文字池机制”也许也是为什么字符串对象在作更改时,直接改变引用的一个原因,因为如果直接对引用的内存块作操作的话,另一个指向相同引用的字符串变量将也会发什么改变,发生逻辑混淆)</p><p>3.</p><p>代码略.</p><p>当字符串对象从不同地方(字符串常量;本地资源文件读取;网络传输:如表单提交;等等)获得时:除了是编译期间用相同常量赋值的字符串变量的引用相同外,其它的全部是新的引用.因此,与这种变量直接用==相比时将得到false,即使内容相同</p><p><strong>应用结论:</strong></p><p>1.如果是单纯的比较字符串内容的话:用equals()</p><p>2.如果确实是要比较两个变量的引用的话:用==</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Servlet总结</title>
      <link href="/2020/03/11/Servlet%E6%80%BB%E7%BB%93/"/>
      <url>/2020/03/11/Servlet%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>写Servlet可以实现Servlet接口，但是需要重写5个方法。继承HttpServlet会更方便。</p><h4 id="Servlet生命周期可分为5个步骤"><a href="#Servlet生命周期可分为5个步骤" class="headerlink" title="Servlet生命周期可分为5个步骤"></a>Servlet生命周期可分为5个步骤</h4><ol><li><strong>加载Servlet</strong>。当Tomcat第一次访问Servlet的时候，<strong>Tomcat会负责创建Servlet的实例</strong></li><li><strong>初始化</strong>。当Servlet被实例化后，Tomcat会<strong>调用init()方法初始化这个对象</strong></li><li><strong>处理服务</strong>。当浏览器<strong>访问Servlet</strong>的时候，Servlet <strong>会调用service()方法处理请求</strong></li><li><strong>销毁</strong>。当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，<strong>让该实例释放掉所占的资源</strong>。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁</li><li><strong>卸载</strong>。当Servlet调用完destroy()方法后，等待垃圾回收。如果<strong>有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作</strong>。</li></ol><ul><li><p>简单总结：<strong>只要访问Servlet，service()就会被调用。init()只有第一次访问Servlet的时候才会被调用。</strong></p><p>destroy()只有在Tomcat关闭的时候才会被调用。</p></li></ul><h4 id="Servlet的细节"><a href="#Servlet的细节" class="headerlink" title="Servlet的细节"></a>Servlet的细节</h4><ol><li>一个已经被注册的servlet可以被映射多次</li><li>映射的URL可以使用通配符</li></ol><h4 id="Servlet是单例的"><a href="#Servlet是单例的" class="headerlink" title="Servlet是单例的"></a>Servlet是单例的</h4><ul><li>为什么是单例的？<strong>浏览器多次对Servlet的请求</strong>，一般情况下，<strong>服务器只创建一个Servlet对象</strong>，也就是说，Servlet对象<strong>一旦创建了</strong>，就会<strong>驻留在内存中，为后续的请求做服务，直到服务器关闭</strong>。</li><li>每次访问请求对象和响应对象都是新的。对于<strong>每次访问请求</strong>，Servlet引擎都会<strong>创建一个新的HttpServletRequest请求对象和一个新的HttpServletResponse响应对象</strong>，然后将这两<strong>个对象作为参数传递给它调用的Servlet的service()方法</strong>，<strong>service方法再根据请求方式分别调用doXXX方法</strong>。</li></ul><h4 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h4><p>当多个用户访问Servlet的时候，<strong>服务器会为每个用户创建一个线程</strong>。<strong>当多个用户并发访问Servlet共享资源的时候就会出现线程安全问题</strong>。</p><p>原则：</p><ol><li>如果一个<strong>变量需要多个用户共享</strong>，则应当在访问该变量的时候，<strong>加同步机制synchronized (对象){}</strong></li><li>如果一个变量<strong>不需要共享</strong>，则<strong>直接在 doGet() 或者 doPost()定义</strong>.这样不会存在线程安全问题</li></ol><h4 id="load-on-startup"><a href="#load-on-startup" class="headerlink" title="load-on-startup"></a>load-on-startup</h4><p>如果在<servlet>元素中配置了一个<load-on-startup>元素，那么<strong>WEB应用程序在启动时</strong>，就会<strong>装载并创建Servlet的实例对象</strong>、以及<strong>调用Servlet实例对象的init()方法</strong>。</load-on-startup></servlet></p><p>作用：</p><ol><li>为web应用写一个InitServlet，这个<strong>servlet配置为启动时装载</strong>，为整个web应用<strong>创建必要的数据库表和数据</strong></li><li>完成一些定时的任务【定时写日志，定时备份数据】</li></ol><h4 id="ServletConfig对象有什么用？"><a href="#ServletConfig对象有什么用？" class="headerlink" title="ServletConfig对象有什么用？"></a>ServletConfig对象有什么用？</h4><blockquote><p>通过此对象可以读取web.xml中配置的初始化参数。</p></blockquote><p>现在问题来了，<strong>为什么我们要把参数信息放到web.xml文件中呢</strong>？我们可以直接在程序中都可以定义参数信息，<strong>搞到web.xml文件中又有什么好处呢</strong>？</p><p>好处就是：<strong>能够让你的程序更加灵活</strong>【更换需求，更改配置文件web.xml即可，程序代码不用改】</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1013-将数组分成和相等的三个部分</title>
      <link href="/2020/03/11/1013-%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86/"/>
      <url>/2020/03/11/1013-%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给你一个整数数组 <code>A</code>，只有可以将其划分为三个和相等的非空部分时才返回 <code>true</code>，否则返回 <code>false</code>。</p><p>示例 1：</p><p>输出：[0,2,1,-6,6,-7,9,1,2,0,1]<br>输出：true<br>解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1</p><p>示例 2：</p><p>输入：[0,2,1,-6,6,7,9,-1,2,0,1]<br>输出：false</p><p>示例 3：</p><p>输入：[3,3,6,5,-2,2,5,1,-9,4]<br>输出：true<br>解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4</p><p>思路：一开始准备直接找，现求和，然后求三等分的值，但是发现有很多特殊情况忘记考虑了，比如和可能为0，前面已经加和到三等分值的时候，是否要从这里分，越想越乱越复杂，其实实际上，直接找的话，依次遍历，加和到三等分就记录一次，正常会记录到3次，有种特殊情况[1,-1,1,-1,1,-1,1,-1]是4次，但小于2次的肯定不满足。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">        <span class="comment">//求和，求三等分</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < A.length; i++)</span><br><span class="line">            sum += A[i]; </span><br><span class="line">      <span class="comment">//如果不是3的倍数</span></span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">3</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//依次遍历</span></span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j < A.length; j++){</span><br><span class="line">            tmp += A[j]; </span><br><span class="line">            <span class="keyword">if</span>(tmp == sum/<span class="number">3</span>){</span><br><span class="line">                tmp = <span class="number">0</span>;</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> count >= <span class="number">3</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>双指针解法：</p><p>前后两个指针left，right同时向中间靠，如果left左边和为sum/3，并且right右边和也为sum/3了，说明符合条件。如果left与right相遇，说明不符合条件。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>{</span><br><span class="line">        <span class="comment">//求和，求三等分</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < A.length; i++)</span><br><span class="line">            sum += A[i]; </span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">3</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftSum = A[left];</span><br><span class="line">        <span class="keyword">int</span> right = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> rightSum = A[right];</span><br><span class="line">      <span class="comment">//如果左右指针还没有相遇</span></span><br><span class="line">        <span class="keyword">while</span>(right - left > <span class="number">1</span>){</span><br><span class="line">            <span class="comment">//如果找到了</span></span><br><span class="line">            <span class="keyword">if</span>(leftSum == sum/<span class="number">3</span> && rightSum == sum/<span class="number">3</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//向中间靠</span></span><br><span class="line">            <span class="keyword">if</span>(leftSum != sum/<span class="number">3</span>){</span><br><span class="line">                left++;</span><br><span class="line">                leftSum += A[left]; </span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(rightSum != sum/<span class="number">3</span>){</span><br><span class="line">                right--;</span><br><span class="line">                rightSum += A[right]; </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">      <span class="comment">//指针相遇还未找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>眼疲劳的解决方法</title>
      <link href="/2020/03/11/%E7%9C%BC%E7%96%B2%E5%8A%B3%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2020/03/11/%E7%9C%BC%E7%96%B2%E5%8A%B3%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>长期习惯：</p><p>一，减少使用手机的时间。早上起来的第一个小时不碰手机，睡前1小时不碰手机，不在黑暗的环境下看手机。</p><p>二，提高眨眼频率。</p><p>三，每看屏幕二十分钟，挺胸抬头转转脖子，闭目或者远眺20秒。</p><p>短期缓解：</p><p>热毛巾敷眼10分钟。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 健康 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>543-二叉树的直径</title>
      <link href="/2020/03/10/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
      <url>/2020/03/10/543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p><p>示例 :<br>给定二叉树</p><pre><code>    1   / \  2   3 / \     4   5    </code></pre><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p><p>思路：这题比较容易出错的地方是，误以为必须要经过根结点。</p><p>深度优先遍历计算深度，然后在遍历的过程中，计算以每一个为“根结点”的最长路径，更新最大值。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) { val = x; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//深度优先遍历，过程中更新“二叉树的直径”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = dfs(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = dfs(root.right);</span><br><span class="line">        res = Math.max(res, left + right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程</title>
      <link href="/2020/03/09/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/03/09/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><h4 id="创建多线程有3种方式"><a href="#创建多线程有3种方式" class="headerlink" title="创建多线程有3种方式"></a>创建多线程有3种方式</h4><ol><li>继承线程类Thread</li><li>实现Runnable接口</li><li>匿名类</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread t1= <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">                             </span><br><span class="line">            }</span><br><span class="line">        };</span><br></pre></td></tr></tbody></table></figure></div><p>注意：启动线程是start()方法，run()并不能启动一个新的线程</p><h4 id="常见线程方法"><a href="#常见线程方法" class="headerlink" title="常见线程方法"></a>常见线程方法</h4><ol><li>sleep 当前线程暂停</li><li>join 加入到当前线程。主线程会等待该线程结束完毕， 才会往下运行。</li><li>setPriority 设置优先级。优先级高的线程会有更大的几率获得CPU资源。</li><li>yield 临时暂停</li><li>setDaemon 设为守护线程。守护线程的概念是：当一个进程里，所有的线程都是守护线程的时候，结束当前进程。</li></ol><h4 id="多线程的同步问题"><a href="#多线程的同步问题" class="headerlink" title="多线程的同步问题"></a>多线程的同步问题</h4><p>多个线程同时修改一个数据的时候，可能导致的问题。</p><p>解决方式：synchronized同步对象</p><p>synchronized表示当前线程独占某个对象，如果其他线程试图占有对象，就会等待，直到当前线程释放该对象。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121-买卖股票的最佳时机</title>
      <link href="/2020/03/09/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2020/03/09/121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p>示例 1:</p><p>输入: [7,1,5,3,6,4]</p><p>输出: 5</p><p>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</p><p>​     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p><p>示例 2:</p><p>输入: [7,6,4,3,1]</p><p>输出: 0</p><p>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p>方法一：暴力枚举</p><p>使用两个变量 i 和 j ，它们分别表示买进这支股票和卖出这支股票，枚举它们在价格数组上可能出现的所有位置。编码很简单，写一个二重循环即可。</p><p>参考代码 1：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len < <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有可能不做交易，因此结果的初始值设置为 0 </span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < len - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j < len; j++) {</span><br><span class="line">                res = Math.max(res, prices[j] - prices[i]);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>复杂度分析：</p><p>时间复杂度：O(N^2)，这里 N 是股价数组的长度；</p><p>空间复杂度：O(1)</p><p>复杂度较高，提交到 LeetCode 以后排名稍微靠后。</p><p>方法二：针对暴力枚举的优化</p><p>我们发现：其实只需要关心之前（不包括现在）看到的最低股价，于是在遍历的过程中，记录下之前看到的最低股价，就可以省去内层循环。</p><p>参考代码 2：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len < <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 表示在当前位置之前的最小值，假设修正法（打擂台法）</span></span><br><span class="line">        <span class="keyword">int</span> minVal = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 注意：这里从 1 开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < len; i++) {</span><br><span class="line">            res = Math.max(res, prices[i] - minVal);</span><br><span class="line">            minVal = Math.min(minVal, prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>复杂度分析：</p><p>时间复杂度：O(N)</p><p>空间复杂度：O(1)</p><p>方法三：动态规划</p><p>动态规划的 5 个步骤：</p><p>1、设定状态</p><p>这道题其实是一个典型的二维 dp 问题。“动态规划”用于多阶段最优化问题的求解。这里天数代表每个阶段，即一天一天看，设置为第一维。为了消除后效性（前面的状态确定下来以后不会因为后面状态而更改），将当天是否持股设置为第二维的状态。于是：</p><p>状态 dp[i][j] 表示：在索引为 i 的这一天，用户手上持股状态为 j 所获得的最大利润。</p><p>说明：</p><p>j 只有 2 个值：0 表示不持股（特指卖出股票以后的不持股状态），1 表示持股。</p><p>“用户手上不持股”不代表用户一定在索引为 i 的这一天把股票抛售了；</p><p>2、思考状态转移方程</p><p>dp[i][0] 怎样转移？</p><p>dp[i - 1][0] ：当然可以从昨天不持股转移过来，表示从昨天到今天什么都不操作，这一点是显然的；</p><p>dp[i - 1][1] + prices[i]：昨天持股，就在索引为 i 的这一天，我卖出了股票，状态由 1 变成了 0，此时卖出股票，因此加上这一天的股价。</p><p>综上：dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);</p><p>dp[i][1] 怎样转移？</p><p>dp[i - 1][1] ：昨天持股，今天什么都不操作，当然可以从昨天持股转移过来，这一点是显然的；</p><p>-prices[i]：注意：状态 1 不能由状态 0 来，因为事实上，状态 0 特指：“卖出股票以后不持有股票的状态”，请注意这个状态和“没有进行过任何一次交易的不持有股票的状态”的区别。</p><p>因此，-prices[i] 就表示，在索引为 i 的这一天，执行买入操作得到的收益。注意：因为题目只允许一次交易，因此不能加上 dp[i - 1][0]。</p><p>综上：dp[i][1] = max(dp[i - 1][1], -prices[i]);</p><p>3、考虑初始值</p><p>第 0 天不持股，显然 dp[0][0] = 0；</p><p>第 0 天持股，显然dp[0][1] = -prices[0]。</p><p>4、考虑输出</p><p>从状态转移方程可以看出，每一天的状态都考虑了之前的状态。在只发生一次交易的情况下，持有这支股票一定不能使我们获得最大利润。因此输出是 dp[len - 1][0]，不可能是持股的状态 dp[len - 1][1]，</p><p>参考代码 3：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len < <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0：用户手上不持股所能获得的最大利润，特指卖出股票以后的不持股，非指没有进行过任何交易的不持股</span></span><br><span class="line">        <span class="comment">// 1：用户手上持股所能获得的最大利润</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：因为题目限制只能交易一次，因此状态只可能从 1 到 0，不可能从 0 到 1</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < len; i++) {</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>复杂度分析：</p><p>时间复杂度：O(N)</p><p>空间复杂度：O(N)</p><p>说明：如果我们一定要区分“不持有股票”的状态是“一开始不持有”和“卖出股票以后的不持有”，设置 3 个状态即可，我个人认为更加清晰。</p><p>下面状态的设置和状态转移方程均写在代码注释中：</p><p>参考代码 4：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len < <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0：不进行任何操作</span></span><br><span class="line">        <span class="comment">// 1：用户执行了一次买入操作</span></span><br><span class="line">        <span class="comment">// 2：用户执行了一次卖出操作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态转移方程：</span></span><br><span class="line">        <span class="comment">// dp[i][0] 永远等于 0</span></span><br><span class="line">        <span class="comment">// dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i])</span></span><br><span class="line">        <span class="comment">// dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意：如果是 `[7, 6, 5, 4, 3]` 这种波动，应该不交易，</span></span><br><span class="line">        <span class="comment">// 因此输出是：max(dp[len - 1][0], dp[len - 1][2])</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 这里状态 2 不应该有值，设置为 0 不影响正确性</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < len; i++) {</span><br><span class="line">            <span class="comment">// 可以不显式赋值，因为 int 的初值就是 0</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[len - <span class="number">1</span>][<span class="number">0</span>], dp[len - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>复杂度分析：</p><p>时间复杂度：O(N)</p><p>空间复杂度：O(N)</p><p>说明：事实上，这一版代码，由于 dp[i][0] = 0 恒成立，和“参考代码 3”其实是等价的。</p><p>由于 dp[i] 仅仅依赖于 dp[i - 1] ，因此，我们可以使用滚动数组的技巧压缩变量。下面根据“参考代码 3”进行修改：</p><p>参考代码 5：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len < <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < len; i++) {</span><br><span class="line">            dp[i & <span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[(i - <span class="number">1</span>) & <span class="number">1</span>][<span class="number">0</span>], dp[(i - <span class="number">1</span>) & <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i & <span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[(i - <span class="number">1</span>) & <span class="number">1</span>][<span class="number">1</span>], -prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[(len - <span class="number">1</span>) & <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>复杂度分析：</p><p>时间复杂度：O(N)</p><p>空间复杂度：O(1)，状态压缩以后相当于只用了 4 个变量。</p><p>我们继续观察“参考代码 3”，因为状态只能从 1 到 0，即先有状态 1 再有状态 0，我们在填写“状态表 dp” 的时候，只需要用 1 维，因此填表的时候，先写 0 再写 1 即可。</p><p>参考代码 6：（根据“参考代码 3”进行修改）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len < <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < len; i++) {</span><br><span class="line">            dp[<span class="number">0</span>] = Math.max(dp[<span class="number">0</span>], dp[<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[<span class="number">1</span>] = Math.max(dp[<span class="number">1</span>], -prices[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>复杂度分析：</p><p>时间复杂度：O(N)O(N)；</p><p>空间复杂度：O(1)O(1)，状态压缩以后相当于只用了 22 个变量。</p><p>很有意思的是，可以将此时的数组 dp 语义化，dp[1] = Math.max(dp[1], -prices[i]); 等价于 dp[1] = Math.min(dp[1], prices[i]); 其实就是“参考代码 2” 中的 minVal，dp[0] 等价于 “参考代码 2” 中的 res。</p><p>方法四：使用差分数组（参考）</p><p>因为我们关注股票的变化，因此明天减去今天的差价在一定程度上是有研究价值的。我们使用数组 diff 表示差分数组。</p><p>说明：差分 diff 是 difference 的缩写。</p><p>差分数组是这样得到的：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] diff = <span class="keyword">new</span> <span class="keyword">int</span>[len - <span class="number">1</span>]; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < len - <span class="number">1</span>; i++) {</span><br><span class="line">diff[i] = prices[i + <span class="number">1</span>] - prices[i]; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>那么：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff[<span class="number">2</span>] + diff[<span class="number">1</span>] = prices[<span class="number">3</span>] - prices[<span class="number">2</span>] + (prices[<span class="number">2</span>] - prices[<span class="number">1</span>]) =  prices[<span class="number">3</span>] - prices[<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure></div><p>我们再多写几个：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff[<span class="number">3</span>] + diff[<span class="number">2</span>] + diff[<span class="number">1</span>] = (diff[<span class="number">4</span>] - diff[<span class="number">3</span>]) + (prices[<span class="number">3</span>] - prices[<span class="number">2</span>]) + (prices[<span class="number">2</span>] - prices[<span class="number">1</span>]) =  prices[<span class="number">4</span>] - prices[<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure></div><p>我们发现：差分数组的连续子区间和的值，就正好是原始股价数组进行一次交易的差价（后 - 前）。因此，我们可以在差分数组上，求“最大连续子序列的和”，这里参考了「力扣」第 53 题：“最大子序和” 的做法。</p><p>参考代码 7：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (len < <span class="number">2</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 差分数组比原始数组的长度少 1</span></span><br><span class="line">        <span class="keyword">int</span>[] diff = <span class="keyword">new</span> <span class="keyword">int</span>[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < len - <span class="number">1</span>; i++) {</span><br><span class="line">            diff[i] = prices[i + <span class="number">1</span>] - prices[i];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i] 以 diff[i] 结尾的子序列的和的最大值</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len - <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i < len - <span class="number">1</span>; i++) {</span><br><span class="line">            dp[i] = Math.max(diff[i], dp[i - <span class="number">1</span>] + diff[i]);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还是要考虑到 [7 , 6, 5, 4, 3] 这种不交易的情况</span></span><br><span class="line">        <span class="comment">// 初值应该赋值成 0</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < len - <span class="number">1</span>; i++) {</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>复杂度分析：</p><p>时间复杂度：O(N)</p><p>空间复杂度：O(N)</p></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>322-零钱兑换</title>
      <link href="/2020/03/08/322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
      <url>/2020/03/08/322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p><strong>示例 1:</strong></p><p><strong>输入:</strong> coins = [1, 2, 5], amount = 11 <strong>输出:</strong> 3  <strong>解释:</strong> 11 = 5 + 5 + 1</p><p><strong>示例 2:</strong></p><p><strong>输入:</strong> coins = [2], amount = 3 <strong>输出:</strong> -1</p><p><strong>说明</strong>:</p><p>你可以认为每种硬币的数量是无限的。</p><p>动态规划自顶向下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (amount < <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//用数组保存已经计算过的结果（剪枝）</span></span><br><span class="line">        <span class="keyword">return</span> coinChange(coins, amount, <span class="keyword">new</span> <span class="keyword">int</span>[amount]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount, <span class="keyword">int</span>[] count)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (amount < <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(count[amount-<span class="number">1</span>] !=<span class="number">0</span> ) <span class="keyword">return</span> count[amount-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//每次拿一种一个硬币</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins){</span><br><span class="line">            <span class="keyword">int</span> res = coinChange(coins, amount-coin, count);</span><br><span class="line">            <span class="keyword">if</span>(res >= <span class="number">0</span> && min > res)</span><br><span class="line">                min = res;</span><br><span class="line">        }</span><br><span class="line">        count[amount-<span class="number">1</span>] = (min == Integer.MAX_VALUE) ? -<span class="number">1</span> : min + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> count[amount-<span class="number">1</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>动态规划-自底向上：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>{</span><br><span class="line">        <span class="comment">//数量最大是amount，当硬币金额都为1的时候</span></span><br><span class="line">        <span class="keyword">int</span> max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//dp[i]表示总金额为i的结果</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, max);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//逐个计算dp[i]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i <= amount; i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j < coins.length; j++){</span><br><span class="line">                <span class="keyword">if</span>(coins[j] <= i)</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i-coins[j]]+<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dp[amount] > amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java_Deque用法</title>
      <link href="/2020/03/07/Java-Deque%E7%94%A8%E6%B3%95/"/>
      <url>/2020/03/07/Java-Deque%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>​    Deque(Double ended queue)是一种线性集合，其允许在集合两端进行数据的插入和删除操作。大多数的Deque实现没有确定的可保存元素数目，但是在本接口中，仍然提供了对容量限制型的队列的支持。本接口中提供了可以双向访问队列中元素的方法，与基本队列Queue类似，其提供的方法在执行失败时均存在两种处理形式：抛出异常或者返回一个特殊值(一般为null或者false)。其中第二中形式的插入操作是为有容量限制的Deque实现设计，而一般情况下，插入操作不会出现失败的情况。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双端队列 </tag>
            
            <tag> 集合框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题-队列的最大值</title>
      <link href="/2020/03/07/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/2020/03/07/%E9%9D%A2%E8%AF%95%E9%A2%98-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<html><head></head><body><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><p>注意队列的头和尾（左边是尾，右边是头）</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Deque<integer> queue;</integer></span><br><span class="line">    <span class="keyword">private</span> Deque<integer> help;</integer></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>{</span><br><span class="line">        queue = <span class="keyword">new</span> ArrayDeque<>();</span><br><span class="line">        help = <span class="keyword">new</span> ArrayDeque<>();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty() ? -<span class="number">1</span> : help.peekFirst();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//进栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>{</span><br><span class="line">        queue.offerLast(value);</span><br><span class="line">        <span class="keyword">while</span>(!help.isEmpty() && value > help.peekLast()){</span><br><span class="line">            help.pollLast();</span><br><span class="line">        }</span><br><span class="line">        help.offerLast(value);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(queue.isEmpty()){</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> val = queue.pollFirst();</span><br><span class="line">        <span class="keyword">if</span>(help.peekFirst() == val){</span><br><span class="line">            help.pollFirst();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.max_value();</span></span><br><span class="line"><span class="comment"> * obj.push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双端队列 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
